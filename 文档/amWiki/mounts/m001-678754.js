if(typeof AWPageMounts=='undefined'){AWPageMounts={}};AWPageMounts['m001']=[{"name":"00-ReadMe.md","path":"001-前端/01-项目开发调研文档/00-ReadMe.md","content":"# 项目调研文档说明\r\n> 该文件夹存放过往每个任务相应的项目调研、技术调研、开放方案的产出文档。\r\n\r\n## 1. 使用方法\r\n- 积累每次的文档，可以给其他开发者提供一个后续开发的依据\r\n- 开发前完成开发方案，开发完成后回顾之前的开发方案，比较自己预先方案，和最终的实现的方案有什么差别\r\n- 查看他人开发思路，通过积累，不断提高代码设计能力，完善开发思路\r\n- 回顾往期自己的开发方案，看下有没有更好的实现方法\r\n\r\n## 2. 存放规则\r\n- 每个任务建立一个文件夹，命名规则：`序号-任务名称`\r\n- 每个文件夹中包含4个文件：`01-需求文档`、`02-技术难点调研`、`03-开发文档`、`04-其他文档`\r\n\r\n## 3. 存放/修改事件点\r\n- 任务经过分析调研，完成开发方案后，需要进行代码实际开发时存放\r\n- 任务开发完成上线后，回顾方案，修改方案为与实际开发相符的方案\r\n- 长期时间后，回顾方案，尝试新建另一份方案","timestamp":1585877701769},{"name":"01-readme.md","path":"001-前端/02-React/01-readme.md","content":"","timestamp":1585877701769},{"name":"01-readme.md","path":"001-前端/03-Redux/01-readme.md","content":"","timestamp":1585877701769},{"name":"01-readme.md","path":"001-前端/04-Router/01-readme.md","content":"","timestamp":1585877701769},{"name":"01-readme.md","path":"001-前端/05-Antd/01-readme.md","content":"","timestamp":1585877701769},{"name":"01-Web发展史.md","path":"001-前端/07-HTML & CSS/001-Web介绍/01-Web发展史.md","content":"# Web发展史\r\n\r\n### 世界性的信息库\r\n20世纪40年代以来，人们就梦想能拥有一个世界性的信息库。在这个信息库中，信息不仅能被全球的人们存取，而且能轻松地链接到其他地方的信息，使用户可以方便快捷地获得重要的信息。\r\n\r\nGopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，但在WWW出现后，Gopher失去了昔日的辉煌。\r\n\r\n\r\n\r\n### 万维网\r\n<div style=\"overflow:hidden;\">\r\n    <div style=\"width:70%;float:left;\">\r\n        蒂姆·伯纳斯·李发明了他发明了World Wide Web(WWW)。 <br/><br/>\r\n\r\n        在1990年圣诞假期，伯纳斯·李制作了要一个网络工作所必须的所有工具：第一个万维网浏览器（同时也是编辑器）和第一个网页服务器。 <br/><br/>\r\n        WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。 是一个由许多互相链接的超文本组成的系统，通过互联网访问。\r\n\r\n\r\n    </div>\r\n    <div style=\"width:30%;float:left;text-align:center;\">\r\n        <img src=\"amWiki/images/li.png\" width=\"70%\"/>\r\n    </div>\r\n</div>\r\n\r\n> 他并没有为“WWW”申请专利或限制它的使用，而是无偿的向全世界开放。如果给万维网申请专利，他将成为物质上最富有的人。\r\n\r\n\r\n### Web诞生\r\n> 1990年可以看做Web开发历史的起点。\r\n\r\n- 1990年，万维网之父蒂姆·伯纳斯·李（Tim Berners-Lee）开发出了第一个网页浏览器Mosaic，随即很多出色的程序员加入了网页浏览器开发的行列；\r\n- 1993年4月30日，欧洲核子研究组织宣布万维网对任何人免费开放，并不收取任何费用。两个月之后Gopher宣布不再免费，造成大量用户从Gopher转向万维网。\r\n- 1994年10月13日，网景公司开发的浏览器Mosaic Netscape 0.9发布；\r\n- 1994年10月，蒂姆·伯纳斯·李(Tim Berners-Lee) 成立万维网联盟，又称W3C理事会(W3C 致力于对web 进行标准化)。\r\n\r\n\r\n\r\n### WWW\r\n1991 年 8 月 6 日，由伯纳斯·李建立的全世界第一个万维网网站上线。\r\n\r\n<img src=\"amWiki/images/www.png\" width=\"50%\"/>\r\n\r\n<img src=\"amWiki/images/zucheng.png\" width=\"70%\"/>\r\n\r\n\r\n#### HTTP\r\n> HTTP（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送WWW方式的数据\r\n\r\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。\r\n\r\n### 网页从学术机构走向公众社会\r\n万维网（WWW）是欧洲核子研究组织的科学家为了方便看文档、传递论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。\r\n\r\n随着网页从学术机构走向公众社会，网页承载的功能便超出了学术范围而变得愈加丰富。\r\n","timestamp":1585877701769},{"name":"02-网页开发流程.md","path":"001-前端/07-HTML & CSS/001-Web介绍/02-网页开发流程.md","content":"## 网站开发流程\r\n\r\n### 1. 项目规划\r\n\r\n网站作为企业的一种对外宣传方式，每家企业都有自己不同的想法，也提供的是不同的服务，所以用户在咨询的时候，网络公司一般都会根据用户的需求、企业资本还有行业网站的动态来帮助用户进行分析与推荐。\r\n\r\n\r\n### 2. 平台规划\r\n\r\n用户在确定好项目规划后，就可以开始着手网站的开发了，网站开发的第一步是网站的界面设计，由用户提供公司的基本资料，设计师根据自己的经验与行业的特性进行创作，一般是先出首页让用户确定，后续在出内页，页面设计直到用户满意为止。\r\n\r\n### 3. 程序开发\r\n\r\n当页面设计确定之后，页面只是一张静态的图片，想要实现，信息交互，方便用户修改资料，还是需要，程序员来去编写网站程序的。\r\n\r\n#### 前端web工程师\r\n\r\n前端工程师负责把设计好的页面进行，切图然后布局，用代码把页面先进行排版，让页面可以展示在网页上，一般网页上的交互效果也是由前端工程师负责的。\r\n\r\n#### 后端工程师\r\n\r\n前端主要负责的是页面的展示，后端程序员主要的工作就是编写一个后台，方便用户进行管理和修改上传资料。\r\n\r\n根据网站功能规划进行数据库设计和代码编写。系统整合：将程序于界面结合，并实施功能性调试。\r\n\r\n\r\n### 4. 网站测试\r\n首先由项目人员测试：项目经理，监察员及项目开发人员一同根据前期规划对项目进行测试和检验。然后由非项目人员测试：邀请非项目参与人员作为不同的用户角色对平台进行使用性测试。公开测试：网站开通，并接受网友的使用测试，设立反馈信息平台。收集意见和建议信息，针对平台存在的不足进行思考和完善。\r\n\r\n一般通过项目人员测试后由客户进行体验，最好确定没有问题之后，在进行上线，到这里，开发网站的流程就结束了。\r\n\r\n\r\n\r\n\r\n## 前端开发详细流程\r\n> 编写代码 -> 单元测试 -> 检查语法 -> 整合代码 -> 生成文档 -> 压缩代码 -> 部署测试环境 -> 测试 -> 发布\r\n\r\n1. 编写代码： 团队开发详见`“WEB基础” -> “开发标准” -> “协同开发”` 目录\r\n2. 单元测试： 即每个功能模块(类、函数等)的正确性监测\r\n3. 语法检查： \r\n    * html、css语法检查可依赖编辑器(如 VSCode)自带的提示工具\r\n    * 通过浏览器自带的 `“控制台 -> 查看元素”` 可查看html结构以及css样式是否正确\r\n4. 整合代码： 将网页共有部分进行整合(例如网站头部、底部)\r\n5. 压缩代码： 网站上线前可对代码进行压缩，从而加快网站加载速度、节约流量 [在线JS/CSS/HTML 压缩](http://tool.oschina.net/jscompress/)\r\n6. 部署测试环境： 网站发布前需要在服务器中部署网站运行环境，例如wamp等软件的安装。\r\n7. 测试： 将网站放到测试环境中运行检查网页是否有结构问题、网站内容是否完整\r\n8. 发布： 将网站正式放到部署环境。 网站发布方式之一详见`“附录” -> “Coding使用指南”` 目录\r\n\r\n","timestamp":1585877701769},{"name":"03-浏览器内核介绍.md","path":"001-前端/07-HTML & CSS/001-Web介绍/03-浏览器内核介绍.md","content":"# 浏览器的内核(Rendering Engine =>渲染引擎)\r\n> 所谓内核，就是常驻内存、能够快速响应的那一部分核心代码。负责网页语法的解释，并渲染（显示）网页。不同的浏览器内核对网页编写语法的解释也有不同，因此同一页面在不同的内核的浏览器里的渲染（显示）效果也可能不同。这也是浏览器兼容问题产生的一个原因。\r\n\r\n## 浏览器内核的简单工作流程\r\n>渲染引擎在接收到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -> 构建渲染树 -> 渲染树布局 -> 渲染树绘制。\r\n\r\n## PC端\r\n| 内核 | 浏览器 |\r\n| ---- | ---- |\r\n| Trident内核(IE内核) | ie浏览器、360浏览器、猎豹浏览器、2345浏览器、搜狗高速浏览器、UC等 |\r\n| Gecko(Firefox内核) |  Mozilla Firefox(火狐)、Mozilla SeaMonkey、waterfox、AOL for Mac OS X等|\r\n| Webkit   |  Apple Safari、傲游浏览器3、360极速浏览器7.5以前、 360安全浏览器6.0、UC等 |\r\n| Blink | 谷歌、 360安全浏览器7.0、360极速浏览器7.5等  |\r\n| Presto(Opera前内核)  | (已废弃)|\r\n\r\n\r\n### Trident内核,又称其为IE内核。\r\n> Trident（又称为MSHTML），是微软开发的一种排版引擎。因IE捆绑在Windows中，所以占有极高的份额,它曾脱离W3C标准，后果就是大量的网页是专门为IE6等老trident内核编写，但这些网页的代码并不符合w3c标准,所以也就导致了我们要为早期IE的浏览器做兼容。其实不是浏览器的兼容性差了，而是你访问的的网页不符合新的标准，所以IE内核的浏览器存在很多兼容性的问题。\r\n\r\n#### 使用Trident内核的浏览器\r\n>IE浏览器、世界之窗、360安全浏览器兼容模式、遨游、搜狗浏览器、腾讯TT、UC浏览器（Webkit内核+Trident内核）；其中部分版本的浏览器是双核浏览器，甚至是多核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。\r\n\r\n### Gecko内核\r\n> FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。因为它是开源的，所以收到很多人的青睐，其可开发程度很高。Gecko是最流行的排版引擎之一.仅次于Trident。\r\n\r\n#### 使用Gecko内核的浏览器\r\n>  Mozilla Firefox(火狐)、Mozilla SeaMonkey、waterfox、AOL for Mac OS X等\r\n\r\n### WebKit内核(Chromium)\r\n> Webkit(Safari内核,Chrome内核原型,开源):它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome(曾经)\r\n\r\n#### 使用webkit内核的浏览器\r\n> apple 的safari(win/mac/iphone/ipad)、塞班手机浏览器、Android手机默认的浏览器、 360安全浏览器6.0、360极速浏览器7.5之前、猎豹安全浏览器1.0-4.2、傲游浏览器3.X、UC浏览器等\r\n\r\n### Blink内核\r\n>Blink是一个由Google和Opera Software开发的浏览器排版引擎,谷歌原来使用苹果的WebKit内核，后转向Blink内核，谷歌此举欲降低Webkit即苹果在浏览器市场的影响力。Opera也采用其Blink浏览器核心。\r\n\r\n#### 使用Blink内核的浏览器\r\n>谷歌浏览器、Opera、360安全浏览器7.0、360极速浏览器7.5、猎豹安全浏览器4.3以后等\r\n\r\n\r\n#### 应用\r\n> 浏览器内核的不同导致了CSS3的属性在不同的浏览器存在兼容性\r\n为了解决这个问题，我们需要在一些属性前面添加前缀\r\n\r\n| 核心 |   前缀   |\r\n| :------------- | :------------- |\r\n|    Trident   | -ms-      |\r\n|    Gecko   | -moz-      |\r\n|    WebKit内核   | -webkit-      |\r\n|    Presto   | -o-      |\r\n\r\n\r\n\r\n\r\n## 移动端浏览器内核\r\n> 移动端的浏览器还是比统一的，基本是webkit内核，和少部分的的IE浏览器内核。\r\n所以在我们去考虑移动端的布局的时候，我们最主要考虑的还是webkit。也就是几乎所有的属性和特性，移动端都是支持的。 \r\n\r\n* IE手机版和PC版皆为Trident内核的\r\n* Opera手机版和PC版皆为Webkit内核（少部分版本仍然是Presto内核）\r\n* Firefox手机版和PC版皆为Gecko内核\r\n* Chrome手机版和PC版皆为Webkit内核\r\n* Safari手机版和PC版皆为Webkit内核\r\n* QQ手机浏览器内核为基于Webkit修改的X5内核\r\n* UC手机浏览器内核为基于Webkit修改的U3内核\r\n* 百度手机浏览器内核为基于Webkit修改的T5内核\r\n* 360手机浏览器内核为基于Chrome修改的G5内核，Chrome、Chromium的内核就是Webkit排版引擎，所以又有的说是采用了Webkit。\r\n","timestamp":1585877701769},{"name":"001-Markdown介绍.md","path":"001-前端/07-HTML & CSS/002-开发工具/01-MarkDown语法指南/001-Markdown介绍.md","content":"# Markdoen 介绍\r\nMarkdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。\r\n\r\n## 使用 Markdown 的优点\r\n* 专注你的文字内容而不是排版样式，安心写作。\r\n* 轻松的导出 HTML、PDF 和本身的 .md 文件。\r\n* 纯文本内容，兼容所有的文本编辑器与字处理软件。\r\n* 随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。\r\n* 可读、直观、学习成本低。\r\n\r\n## 使用方法\r\n新建`.md`后缀文件，即可按照 Markdown 语法进行编辑。\r\n\r\n## 使用环境\r\n### MarkdownPad\r\nMarkdownPad是Windows下的一个多功能Markdown编辑器。\r\n\r\n<a href=\"http://markdownpad.com/download.html\">\r\n<img src=\"amWiki/images/Markdown_logo.png\" width=\"150\"/> <br>\r\nMarkdownPad2 下载地址\r\n</a>\r\n\r\n### WebStorm\r\n下载 Markdown 语法支持插件\r\n\r\n<img src=\"amWiki/images/markdown_webstorm.png\" width=\"1000\"/> <br>\r\n\r\n### Sublime Text\r\n<a href=\"http://www.jianshu.com/p/049e2fdb55ae\">安装 Markdown 语法支持插件教程</a>\r\n\r\n### 有道云笔记\r\n使用有道云笔记也可新建Markdown文件，并且手机、pc等都可进行查看、修改。\r\n\r\n<img src=\"amWiki/images/markdown_youdao.png\" />\r\n","timestamp":1585877701769},{"name":"002-Markdown语法.md","path":"001-前端/07-HTML & CSS/002-开发工具/01-MarkDown语法指南/002-Markdown语法.md","content":"# Markdown基础语法\r\n\r\n## 基础入门\r\n\r\n### 标题标签\r\n```\r\n# 一级标题\r\n## 二级标题\r\n### 三级标题\r\n#### 四级标题\r\n##### 五级标题\r\n###### 六级标题\r\n```\r\n效果：\r\n# 一级标题\r\n## 二级标题\r\n### 三级标题\r\n#### 四级标题\r\n##### 五级标题\r\n###### 六级标题\r\n\r\n### 修辞和强调\r\n  使用星号和底线来标记需要强调的区段\r\n> 在Atom中有相应的快捷方式，只要输入 `b`,`i`也会有相应的提示。  \r\n\r\n```\r\n**加粗**\r\n\r\n__加粗__\r\n\r\n*斜体*\r\n\r\n_斜体_\r\n\r\n```\r\n效果：\r\n  **加粗**\r\n  __加粗__\r\n  *斜体*\r\n  _斜体_\r\n\r\n### 删除线\r\n```\r\n  ~~要删除的内容 ~~\r\n```\r\n效果：\r\n  ~~要删除的内容~~\r\n\r\n### 列表\r\n####  无序列表 使用星号、加号和减号来做为列表的项目标记，并且支持列表嵌套。\r\n\r\n```\r\n  * SublimeText3使用说明\r\n  + Git和Svn的使用说明\r\n  - Hexo和Github搭建个人博客\r\n    + 环境搭建\r\n    - 安装Hexo\r\n```\r\n* SublimeText3使用说明\r\n+ Git和Svn的使用说明\r\n- Hexo和Github搭建个人博客\r\n  + 环境搭建\r\n  - 安装Hexo\r\n\r\n#### 有序列表 则是使用一般的数字接着一个英文句点作为项目标记\r\n按照书写顺序排列，不按照序列号\r\n1. Kevin\r\n2. Json\r\n3. Nico\r\n4. Money\r\n\r\n### 链接\r\n方括号后面跟小括号，方括号中写文字，小括号中写链接。也可以 ` l + enter`\r\n\r\n```\r\n[uek](https://www.uekedu.com)\r\n```\r\n[uek](https://www.uekedu.com)\r\n\r\n### 图片\r\n叹号方括号后面跟小括号，方括号中写文字，小括号中写地址。也可以 ` img + enter`\r\n\r\n```\r\n![Web](amWiki/images/zucheng.png)\r\n```\r\n![Web](amWiki/images/zucheng.png)\r\n\r\n\r\n### 代码\r\n使用反引号 来标记代码区段\r\n\r\n```\r\n 我是`code`，`<div>division</div>`\r\n```\r\n 我是`code`，`<div>division</div>`\r\n\r\n\r\n### 代码段\r\n\r\n如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了\r\n\r\n```\r\n  for(var i=0;i<10;i++){\r\n    console.log(i);\r\n  }    \r\n```\r\n\r\n### 表格\r\n\r\n使用竖线分割内容，且同时使用“---”与“:”指定对齐方式。自动补全功能 `table + enter`\r\n\r\n```\r\n| 姓名 | 年龄 | 性别\r\n| -------- | :------: | ---:\r\n| 默认 | 居中 | 右\r\n```\r\n\r\n| 姓名 | 年龄 | 性别\r\n| -------- | :------: | ---:\r\n| 程鹏 | 18 | 男\r\n\r\n### 引用\r\n只需要在文本前加入 > 这种尖括号（大于号）即可。为了防止将多余的文本也变成引用，在引用前后加换行。\r\n\r\n```\r\n> 引用的内容\r\n```\r\n\r\n> 引用的内容\r\n\r\n### 分割线\r\n三个横线\r\n```\r\n---\r\n```\r\n---\r\n\r\n### 换行\r\n只需要俩个以上的空格\r\n\r\n  我是第一行  \r\n  我是第二行\r\n\r\n### html\r\n可以直接在文档里书写 HTML，不需要额外标注这是 HTML\r\n\r\n      <b>division</b>\r\n\r\n  <b>division</b>\r\n\r\n### 语法高亮\r\n使用两组每组三个反引号分单独两行将代码包围起来，并在第一组反引号后写上语言类型即可使用语法高亮。自动补全功能 ` code + enter`\r\n\r\n#### js/javascript\r\n普通格式\r\n```\r\n{\r\n    \"state\": {\r\n        \"code\": 10200,                   //code状态码\r\n        \"msg\": \"ok\"                      //状态描述\r\n    },\r\n    \"data\": {\r\n        \"team_num\": 13,                  //队伍数\r\n        \"position\": \"海珠区新港中路\"      //位置\r\n    }\r\n}\r\n```\r\n\r\n加入语法标识\r\n```js\r\n{\r\n    \"state\": {\r\n        \"code\": 10200,                   //code状态码\r\n        \"msg\": \"ok\"                      //状态描述\r\n    },\r\n    \"data\": {\r\n        \"team_num\": 13,                  //队伍数\r\n        \"position\": \"海珠区新港中路\"      //位置\r\n    }\r\n}\r\n```\r\n\r\n其他语言和js类似，只需要在第一组的三个 \\`\\`\\`后添加语言标志即可。如html，js，css，sql等。\r\n","timestamp":1585877701769},{"name":"01-Sublime Text3介绍.md","path":"001-前端/07-HTML & CSS/002-开发工具/02-SublimeText3使用指南/01-Sublime Text3介绍.md","content":"# Sublime Text3介绍 \r\n作为一个前端，有一款好的开发利器是必不可少的，editplus、notepad++都是不错的工具，体积轻巧，启动迅速。几年前，又有一款新的编辑器诞生，席卷前端界，惹得无数喜爱，不少前端er纷纷抛弃用了数年的“伙伴”，投入了她的怀抱——最新版Sublime Text 3。ST3是一款跨平台的编辑器，再也不用为换平台而找不到合适的、熟悉的编辑器担忧了。\r\n\r\nSublime Text 3 是一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。\r\n\r\n## 整体界面\r\n\r\n![整体界面](amWiki/images/interface1.png)\r\n\r\n## 保存贴心提示\r\n如果没有保存会当前编辑文件会有一个小圆点显示\r\n\r\n<img src=\"amWiki/images/save.png\" width=\"600\"/>\r\n\r\n## 概览\r\n- 标签（Tab）：无需介绍。\r\n- 编辑区（Editing Area）：无需介绍。\r\n- 侧栏（Side Bar）：包含当前打开的文件以及文件夹视图。\r\n- 缩略图（Minimap）：如其名。\r\n- 命令板（Command Palette）：Sublime Text的操作中心，它使得我们基本可以脱离鼠标和菜单栏进行操作。\r\n- 控制台（Console）：使用Ctrl + \\` 调出，它既是一个标准的Python REPL，也可以直接对Sublime Text进行配置。\r\n- 状态栏（Status Bar）：显示当前行号、当前语言和Tab格式等信息。\r\n\r\n![整体界面](amWiki/images/interface2.png)\r\n","timestamp":1585877701769},{"name":"02-SublimeText3使用.md","path":"001-前端/07-HTML & CSS/002-开发工具/02-SublimeText3使用指南/02-SublimeText3使用.md","content":"# SublimeText3使用\r\n## 插件安装\r\n### Package Control安装\r\n1. 打开包管理工具：\r\n    * 点击菜单栏的“首选项(N)”-->\"Package Control\",或者可以使用快捷键CTRL+SHIFT+P 打开\r\n2. 在打开的终端窗口，输入“install”,下方就会提示“Package Control:install package”,用鼠标点击\r\n  ![Alt + F3](amWiki/images/installPackage.png)\r\n3. 这时候等待几秒，就会弹出一输入框端，在输入框输入你想要安装的插件，点击之后就可以自动安装插件。\r\n4. 重启sublime text3就可以使用插件\r\n\r\n### 直接安装\r\n> 如果Package Control打不开，可以直接下载好想要的插件，然后打开sublime插件所在位置将插件文件放进入\r\n\r\n1. 菜单栏“首选项(N)”-->\"浏览插件目录(B)\"打开插件包位置\r\n2. 将下载好的插件复制到该文件夹中，重启sublime 即可\r\n\r\n\r\n## sublime text3 常用插件\r\n* ChineseLocalizations     汉化插件(中英日文)\r\n* Emmet   html于css缩写，代码提示\r\n* Autoprefixer    css前缀自动补全\r\n* lessc   自动编译less文件\r\n* MarkdownEditing   支持markdown编辑\r\n* OmniMarkupPreviewer   可在浏览器中查看markdown效果\r\n\r\n\r\n## SublimeText3常用快捷键\r\n\r\n* Ctrl + /  ---------------------注释\r\n\r\n* Ctrl + 滚动　--------------字体变大/缩小\r\n\r\n* Ctrl + N-------------------新建\r\n\r\n* Ctrl+Shift +k -----------删除一行\r\n\r\n* Alt + Shift + 数字  -----------编辑器分栏\r\n\r\n* Alt + . ------------快速闭合标签\r\n\r\n* Ctrl + 回车 -----------添加一行空行\r\n\r\n* Ctrl + Shift +V --------粘贴过程中保持缩进\r\n\r\n* Alt + F3 ---------------选中选择的词\r\n\r\n![Alt + F3](amWiki/images/AltF3.jpg)\r\n\r\n* Ctrl + W ---------------关闭当前文档\r\n\r\n* Ctrl + H ---------------替换\r\n\r\n* Ctrl + ] ---------------右缩进\r\n\r\n* Ctrl + [ ---------------左缩进\r\n\r\n* Ctrl + ← ---------------向左单位性地移动光标，快速移动光标。\r\n\r\n* Ctrl + → ---------------向右单位性地移动光标，快速移动光标。\r\n\r\n* Ctrl + K + U ---------------转换大写。\r\n\r\n* Ctrl + K + L ---------------转换小写。\r\n","timestamp":1585877701769},{"name":"03-Emmet插件.md","path":"001-前端/07-HTML & CSS/002-开发工具/02-SublimeText3使用指南/03-Emmet插件.md","content":"# Emmet插件\r\nEmmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具。\r\n\r\n\r\n## 快速编写HTML代码\r\n### 初始化页面结构\r\nHTML文档需要包含一些固定的标签，比如`<html>`、`<head>`、`<body>`等，现在你只需要1秒钟就可以输入这些标签。\r\n\r\n比如输入“!”或“html:5”，然后按Tab键：\r\n\r\n![初始化](amWiki/images/init.gif)\r\n\r\n- html:5 或!：用于HTML5文档类型\r\n- html:xt：用于XHTML过渡文档类型\r\n- html:xxs：用于XHTML严格文档类型\r\n- html:4s：用于HTML4严格文档类型\r\n\r\n### 添加类、id、文本和属性\r\n连续输入元素名称和ID 并按下Tab，Emmet会自动为你补全，比如输入p#foo：\r\n![添加类id文本属性](amWiki/images/attr.gif)\r\n#### 添加类\r\n```\r\np.box\r\n\r\n按下Tab\r\n\r\n<p class=\"box\"></p>\r\n```\r\n#### 添加id\r\n```\r\np#boxmmm\r\n\r\n按下Tab\r\n\r\n<p id=\"box\"></p>\r\n```\r\n#### 添加文本\r\n```\r\np{hello}\r\n\r\n按下Tab\r\n\r\n<p>hello</p>\r\n```\r\n\r\n\r\n#### 添加属性\r\n##### 属性结合内容\r\n```\r\na[href=http://www.baidu.com]{百度一下}\r\n\r\n按下Tab\r\n\r\n<a href=\"http://www.baidu.com\">百度一下</a>\r\n```\r\n\r\n##### 多个属性\r\n```\r\ninput[type=search][placehodler=搜索内容]\r\n\r\n按下Tab\r\n\r\n<input type=\"search\" placehodler=\"搜索内容\">\r\n```\r\n#### 结合使用\r\n```\r\ndiv#box.container[title=容器标签]{你好}\r\n\r\n按下Tab\r\n\r\n<div id=\"box\" class=\"container\" title=\"容器标签\">你好</div>\r\n```\r\n\r\n### 嵌套\r\n现在你只需要1行代码就可以实现标签的嵌套。\r\n\r\n- \\>：子元素符号，表示嵌套的元素\r\n- +：同级标签符号\r\n- ^：可以使该符号前的标签提升一行\r\n\r\n![嵌套](amWiki/images/qiantao.gif)\r\n\r\n#### 嵌套\r\n```\r\np>span\r\n\r\n按下Tab\r\n\r\n<p><span></span></p>\r\n```\r\n\r\n#### 同级\r\n```\r\nh1+h2\r\n\r\n按下Tab\r\n\r\n<h1></h1>\r\n<h2></h2>\r\n```\r\n### 提升一行\r\n```\r\np>span^div\r\n\r\n按下Tab\r\n\r\n<p><span></span></p>\r\n<div></div>\r\n```\r\n\r\n### 分组\r\n你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo>h1)+(.bar>h2)，会自动生成如下代码：\r\n\r\n![分组](amWiki/images/group.gif)\r\n\r\n```\r\n(.foo>h1)+(.bar>h2)\r\n\r\n按下Tab\r\n\r\n<div class=\"foo\">\r\n\t<h1></h1>\r\n</div>\r\n<div class=\"bar\">\r\n\t<h2></h2>\r\n</div>\r\n```\r\n\r\n### 隐式标签\r\n\r\n声明一个带类的标签，只需输入div.item，就会生成`<div class=\"item\"></div>`\r\n\r\n在过去版本中，可以省略掉div，即输入.item即可生成`<div class=\"item\"></div>`。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在`<ul>`中输入.item，就会生成`<li class=\"item\"></li>`。\r\n\r\n![隐式标签](amWiki/images/tag.gif)\r\n\r\n下面是所有的隐式标签名称：\r\n\r\n- li：用于ul和ol中\r\n- tr：用于table、tbody、thead和tfoot中\r\n- td：用于tr中\r\n- option：用于select中\r\n\r\n\r\n### 定义多个元素\r\n要定义多个元素，可以使用*符号。比如，ul>li*3可以生成如下代码：\r\n\r\n![多个标签](amWiki/images/tags.gif)\r\n\r\n```\r\nul>li*3\r\n\r\n按下Tab\r\n\r\n<ul>\r\n\t<li></li>\r\n\t<li></li>\r\n\t<li></li>\r\n</ul>\r\n```\r\n### 定义多个带属性的元素\r\n\r\n```\r\nul>li.item$*3{列表$}\r\n\r\n按下Tab\r\n\r\n<ul>\r\n\t<li class=\"item1\">列表1</li>\r\n\t<li class=\"item2\">列表2</li>\r\n\t<li class=\"item3\">列表3</li>\r\n</ul>\r\n```\r\n![多个标签属性](amWiki/images/tagsattrs.gif)\r\n## 快速编写CSS代码\r\n### 值\r\n\r\n比如要定义元素的宽度，只需输入w100，即可生成\r\n```\r\nw100\r\n\r\n按下Tab\r\n\r\nwidth: 100px;  \r\n```\r\n![值](amWiki/images/cssval.gif)\r\n\r\n除了px，也可以生成其他单位，比如输入h10p+m5e，结果如下：\r\n```\r\nh10p+m5e\r\n\r\n按下Tab\r\n\r\nheight: 10%;  \r\nmargin: 5em;  \r\n```\r\n\r\n单位别名列表：\r\n- p 表示%\r\n- e 表示 em\r\n- r 表示 rem\r\n\r\n### 附加属性\r\n\r\n可能你之前已经了解了一些缩写，比如 @f，可以生成：\r\n```\r\n@f\r\n\r\n按下Tab\r\n\r\n@font-face {  \r\n  font-family:;  \r\n  src:url();  \r\n}  \r\n```\r\n![@f](amWiki/images/@f.gif)\r\n\r\n一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成，比如输入@f+，将生成：\r\n\r\n```\r\n@f+\r\n\r\n按下Tab\r\n\r\n@font-face {\r\n\tfont-family: \'FontName\';\r\n\tsrc: url(\'FileName.eot\');\r\n\tsrc: url(\'FileName.eot?#iefix\') format(\'embedded-opentype\'),\r\n\t\t url(\'FileName.woff\') format(\'woff\'),\r\n\t\t url(\'FileName.ttf\') format(\'truetype\'),\r\n\t\t url(\'FileName.svg#FontName\') format(\'svg\');\r\n\tfont-style: normal;\r\n\tfont-weight: normal;\r\n}\r\n```\r\n\r\n```\r\nbg+  background: #fff url() 0 0 no-repeat;\r\n\r\nbr+ border-right: 1px solid #000;\r\n\r\nf+ font: 1em Arial,sans-serif;\r\n\r\nto+ text-outline: 0 0 #000;\r\n```\r\n\r\n### 模糊匹配\r\n\r\n如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的：\r\n```\r\novh\r\n\r\n按下Tab\r\n\r\noverflow: hidden;\r\n```\r\n![模糊匹配](amWiki/images/ovh.gif)\r\n\r\n\r\n### 浏览器前缀\r\n如果输入非W3C标准的CSS属性，Emmet会自动加上浏览器前缀，比如输入trs，则会生成：\r\n\r\n```\r\ntrs\r\n\r\n按下Tab\r\n\r\n-webkit-transform: ;  \r\n-moz-transform: ;  \r\n-ms-transform: ;  \r\n-o-transform: ;  \r\ntransform: ;\r\n```\r\n![前缀](amWiki/images/qianzhui.gif)\r\n\r\n\r\n如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-border-radius表示只加上-webkit和-moz前缀：\r\n\r\n```\r\n-wm-border-radius\r\n\r\n按下Tab\r\n\r\n-webkit-border-radius: ;\r\n-moz-border-radius: ;\r\nborder-radius: ;\r\n```\r\n\r\n前缀缩写如下：\r\n\r\n- w 表示 -webkit-\r\n- m 表示 -moz-\r\n- s 表示 -ms-\r\n- o 表示 -o-\r\n","timestamp":1585877701769},{"name":"03-开发常用工具.md","path":"001-前端/07-HTML & CSS/002-开发工具/03-开发常用工具.md","content":"# 开发常用工具\r\n\r\n设计师给出静态的高保真图片， 需要前端工程师按照高保真图，进行html编码。\r\n\r\n前端工程师，一般工作方法为：打开图片，一边看下图片，一边编写相应的html代码。这样有两个问题：\r\n\r\n1. 前端工程师比较累， 不停切换 图片和 编辑器， 操作频繁。手累！\r\n2. 编写出来的html页面，不一定跟设计师的图片完全吻合。\r\n\r\n因此借助一些切图工具和原型工具可以帮助我们更加高效、准确地进行页面布局\r\n\r\n## 截图(测量)工具  FastoneCapture\r\n>FastoneCapture是一款集成视频录制，截屏，取色于一体的软件，具有功能强大操作简单的特点。\r\n\r\n<a href=\"/download/最好的截图软件.exe\" download=\"最好的截图软件.exe\">点击下载</a>\r\n百度网盘链接：https://pan.baidu.com/s/1kk45mQMZAN8MXAdtLlrmRQ\r\n提取码：9t6j\r\n\r\n#### 软件使用\r\n1. 下载完成之后，双击打开，桌面就会出现下图所示的内容，便可以使用  \r\n<img src=\"amWiki/images/最好的截图软件.jpg\"/>\r\n2. 鼠标悬停在菜单栏上，就是出现对应的提示信息，这个软件对应着多种截图形式。\r\n3. 菜单栏的最后一项的设置，屏幕放大和取色器就在这设置里。你也可以给软件设置你想要的快捷键。\r\n\r\n\r\n\r\n\r\n## 切图工具\r\n\r\n### pxCook\r\n> PxCook（像素大厨）是一款切图设计工具软件。可自动识别psd文件中的文字、颜色、距离等信息并添加标注，以及自带单位转化、取色器、放大镜等工具，方便开发人员读取psd文件信息。\r\n\r\n#### 安装使用\r\n1. 先下载并安装依赖工具 [Adobe AIR](https://get.adobe.com/cn/air/)   \r\n2. 下载安装 [PxCook](http://www.fancynode.com.cn/pxcook)\r\n\r\n![PxCook软件截图](assets/001/04-1541558566000.png)\r\n\r\n### Cutterman\r\n> Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 \"导出web所用格式\" 以及使用切片工具进行挨个切图的繁琐流程。 支持各种各样的图片尺寸、格式、形态输出，方便在pc、ios、Android等端上使用。\r\n\r\n1. 下载对应安装程序, 注意选择适合你PS的版本, 不然安装不上\r\n2. 解压下载的安装包, 里面是一个exe文件, 双击打开, 如图\r\n3. 不要修改默认的安装路径,点击安装即可\r\n4. 安装完成后重启PS, 从菜单栏 -> 窗口 -> 扩展里头打开\r\n\r\n> 注： 所有插件都不再提供CS6的版本, 并且即将暂停对CC版本的支持, 请尽快升级您的PS到最新版本\r\n\r\n\r\n## 原型工具\r\n> 原型：用线条、图形描绘出的产品框架，也称线框图。是一个综合考虑产品目标、功能需求场景、用户体验等因素，对产品的各版块、界面和元素进行的合理性排序过程\r\n\r\n\r\n![原型设计](assets/001/04-1541559707000.png)\r\n\r\n### 蓝湖\r\n> 蓝湖，产品设计协作平台＆原型制作工具，支持团队合作、在线讨论、自动为设计图生成标注，只需简单几步就能将设计图变成一个可以点击的演示原型，支持分享给同事，让他也可以在手机中查看设计效果。\r\n\r\n蓝湖是一个Sketch 插件，只能在mac上安装，也可以直接访问网页版使用（需注册账号）：[蓝湖](https://lanhuapp.com/web/#/item)\r\n\r\n<img src=\"assets/001/04-1541560373000.png\" width=\"60%\" />\r\n### 墨刀\r\n> 墨刀是一款在线原型设计工具。借助于墨刀，创业者、产品经理及UI/UX设计师能够快速构建移动应用产品原型，并向他人演示  [墨刀](https://modao.cc/workspace/apps)\r\n\r\n* 提供所有屏幕分辨率尺寸切图，一键下载\r\n* 获取设计稿中每个元素的 CSS、Swift、Android 代码\r\n* 适配不同分辨率设备，精准换算 iOS、Android 及 PC 端所有像素单位\r\n* 自由吸取设计文件颜色\r\n\r\n<img src=\"assets/001/04-1541560965000.png\" width=\"60%\" />\r\n\r\n\r\n## 图片压缩\r\n一般网站中图片肯定是不可或缺的。如果图片不经过处理，那么会导致加载速度很慢，并且浪费流量\r\n### 1. 使用PhotoShop压缩\r\n载入图片 -> 点击\"文件\"-\"保存为WEB格式文件\"(快捷键 ctrl + alt + shift + S) -> 参数配置(图片格式、压缩质量、压缩级别、图片大小) -> 点击”存储”进行导出\r\n\r\n<img src=\"assets/001/04-1542062901000.png\" width=\"60%\" />\r\n\r\n### 2. 在线压缩\r\n\r\n| 类别 | 描述    |\r\n| :------------- | :------------- |\r\n| [picdiet在线压缩](https://www.picdiet.com/zh-cn )     | 可以批量处理，效果还不错，但是只支持jpg/jpeg       |\r\n| [智图](https://zhitu.isux.us/)  |  可在线进行图片压缩，也可下载客户端本地使用。 |\r\n\r\n### 3. 本地压缩(智图)\r\n智图能够自动为你选择压缩率压缩并且在合适的情况下为你选择正确的图片格式。操作十分简单，与此同时，智图也会为你上传的图片转换一份webP格式的图片。\r\n\r\n下载地址：[智图下载](https://zhitu.isux.us/index.php/preview/download)\r\n安装教程：[智图安装教程](https://zhitu.isux.us/index.php/preview/install)\r\n\r\n客户端界面\r\n\r\n<img src=\"amWiki/images/zhitu.jpg\" width=\"60%\"/>\r\n\r\n客户端右上角 设置 还支持生成WebP、替换原图、深度压缩。\r\n\r\n只需要将要优化的图片拉至首页的拖拽区域后，系统会自动上传图片并经过智图压缩，返回新的图片。你也可以根据自己的实际使用情况选择不同的压缩率。\r\n","timestamp":1585877701769},{"name":"001-Chrome开发者工具介绍.md","path":"001-前端/07-HTML & CSS/002-开发工具/04-Chrome调试工具使用指南/001-Chrome开发者工具介绍.md","content":"# 谷歌开发者工具介绍\r\n作为一名前端开发工程师，相信你也不会对Chrome浏览器感到陌生。根据最新的的浏览器市场占有率报告（2017.03-2017.06），Chrome近乎占有浏览器天下的半壁江山。Chrome是一个强大的浏览器，不仅访问网页速度快，体积不大，支持的新特性也比其它浏览器多，而且提供了功能强大的分析工具，接下来，我们开始认识一下这些调试工具。\r\n\r\n\r\n## 打开方式\r\n在网页的空白处，点击鼠标右键调出菜单，然后选择检查（某些浏览器叫做“审查元素”）；或按快捷键F12就可以轻松的打开开发者工具。\r\n\r\n<img src=\"amWiki/images/chrome_open.png\" width=\"1000\"/>\r\n\r\n开发者工具打开之后如图所示\r\n\r\n<img src=\"amWiki/images/chrome_all.png\" width=\"1000\"/>\r\n\r\n\r\n## 位置调整\r\n可在控制台右上角处调整工具位置：\r\n\r\n<img src=\"amWiki/images/chrome_wz.png\"/>\r\n\r\n对应下方三个选项分别为：①在新窗口打开、②在浏览器下方打开、③在浏览器右侧打开。\r\n\r\n\r\n## 开发者工具功能\r\nChrome开发者工具功能很多，我们着重介绍其中两大常用功能：\r\n* **Elements**    （审查元素）\r\n* **Console**   （控制台）\r\n\r\n<img src=\"amWiki/images/chrome_menu.png\"/>\r\n","timestamp":1585877701769},{"name":"002-Chrome查看元素使用.md","path":"001-前端/07-HTML & CSS/002-开发工具/04-Chrome调试工具使用指南/002-Chrome查看元素使用.md","content":"# Elements 查看元素\r\n打开开发者工具选择（默认）`Element`功能，Element功能非常实用，可以用来查看网页布局结构以及样式。  \r\n\r\n\r\n在Element中主要分两块大的部分  \r\n* A部分：HTML结构面板\r\n* B部分：CSS样式、结构\r\n\r\n<img src=\"amWiki/images/chrome_elements.png\" width=\"1000\"/>\r\n\r\n\r\n## A部分：HTML结构面板\r\n### 选择元素\r\n**在HTML结构面板中，每当你的鼠标移动到任何一个元素上，对应的html视图中会给该元素蓝色的背景。**\r\n\r\n<img src=\"amWiki/images/chrome_hover.png\" width=\"1000\"/>\r\n\r\n<br>\r\n**如果你单击选中一个元素，在A部分的底部，会显示该元素在html结构中的位置关系：**\r\n\r\n<img src=\"amWiki/images/chrome_click.png\"/>\r\n\r\n<br>\r\n**可以通过点击左上角箭头工具，鼠标经过页面时会高亮显示对应的html标签。**\r\n\r\n<img src=\"amWiki/images/chrome_xuan.png\" width=\"1000\"/>\r\n\r\n\r\n\r\n### 修改元素\r\n**双击标签属性、内容可以进行修改。**<br>\r\n<img src=\"amWiki/images/chrome_change2.png\"/>\r\n<br>\r\n\r\n## B部分：CSS样式、结构\r\n**单击选中一个元素之后，可以在B部分看到该元素所有CSS样式，以及该样式所在CSS文件第几行。**\r\n\r\n<img src=\"amWiki/images/Chrome_css.png\"/>\r\n\r\n<br>\r\n**可以在B部分的styles选项中修改、注释（取消勾选样式前的对钩）该元素的样式，还可点击样式空白位置新增CSS样式，并且看到html结构的实时更新（大大的福利）。**\r\n\r\n<img src=\"amWiki/images/chrome_change.png\"/>\r\n","timestamp":1585877701769},{"name":"003-Chrome控制台使用.md","path":"001-前端/07-HTML & CSS/002-开发工具/04-Chrome调试工具使用指南/003-Chrome控制台使用.md","content":"# Console    控制台\r\n打开chrome浏览器，按f12，选择`Console`就可以轻松的打开控制台。\r\n\r\n> 在界面重构阶段， console 主要用来查看网页报错，如css、图片路径错误时会将错误信息输出到控制台\r\n\r\n##　js代码编写\r\n控制台主要是显示JS文件里面打印的日志信息(console对象)。你也可以直接在里面写javascript，查看或修改当前作用域的变量信息。  \r\n如果是当前作用域内的对象（包含全局对象）的话，console还会自动帮你补全，有时候我忘记某个对象有什么方法，可以会用这个来看。\r\n\r\n<img src=\"amWiki/images/chrome_console.png\"/>\r\n\r\n如果想清空控制台，可以点击左上角那个<img src=\"amWiki/images/chrome_clear.png\" style=\"vertical-align: middle;\"/>来清空。\r\n\r\n\r\n## console对象\r\n可以通过输出`console`查看Console对象上的方法：\r\n\r\n<img src=\"amWiki/images/chrome_console2.png\"/>\r\n\r\n### 常用输出\r\n| 语法 | 含义 |\r\n|----|----|\r\n| console.log | 普通信息 |\r\n| console.error | 错误信息 |\r\n| console.warn | 警示信息 |\r\n| console.table | 以表格的形式将数据输出 |\r\n| console.dir | 将DOM结点以对象的形式输出到控制台 |\r\n","timestamp":1585877701769},{"name":"01-html简介、标签.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/01-html简介、标签.md","content":"# 第一阶段html、css初始\r\n##  名词解释\r\n### w3c（World Wide Web Consortium，W3C）： 万维网联盟\r\n>World Wide Web Consortium（W3C），又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立建立者是万维网的发明者蒂姆·伯纳斯-李。W3C为解决 Web 应用中不同平台、技术和开发者带来的不兼容问题，保障 Web 信息的顺利和完整流通，万维网联盟制定了一系列标准并督促 Web 应用开发者和内容提供者遵循这些标准\r\n\r\n### 网站\r\n>网站 是构成web的基础 ， 所谓网站(Website)，就是指在网际网路（万维网）上，根据一定的规则，使用HTML等工具制作的用于展示特定内容的相关网页的集合, 同时也是构成web的基础。例如淘宝、京东等网站。\r\n\r\n### 网页\r\n>网页 是网站中的一「页」，是构成网站的基础。网页是构成网站的基本元素，是承载各种网站应用的平台。通俗的说，网站就是由网页组成的。通常是HTML格式（文件扩展名为.html或.htm或.asp或.aspx或.php或.jsp等）。网页通常用图像档来提供图画。网页要透过网页浏览器来阅读。\r\n\r\n#### 静态网页\r\n> 静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。例如\r\n* 常见格式 .htm、.html、.shtml、.xml\r\n* 静态网页每个网页都有一个固定的URL\r\n* 静态网页的内容相对稳定，因此容易被搜索引擎检索\r\n* 静态网页没有数据库的支持，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难\r\n* 静态网页运行数据快\r\n\r\n#### 动态网页\r\n> 动态网页，显示的内容不是固定而是可以随着时间、环境或者数据库操作的结果而发生改变。（而不是指页面是否有动效）\r\n* 常见格式 .aspx、.asp、.jsp、.php、.perl、.cgi\r\n* 动态网页一般以数据库技术为基础，可以大大降低网站维护的工作量\r\n* 动态网页实际上并不是独立存在于服务器上的网页文件，只有当用户请求时服务器才返回一个完整的网页\r\n* 采用动态网页技术的网站可以实现更多的功能，如用户注册、用户登录、在线调查、用户管理、订单管理等等\r\n* 动态网页在访问速度和搜索引擎收录上不占优势\r\n\r\n### 构成网页的元素\r\n>图片和文字是构成一个网页的最基本元素。文字是一个网页的内容，图片负责网页的美观。当然除此之外，网页中的内容还包括音频视频。\r\n\r\n\r\n## HTML基础概念\r\n### html（hyper text markup language）超文本标记语言\r\n\r\n> 它是制作网页的标准语言，由蒂姆·伯纳斯里在1990年提出，其目的是方便地把一台电脑中的文本或图形，与另一台电脑中的文本或图形联系在一体，形成一个有机的整体。超文本，就是指图像、视频、动画、声音、表格、链接等多媒体的内容。\r\n\r\n### xhtml（eXtensible HyperText Markup Language）：可扩展标记语言\r\n>他是更严谨更纯净的HTML版本，可以使我们的代码更规范，更整洁，更有效率。相比html语言更加的严格。\r\n\r\n\r\n## html语言\r\n> html 是一种规范，一种标准，它通过**标记符号**来标记要显示的网页中的各个部分。可以告诉浏览器如何显示其中的内容，他是一种由浏览器解释执行的语言。（如：文字如何处理，画面如何安排，图片如何显示等\r\n\r\n> 注意：浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容，对书写出错的标记将不指出其错误，且不停止其解释执行过程，编制者只能通过显示效果来分析出错原因和出错部位\r\n\r\n## html发展历程：\r\n> 当前使用的HTML版本为 HTML5，2014年10月由万维网联盟（W3C）完成标准制定\r\n\r\n| 版本  |  年份 |\r\n|:------|:----|:------|:------|\r\n| HTML | 1991    |\r\n| HTML+ | 1993    |\r\n| HTML2.0 | 1995    |\r\n| HTML3.2 | 1997    |\r\n| HTML4.01 | 1999    |\r\n| HTML5 | 2014   |\r\n\r\n\r\n## html特性\r\n\r\n  • 可以使用.html与.htm做为html文件的扩展名。<br>\r\n  • HTML由于比较简单，是一种描述性的语言，没有逻辑性。<br>\r\n  • 可以使用任意文本编辑器创建HTML所以学习起来非常容易。<br>\r\n\r\n## html语法\r\n\r\n  ### 标签\r\n  > 标记符中的标记元素用尖括号括起来，带斜杠的元素表示该标记说明结束;大多数标记符需成对使用，以表示作用的起始和结束。 结束标记一定要以\"/\"结束，标签之间不能交叉嵌套。\r\n\r\n  ```html\r\n  <span>这是文字标签</span>\r\n  ```\r\n  ### 属性\r\n  > 必须放在开始标签里面，属性可以为标签提供更多样化的特性。\r\n\r\n  ```html\r\n  <span class=\'wenzi\'> 这是字体标签 </span>\r\n  ```\r\n  ### 元素\r\n  > 开始和结束标签连同包含在他们之间内容，我们通常叫做元素。\r\n\r\n\r\n## html基本标签<br>\r\n  ### 注释标签： 为编写的HTML代码提示说明文字，或者临时停用部分代码\r\n\r\n ```html\r\n <!-- 注释内容 -->\r\n ```\r\n\r\n### html主体结构\r\n\r\n```html\r\n<html>\r\n<head>\r\n<!-- 对html文档进行诠释、定义、描述不会显示在文档当中-->\r\n</head>\r\n<body>\r\n<!-- 对页面内容进行排版、编辑、显示在页面当中，是html页面的主体-->\r\n</body>\r\n</html>\r\n```\r\n\r\n  #### head中的标签\r\n```html\r\n<title>标题</title>\r\n<meta name=\"keywords\" content=\"关键词，多个关键词用英文逗号隔\r\n开\"/>\r\n<meta name=\"description\" content=\"本篇网页的概述，一段话\"，对网\r\n站的进一步描述/>\r\n<meta name=\"author\" content=\"网页作者的资料\"\r\n<meta name=\'robots\' content=none/>\r\n<!--  \"all\" 本页以及本页面的所有链接都可被查询\r\n\"none\" 表示不给检索\r\n\"index\" 本文件将被检索 -->\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"> 　\r\n<!-- 网页常用编码方式为utf-8 -->\r\n```\r\n\r\n#### 文档声明\r\n\r\n  > <!DOCTYPE> 声明Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 <!DOCTYPE> 的用处。<!DOCTYPE> 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。\r\n\r\n#### 编码格式\r\n   * utf-8\r\n    >是一种针对Unicode的可变长度字符编码，也是一种前缀码，又称万国码。\r\n\r\n   * gb2312\r\n    >（ie浏览器默认编码）它是计算机可以识别的编码，适用于汉字处理、汉字通信等系统之间的信息交换。基本集共收入汉字6763个和非汉字图形字符682个。\r\n\r\n### body元素中的标签\r\n   >body 中放置的是网页中的主体，表示网页的主体部分，通俗的说也就是用户可以看到的内容，可以包含文本、图片、音频、视频等各种内容！\r\n### 字体效果标签\r\n\r\n ```html\r\n <h1>...</h1>标题字(最大)\r\n <h6>...</h6>标题字(最小)\r\n <b>...</b>粗体字\r\n <strong>...</strong>粗体字(强调)\r\n <i>...</i>斜体字\r\n <em>...</em>斜体字(强调)\r\n ```\r\n >字体标签在seo中的权重：\r\n seo :  是指在了解搜索引擎自然排名机制的基础上， 对网站进行内部及外\r\n 部的调整优化， 改进网站在搜索引擎中的关键词自然排名， 获得更多流量，\r\n 从而达成网站销售及品牌建设的目标\r\n <hx>标签\r\n  h1>h2>h3>h4>h5>h6\r\n 加重语气的标签\r\n strong > b  em > i\r\n\r\n### 区段标签\r\n >和上下的内容进行区分和隔离\r\n\r\n```html\r\n  <hr/>水平线\r\n  <hr size=\'9\'>水平线(设定大小)  \r\n  <hr width=\'80%\'>水平线(设定宽度)\r\n  <hr color=\'ff0000\'>水平线(设定颜色)\r\n  <br/>(换行)\r\n  <p>...</p> (段落)\r\n```\r\n\r\n  ### pre标签\r\n  >元素可定义预格式化的文本。\r\n\r\n  >被包围在 pre 元素中的文本通常会保留空格和换行符，在浏览器中显示时，按照编辑工具中文档预先排好的形式显示内容\r\n\r\n  ### 实体\r\n  >在html中有一些特殊符号属于html语法的关键字符，比如\'<\'或\'>\'等，为了在页面中显示这样的特殊字符，所以要使用实体来表示\r\n\r\n  > 语法\r\n   &+实体名称 +\';\'\r\n\r\n   ```html\r\n    &nbsp; <!--空格--> &lt; <!-- < 小于-->\r\n   ```\r\n\r\n| 代码   |  效果 | 代码   |  效果  |\r\n|:------|:----|:------|:------|\r\n| `&quot;` | \"    |`&amp;`  |   &    |\r\n| `&lt;`   | <    | `&gt;`   |   >    |\r\n| `&nbsp;` | 空格 | `&copy;` |   ©    |\r\n| `&sect;` |  §   | `&curren;`|  ¤    |\r\n\r\n  ### 链接标签\r\n  >链接是指从一个页面指向到另一个目标体，目标体可以是一个图片，也可以是一个网页，也可以是一个文件等，超链接是网络的灵魂，使用的HTML标记是<a>标记\r\n\r\n  ```html\r\n  <a href=\'index.html\' target=\'\' title=\'\'> </a>\r\n  ```\r\n  ### href 路径\r\n   #### 绝对地址\r\n   >绝对路径是从盘符或者根目录出发的，按照文件夹结构指导目标文件或者在互联网上的一个独立地址,在任何地方通过该地址都可访问。\r\n\r\n   >D:\\uek\\index.html;\r\n   http://www.sxuek.com;\r\n\r\n   #### 相对地址\r\n   >相对路径是相对于当前的文件夹或入口文件来说\r\n\r\n   #### traget\r\n   > `_blank`  在新窗口中打开链接； `_self`在当前窗体打开链接,此为默认值\r\n\r\n   #### title\r\n   > 鼠标悬停提示文字\r\n\r\n   #### download\r\n   > 下载    href写文件的路径，download属性是下载文件的名字\r\n\r\n   #### 锚链接\r\n   >给页面当中的某个特定位置添加标记，可以通过a链接直接指向这个位置，经常用在页面内容比较多的情况。\r\n\r\n```html\r\n<a href=\"#name\"></a>\r\n<a name=\"\"></a>\r\n```\r\n\r\n### 图像标签img\r\n\r\n|属性|描述|\r\n|:--|:--|\r\n| src  | 表示\'源\'的意思。\"src\"属性的值是所要显示图像的URL。|\r\n| width|宽度|\r\n|height|高度|\r\n|alt|给图像显示一个\"交互文本\"。 一般用于图片加载失败时的文本提示。|\r\n| title|鼠标移过时显示的文字（对SEO有帮助）|\r\n|border| 给图片加一个边框|\r\n|usemap=\"#name\"| 用于图像地图，可以和图像地图关联起来|\r\n\r\n  >图像地图：图像地图 效果的实质是把一幅图片划分为不同的作用区域，再让不同的区域链接不同的地址\r\n\r\n```html\r\n<map name=\'\'>\r\n  <area shape=\"\" coords=\"\" alt=\"\" href=\"\">\r\n</map>\r\n   <!--\r\n    shape 形状 \"rect\" \"circle\" \"poly\"\r\n    coords 坐标 (相对于图片的左上角)\r\n    title鼠标经过提示的文字\r\n    href 指向的链接\r\n    target 以哪种方式打开 -->\r\n```\r\n\r\n  ### 列表标签\r\n\r\n   #### 无序列表\r\n ```html\r\n  <ul type=\"\"><li></li></ul>```\r\n  <!--默认样式type:通常是黑色的实心小圆圈 disc square 小方块 circle 空心小圆圈-->\r\n   #### 有序列表\r\n  ```html\r\n   <ol type=\"\"><li></li></ol>\r\n  ```\r\n    #### 自定义列表\r\n  >自定义列表不是一个项目的序列，它是一系列条目和它们的解释。有序列表以`<dl>`标签开始，自定义列表条目以`<dt>`开始，自定义列表的定义以`<dd>`开始。\r\n\r\n  ### 表格元素 table\r\n ```html\r\n  <table>\r\n    <tr>\r\n      <td></td><td></td><td></td><!--td表示单元格 -->\r\n    </tr><!--tr表示行-->\r\n  </table>\r\n ```\r\n\r\n|标签|属性|描述|\r\n|:-----|:-----|:-----|\r\n|`table`|width|表格宽度|\r\n|`table`|height|表格高度|\r\n|`table`|border|表格边框|\r\n|`table`|cellspacing|单元格之间的距离|\r\n|`table`|cellpadding|单元格的内边距|\r\n|`table`|align|表格水平对齐方式|\r\n|`tr`|align|文本水平对齐方式|\r\n|`tr`|valign|文本垂直对齐方式|\r\n|`td`|colspan|横跨的列数（合并列）|\r\n|`td`|rowspan|横跨的行数（合并行）|\r\n\r\n> 如果表格样式能使用CSS实现,则尽量使用css达到页面与效果分离\r\n\r\n```html\r\n<table border=\"1\">\r\n  <caption>支出 </caption> <!-- 表格标题-->\r\n  <thead> <!-- 表格头部-->\r\n    <tr>\r\n      <th>Month</th> <!-- th 表头默认大写居中-->\r\n      <th>Savings</th>\r\n    </tr>\r\n  </thead>\r\n\r\n  <tfoot> <!-- 表格底部-->\r\n    <tr>\r\n      <td>Sum</td>\r\n      <td>$180</td>\r\n    </tr>\r\n  </tfoot>\r\n\r\n  <tbody> <!-- 表格内容-->\r\n    <tr>\r\n      <td>January</td>\r\n      <td>$100</td>\r\n    </tr>\r\n    <tr>\r\n      <td>February</td>\r\n      <td>$80</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n```\r\n  > 如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚了。您必须在 table 元素内部使用这些标签。\r\n  > 注意：如果单元格数据为空在IE等浏览器中会不显示，所以要保证单元格不能为空，可以添加`&nbsp;`实体空格\r\n\r\n  ### 表单form\r\n  >表单 是Web浏览器和Web服务器进行通信的最常用的手段，即通过表单，浏览器不仅能从Web服务器中获得信息，而且还能向Web服务器反馈信息。HTML为此提供了表单(Form)元素来设计和实现这种交互界面。\r\n\r\n```html\r\n<form method=\'get\' action=\'uek.php\'>……</form>\r\n```\r\n\r\n| 属性     | 描述     | 值|\r\n| :------------- :| :------------- :| :---|\r\n| action       | 数据处理文件       | php、asp、jsp|\r\n| method       | 数据提交方式       |get、post|\r\n\r\n  ### 表单元素input（控件）\r\n  >表单形成的交互界面上有许多元素，负责收集用户输入的各种信息，这些元素一般称为控件。如：单行/多行文本、单元按钮、多选按钮、文本域、下拉菜单、按钮、重置按钮、提交按钮。\r\n\r\n```html\r\n<input type=\'text\' name=\'user\' value=\'uek\' size=\'10\' maxlength=\'20\'>\r\n```\r\n\r\n| 属性 | 描述 |\r\n| :------------- | :-------------|\r\n| type           | 控件类型       |\r\n| name           | 用于数据库获取信息       |\r\n| value          | 指定默认值       |\r\n| size           | 显示文本框长度      |\r\n| maxlength      | 用户可以出入的最多大字符数      |\r\n| disabled       | 用来设置或获取控件是否可用      |\r\n| readOnly       | 用来设置空间的只读属性，只能复制和读取      |\r\n\r\n  ### 控件类型\r\n\r\n| 控件类型     | 值     |\r\n| :------------- | :------------- |\r\n| 单行文本     | text       |\r\n| 密码         | password       |\r\n| 单选按钮     | radio       |\r\n| 复选按钮     | checkbox       |\r\n| 文件域       | file       |\r\n| 按钮         | button       |\r\n| 重置按钮     | reset       |\r\n| 提交按钮     | submit       |\r\n\r\n  ### 下拉框 select\r\n    >HTML是通过`<select>`和`<option>`标记来定义输入列表框的。列表框标记`<select>`是成对出现标记，首标记`<select>`和尾标记</select>之间的内容就是一个列表框的内容。`<option>`标记用于定义列表框中的各个选项\r\n\r\n```html\r\n  <select name=\"uek\" size=\"1\" multiple>\r\n  　　<option value=\"webui\" selected=\"selected\">前端工程师</>\r\n  　　<option value=\"ui\" selected=\"selected\">ui设计师</>\r\n  　　<option value=\"php\" selected=\"selected\">php工程师</>\r\n  </select>\r\n```\r\n| 属性 | 描述     | 值 |\r\n| :------------- | :------------- |\r\n| name           | 指定列表框的文字（必填）      | 自定义|\r\n| size           | 用于定义列表框的长度（可选）      | Number|\r\n| multiple       | 属性表示可以多选，按Ctrl可以多选。默认单选     | true|\r\n\r\n  ### 下拉选项 option\r\n  >用于定义列表框中的选项。它必须嵌套在列表框标记中使用，一个列表框中有几个选项，就要有几个<option>标记与之相对应。`<option>`标记有2个属性：value和selected，它们都是可选的。\r\n\r\n| 属性     | 描述     |\r\n| :------------- | :------------- |\r\n| value       | 属性的参数值是当该项被选中并提交后，web浏览器传送给服务器的数据。缺省时，浏览器将传送选项的内容。|\r\n| selected       | 属性用来指定选项的初始状态，表示该选项在初始时是被选中的。|\r\n\r\n\r\n  ### 文本域 textarea\r\n  >文本域用来定义多行文本。\r\n\r\n| 属性 | 描述     |\r\n| :------------- | :------------- |\r\n| name       | 用于指定文本输入框的名字       |\r\n| cols       | cols属性用于规定文本输入框的宽度。属性的参数值是数字，表示一行所能显示的最大字符数       |\r\n| rows       | rows属性用于规定文本输入框的高度。属性的参数值是数字，表示该文本输入框所占的行数       |\r\n\r\n  ### 自动聚焦 lable\r\n  >用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上\r\n\r\n```html\r\n  <input type=\'radio\' name=\'sex\' value=\'nan\' id=\'sex\'>\r\n  <label for=\'idname\'> </label>\r\n```\r\n\r\n```html\r\n  <label>\r\n    <input type=\'radio\' name=\'sex\' value=\'nan\' id=\'sex\'>\r\n  </label>\r\n```\r\n\r\n  ### fieldset              \r\n  >标签将表单内容的一部分打包，生成一组相关表单的字段。\r\n\r\n```html\r\n  <fieldset>\r\n    <legend>fieldset名称</legend>\r\n    <!-- 加入你的内容 -->\r\n  </fieldset>\r\n```\r\n  >fieldset 元素可将表单内的相关元素分组。\r\n  `<legend>` 标签为 fieldset 元素定义标题。\r\n\r\n  ### iframe\r\n  >可以和body体共存，用法和<frame>类似，用于早期实现异步传输等视觉效果。iframe标签是成对出现的，以 `<iframe>`开始，`</iframe>`结束iframe标签内的内容可以做为浏览器不支持iframe标签时显示。\r\n\r\n| 属性 | 值     |\r\n| :------------- | :------------- |\r\n| width       | 宽度       |\r\n| height      | 高度      |\r\n| scrolling      | 是否出现滚动条     |\r\n| src     | 本框架要指向的页面   |\r\n\r\n```html\r\n<iframe src=\"https://www.baidu.com\" width=\"\" height=\"\"></iframe>\r\n```\r\n","timestamp":1585877701769},{"name":"02-css的使用.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/02-css的使用.md","content":"# CSS\r\n## 名词解释\r\n\r\n### 网页标准布局：div+css网页标准布局方式\r\n   #### div  \r\n   >全称 division 意为\"区块、分割\"div标签是一个无意义的容器标签，用于将页面划分出不同的区域。 通过div将复杂的页面进行细分块，可以将问题细分一个一个解决，所以通过div将页面分块是一个关键的工作，也是决定最终效果与质量的前提。\r\n\r\n  #### css（Cascading Style Sheet）\r\n  >中文翻译为层叠样式表，是用于控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。\r\n\r\n   div承载的是内容，css承载的是样式。\r\n\r\n\r\n## CSS 的引入方式  \r\n  要利用div+css的布局方式，那么首先我们来看如何引入css。\r\n### 行内样式表\r\n  >顾名思义，我们要修饰哪个元素我们就将css写在哪个标签上。\r\n\r\n```html\r\n  <div style=\'属性:值;属性:值……\'></div>\r\n\r\n  <div style=\'width:200px;height:200px;background:red\'> </div>\r\n```\r\n\r\n### 嵌入样式表\r\n> css样式表是写在html文件中的，因此我们称之为嵌入样式表。\r\n\r\n```html\r\n  <style> 选择器{属性：值;属性：值;……}</style>\r\n```\r\n\r\n```html\r\n <head>\r\n   <style>\r\n      div{\r\n        width:200px;\r\n        height:200px;\r\n        background:red;\r\n      }\r\n   </style>\r\n </head>  \r\n```\r\n\r\n### 外部样式表\r\n  >该方法是需要我们引入一个外部的css样式表。\r\n\r\n  + 新建css样式表\r\n  + 引入 `<link rel=\'stylesheet\' type=\'text/css\' href=\'地址\'>` (type属性可省略)\r\n\r\n```html\r\n<link rel=\'stylesheet\' type=\'text/css\' href=\'uek.css\'>\r\n```\r\n\r\n### 导入样式表\r\n  >该方法是将一个css样式表导入到另一个css样式表中。\r\n\r\n  + `@import` url(外部样式表位置)\r\n\r\n```css\r\n @import url(\'index.css\');\r\n```\r\n\r\n## 优先级\r\n 现在我们可以有4中方式将css引入到我们的页面当中。那么当一个html文件中利用多种方式引入css，哪种方式会作用到页面元素呢？因此我们需要引入优先级。优先级也就是说哪种样式会优先作用到元素。\r\n *  行内样式最高\r\n *  其他的样式表，优先级一样，按照导入的顺序来确定他们是否起作用。\r\n\r\n## 选择器\r\n  当我们定义一条样式规则时候，这条样式规则会作用于网页当中的某些元素，而我们的规定的这些元素的规则就叫做选择器。\r\n> 在此处我们需要注意，css既然是用来修饰页面中元素样式的，那么页面中必须存在该元素。\r\n\r\n| 选择器 |          格式     |作用范围|\r\n| :------------- | :------------- | :---- |\r\n| id选择器        | #id               | 选择页面中指定id名的元素，id是唯一的  |\r\n| 类名选择器      | .classname       | 选择页面中指定类名的元素集合|\r\n| 标签选择器      | tagname          | 选择页面中所有指定标签元素集合|\r\n| 交叉选择器      | tagname.classname| 选择页面中同时符合俩个条件元素集合|\r\n| 群组选择器      | 多个选择器用‘，’隔开| 选择多个选择器指定元素|\r\n| 后代选择器      | 父级 空格 子级    | 选择某父元素下面的子元素 |\r\n| 通用选择器      | *    | 选择页面中所有的元素 |\r\n\r\n## 伪类选择器\r\n   同一个html元素在不同状态下的不同样式\r\n\r\n| 选择器     | 描述     |\r\n| :------------- | :------------- |\r\n| :link         | 未访问的链接     |   \r\n| :active       | 选定的链接       |   \r\n| :hover        | 鼠标移动到链接上  |   \r\n| :visited      | 已访问的链接     |   \r\n| :first-letter | 选择段落中的第一个字母或中文字符     |   \r\n| :first-line   | 选择文本中的首行     |   \r\n\r\n## CSS的继承性和叠加性\r\n  ### 继承性\r\n  >后代元素会继承前辈元素的一些属性和样式。\r\n\r\n  ### 叠加性\r\n  >同一个元素，被多个样式规则指定。\r\n\r\n因为有了继承性和叠加性，就有了css的优先级。\r\n\r\n## 选择器的优先级\r\n  所谓的优先级，指的就是哪条样式规则会最作用于指定的元素  \r\n  ![选择器优先级](amWiki/images/001-yxj.png);\r\n\r\n## CSS注释\r\n` /* css code */`  \r\n\r\n## 文字属性\r\n\r\n| 属性            |      描述     | 值 |\r\n| :------------- | :---------- | :---- |\r\n|  font-size      |   文字大小    | px、em |\r\n|  font-family    |   文字字体    | 微软雅黑、宋体 |\r\n|  font-weight    |   文字粗细    | bold（加粗）normal（正常）100~900（9级加粗） |\r\n|  font-style     |   文字风格    | normal（默认值标准样式）italic\t（斜体）oblique（倾斜）inherit |\r\n| color           |   文字颜色    | rgb、#ffffff、red |\r\n\r\n` 字体缩写 font: bold 12px/20px \"宋体\" ;  如果缩写至少要定义 font-size 和font-family两个属性`\r\n\r\n## 文本段落\r\n\r\n| 属性            |      描述     | 值 |\r\n| :------------- | :---------- | :---- |\r\n|  text-align     |   设置文本水平对齐方式  | left左对齐，right右对齐，center居中对齐，justify两端对齐 |\r\n| vertical-align  |   设置元素垂直对齐方式  | super上标，sub下标，top与行中最高元素顶端对齐，middle父元素的中间位置，bottom与行中最低元素底端对齐.常用来对齐表单元素和图片，在块元素内不起作用，在行内元素中起作用。 |\r\n|  line-height    |   设置元素的行高字体行高，单行文字一般用来设置居中，    | 常用单位em |\r\n|  text-indent    |   设置首行的缩进方式     |常用单位em  |\r\n|  word-break     |   自动换行   |  break-all  |       \r\n| text-transform  |   设置文本的大小写   | none（无转换） capitalize（将每个单词的第一个字母转换成大写）<br> uppercase（将每个单词转换成大写）lowercase（将每个单词转换成小写）        |\r\n| letter-spacing  |   设置字间距  | normal、length、percentage（css3）|\r\n| text-indent  |   设置首行缩进  | length、percentage|\r\n|text-size-adjust | 设置移动端页面中对象文本大小 | （auto）文本大小根据设备尺寸进行调整。（none）文本大小不会根据设备尺寸进行调整。（percentage）用百分比来指定文本大小在设备尺寸不同的情况下如何调整。|\r\n```html\r\n<style media=\"screen\">\r\n   .fontcap{\r\n     text-transform: capitalize;\r\n   }\r\n   .fontup{\r\n     text-transform: uppercase;\r\n   }\r\n   .fontlow{\r\n     text-transform: lowercase;\r\n   }\r\n</style>\r\n<span class=\"fontcap\">web ui php</span>\r\n<span class=\"fontup\">web ui php</span>\r\n<span class=\"fontlow\">WEB UI PHP</span>\r\n```\r\n","timestamp":1585877701769},{"name":"03-css盒子模型 与 标签种类.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/03-css盒子模型 与 标签种类.md","content":"# css盒子模型\r\n* 盒子模型是CSS的基石之一，布局最重要的概念，它指定元素如何呈现在页面当中。网页就是由许多个盒子通过不同的排列方式（纵向排列，横向排列，嵌套排列）堆积而成。\r\n* 页面上的每个元素都被浏览器看成是一个矩形的盒子，这个盒子由元素的`内容`、`填充`、`边框`和`边界`组成。\r\n* 默认情况下盒子的边框是无，背景色是透明，所以我们在默认情况下看不到盒子\r\n\r\n## 盒子的相关概念和属性\r\n* 内容\r\n  * 盒子里面所包含的元素和内容\r\n* 填充(内边距) (padding)\r\n  * 盒子里面的内容到盒子的边框之间的距离. padding-left、 padding-right、 padding-top、padding-bottom\r\n*  边框(border)\r\n  * 盒子本身有边框(border) border-left、 border-right、 border-top、 border-bottom\r\n* 外边距(magin)\r\n  * 边框外和其它盒子之间 margin-left、 margin-right、 margin-top、margin-bottom\r\n* 盒子实例图示\r\n<br/>\r\n![盒子实例图示](amWiki/images/2016-12-13_010759.png)\r\n* 盒子示意图示\r\n<br/>\r\n![盒子实例图示](amWiki/images/2016-12-13_011313.png)\r\n\r\n## 设置盒子padding和margin的方式\r\n\r\n| 设定值的个数    |  写法    |描述 |\r\n| :------------- | :------------- |------|\r\n| 1个属性值     | padding:40px;margin:40px;|表示上下左右的值都是该值|\r\n| 2个属性值     | padding:10px 10px;|前者表示上下的值，后者表示左右的值|\r\n| 3个属性值     | padding:10px 20px 10px;|前者表示上边的值，中间的数值表示左右的值，后者表示下边的值|\r\n| 4个属性值     | padding:10px 20px 10px 10px;|依次表示上、右、下、左的值，即顺时针排序|\r\n| 单独设定属性值 | padding-left、 padding-right、 padding-top、padding-bottom|  |\r\n\r\n## 盒子的宽高属性\r\n\r\n|  盒子所占大小 | 计算方式  |\r\n| :------------- | :------------- |\r\n|  盒子所占宽度     | width + padding-left + padding-right + border-left + border-right 设定宽度+左右内边距+左右边框     |\r\n|  盒子所占高度   | height + padding-top + padding-bottom + border-top + border-bottom 设定高度+上下内边距+上下边框|\r\n|  width   |宽度设定的具体值|\r\n|  height   |高度设定的具体值|\r\n|  width auto  |一般会是父元素的宽度|\r\n|  height auto  |一般会是内容的高度|\r\n\r\n###  边框\r\n\r\n| 类型     | 设置方式   |\r\n| :------------- | :------------- |\r\n| border-width      | border-top-width、border-right-width、border-bottom-width、border-left-width对某一面的边框宽度单独设置    |\r\n| border-color     |设置四个方面的边框颜色，可以通过设置border-top-color、border-right-color、border-bottom-color、border-left-color对某一面的边框颜色单独设置  |\r\n| border-style    |设置四个方面的边框样式，可以通过设置border-top-style、border-right-style、border-bottom-style、border-left-style对某一面的边框样式进行单独设置.|\r\n\r\n* border常见的样式\r\n  * none：无样式\r\n  * dotted：点线\r\n  * dashed：虚线\r\n  * solid：实线\r\n  * double：双线\r\n  * groove：槽线\r\n  * ridge：脊线\r\n  * inset：内凹\r\n  * outset：外凸\r\n* 实例\r\n```css\r\n.sample-border1{\r\n border-top-width:1px;\r\nborder-top-style:dotted;\r\nborder-top-color:#cccccc;\r\n}\r\n.sample-border2{\r\nborder-top:1px solid #cccccc;\r\nborder-left:1px solid #cccccc;\r\nborder-right:1px soli #cccccc;\r\nborder-bottom:1px solid #cccccc;\r\n}\r\n// 缩写后\r\n.sample-border1{\r\nborder-top:1px dashed #ccc;\r\n}\r\n.sample-border2{\r\n   border:1px solid #ccc;\r\n}\r\n```\r\n\r\n## 关于填充和边距的常见问题\r\n* 大部分html元素的盒子属性(margin, padding)默认值都为0，有少数html元素的(margin, padding)浏览器默认值不为0，例如：body，p，ul，li，form标记等，因此我们有时有必要先设置它们的这些属性为0。\r\n* 相邻两个兄弟元素的上下外边距会发生合并，一般布局我们都会设定他们的外边距\r\n* 如果没有设置父级元素的内边距或边框那么他的子元素的边界会和其合并\r\n* margin-top bug的问题:当两个容器嵌套时,如果外层容器和内层容器之间没有别的元素,并且外层容器没有边框和padding值的时候，部分浏览器会把内层元素的margin-top作用与父元素\r\n* 设定一个块元素居 中 `margin:0 auto;`\r\n* margin可以设置负值，padding不可以\r\n* 行内元素的margin值，只有左右，没有上下的值、border和padding上下只有样式但不占据页面位置\r\n\r\n## 标签分类\r\n\r\n| 分类 | 特性     | 代表元素 |\r\n| :------------- | :------------- |:---|\r\n| 块标签       |  有宽、高属性，同时块标签会独占一行     | H1～H6、P、li、div |\r\n| 行标签       |  不具有宽、高特性，mrgin属性的值，只有左右没有上下。也不会占一行     | 字体标签、span |\r\n| 行内块标签   |  既有行元素的属性即:不会独占一行又有块元素的属性即：可以设置宽高| img 、表单元素  |\r\n\r\n\r\n## display\r\n> 元素的在页面中的存在形式 与 元素的相互转化\r\n\r\n| 值 | 特性   |\r\n| :------------- | :------------- |\r\n| `display: none;`     |可以让元素隐藏起来并且不占用页面空间,浏览器会完全忽略掉这个元素，该元素将不会被显示，也不会占据文档中的位置 |\r\n| ` display:block; `  |可以让元素具有块特性将块级元素|\r\n| ` display:inline; `  |可以让块级元素变为行内元素|\r\n| ` display:inline-block; `  |指定元素兼有块级和行级元素的特性，即在行内显示但是可以设定宽高|\r\n\r\n> 在IE6中当行内元素转换为块元素时，高度会比原有的高度大，所以要设置overflow:hidden,来做兼容。\r\n","timestamp":1585877701769},{"name":"04-css浮动.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/04-css浮动.md","content":"# 浮动\r\n> 可以改变普通文档流的排列方式，可以使得块元素在同一行中排列，使我们的布局更加的方便。\r\n\r\n| 属性值 | 描述     |\r\n| :------------- | :------------- |\r\n| none     | 不浮动(默认值)     |\r\n| right    | 向右浮动     |\r\n| left  | 向左浮动    |\r\n\r\n## 文档流\r\n* HTML元素在标准状况下的定位方式，会按照由上到下由左到右的顺序排列行内元素在同一行内横向排列块级元素占满整个一行，在页面中竖向排列\r\n\r\n* 通过设置float属性来完成 另一种脱离文档流的行为就是浮动，分为左、右浮动\r\n* 浮动是脱离文档流的，也就是其他元素视他不见\r\n*  浮动停止\r\n  * 当遇到一个浮动元素后会停止\r\n  * 遇到父级元素后会停止\r\n* 多个盒子都浮动后，就产生了块级元素水平排列的效果\r\n* 多个浮动元素不会相互覆盖\r\n* 若包含的容器太窄，无法容纳水平排列的多个浮动元素，那么最后的浮动盒子会向下移动,但如果浮动元素的高度不同，那当它们向下移动时可能会被卡住\r\n\r\n## 浮动引发的问题\r\n* 如果子元素设置了浮动，而父元素没有设置高度的话，父元素不会被自动撑开。\r\n  * 解决办法：给父元素设置overflow：hidden;\r\n  * 或者在子元素的后面加一个清除浮动的元素\r\n* 行内元素和块元素在一行的时候 如果只给块元素设置浮动，在一些旧的浏览器中行元素和块元素不能在一行内显示。\r\n  * 解决办法：给行元素也设置浮动;\r\n  * 改变文档顺序\r\n* 一般情况下，如果在一行内，一个元素设置浮动的时候，那么这行之内的其他元素也要是设置浮动。\r\n\r\n## 清除浮动\r\n* clear是清除浮动属性，它的取值有left、right、both和none（默认值），\r\n  * 如果设置盒子的清除浮动属性clear值为left或right，表示该盒子的左边或右边不允许有浮动的对象。\r\n  * 值设置为both则表示两边都不允许有浮动对象，因此该盒子将会在浏览器中另起一行显示\r\n\r\n* 清除浮动是清除其它盒子浮动对该元素的影响，而设置浮动是让元素自身浮动，两者并不矛盾  \r\n* 清除浮动的一般做法是在浮动同辈元素的最后添加一个块元素，然后添加`cloth:both`.\r\n```html\r\n<div class=\"float\">\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <!-- 使用 clear:both; 清除浮动 -->\r\n  <div style=\"clear:both;\"></div>   \r\n</div>\r\n```\r\n```css\r\n.item{\r\n  flaot:left;\r\n}\r\n```\r\n\r\n通过伪元素选择器改进,不需要新增空标签：\r\n```html\r\n<div class=\"float\">\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n  <div class=\"item\"></div>\r\n</div>\r\n````\r\n```css\r\n.float::after{\r\n  content:\"\";\r\n  display:block;\r\n  clear:both;\r\n}\r\n```","timestamp":1585877701769},{"name":"05-css定位.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/05-css定位.md","content":"# 定位 position\r\n> 定位确定元素的位置，用定位属性能够方便我们将元素固定在任意的位置。设置定位之后的元素依靠`top,right,bottom,left`修改位置\r\n\r\n| 属性值 | 描述     |\r\n| :------------- | :------------- |\r\n| static    | 静态定位，默认定位方式      |\r\n| relative  |相对定位     |\r\n| absolute  |绝对定位     |\r\n| fixed     |固定定位     |\r\n| initial     |初始值    |\r\n| inherit     |继承   |\r\n\r\n## 固定定位  position: fixed\r\n> 将元素固定在窗口中的某个位置，绝对定位是相对于元素的，固定定位是相对于窗口的，会随着窗口的移动而移动。在 `ie6` 不支持此属性。`固定定位在IE浏览器里面是有问题的，这个问题我们在兼容性章节里会详细介绍。`\r\n\r\n#### 写法\r\n添加 `position: fixed;`, 使用`top` `bottom` `left` `right` 四个属性来表示定位元素的位置信息,表示定位元素到浏览器上下左右的间距(四选二使用)\r\n\r\n```css\r\n.toTop{\r\n  position: fixed;\r\n  right: 30px; bottom: 50px;\r\n}\r\n```\r\n> 注: 固定定位必须固定位置信息,否则其位置会被其他元素影响\r\n\r\n\r\n## 相对定位  position: relative\r\n>  相对定位是参照元素原来的位置进行移动，元素原有的空间位不变，元素在移动时会盖住其他元素。在页面中我们很少使用相对定位来改变元素的位置。相对定位一般要和绝对定位搭配使用的。\r\n\r\n利用相对定位根据自身位置移动并且移动时不影响其他元素的特性,可以制作鼠标移入元素移动的动效:\r\n```css\r\n/* 鼠标移入元素上移5px */\r\n.box{\r\n  position: relative;\r\n  bottom: 0;\r\n}\r\n.box:hover{\r\n  bottom: 5px;\r\n}\r\n```\r\n\r\n\r\n## 绝对定位  position: absolute\r\n> 绝对定位是元素完全脱离文档流，页面中的其他元素视他不存在，也就是说绝对定位元素不会影响到其他元素，在移动的过程中同样会盖住其他的元素。绝对定位的元素是相对于具有定位属性的父辈元素进行定位的，如果父辈元素没有定位属性，则相对于文档进行定位。因此在使用绝对定位时，还需要找一个合适的父辈元素设置为相对定位。<br/>\r\n> 绝对定位在进行定位是相对于具有定位属性父辈元素进行定位。原点是父辈元素padding开始的位置。   \r\n\r\n+ 特殊布局水平垂直居中\r\n\r\n```css\r\n   div{\r\n     width:200px;\r\n     height:200px;\r\n     position:absolute;\r\n     top:0;\r\n     right:0;\r\n     bottom:0;\r\n     left:0;\r\n     margin:auto;\r\n   }\r\n\r\n   div{\r\n     width:200px;\r\n     height:200px;\r\n     position:absolute;\r\n     top: 50%;\r\n     left:50%;\r\n     margin-top:-100px;\r\n     /* 元素高度一半 */\r\n     margin-left:-100px;\r\n     /* 元素宽度一半 */\r\n   }\r\n\r\n```\r\n\r\n\r\n\r\n## 层级 z-index\r\n> 定位属性是脱离文档流的，也就是说他有可能盖住其他元素,如果有多个定义属性存在，那么相互间就会存在遮挡的情况，可以通过修改元素的z-index属性来设置元素叠放的层次，z-index值越高就会越在最上面\r\n\r\n* 层级 z-index 的值为 `-1 到 正无穷` 的整数\r\n* 定位元素默认的层级为0\r\n* 如果定位元素挡住普通元素，可给普通元素添加`position: relative;` 并提高层级\r\n* 定位元素层级为-1意味着该元素会在背景下方\r\n\r\n","timestamp":1585877701769},{"name":"06-css补充属性.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/06-css补充属性.md","content":"## overflow\r\n> 有时候，子元素的宽高会超出父元素的尺寸，我们需要对超出的内容做一些设置。\r\n\r\n| 属性值 | 描述     |\r\n| :------------- | :------------- |\r\n|   hidden     | 将超出的内容隐藏      |\r\n|   visible     | 全部显示内容      |\r\n|   auto     | 根据实际情况做出调整，如果说没有超出那么正常显示，否则将会出现滚动条。      |\r\n|  scroll     | 始终出现滚动条      |\r\n\r\n## visibility <br/>\r\n> 主要是控制元素的隐藏和显示状态,想当于opacity的0和1状态。\r\n\r\n| 属性值 | 描述     |\r\n| :-------- | :-------------   |\r\n| visible    | 当前元素为显示状态  |\r\n| hidden     | 当前元素为隐藏状态  |\r\n\r\n## overflow、display、visibility\r\n> 三个属性设置为隐藏状态时的区别\r\n\r\n| 属性    | 描述     |\r\n| :------------- | :------------- |\r\n| overflow    | 只是对超出容器的内容进行处理       |\r\n| display     | 整个元素的显示状态是不可见的,浏览器会认为这个元素不存在。       |\r\n| visibility  | 浏览器认为该元素存在，但是不显示出来，所有该隐藏的元素还会占据原有的位置     |\r\n\r\n## 改变尺寸 resize <br/>\r\n> 主要处理textarea的缩放\r\n\r\n| 属性值 | 描述     |\r\n| :------------- | :------------- |\r\n| none      |不能拖动      |\r\n| both      |任意拖动      |\r\n| horizontal|水平拖动      |\r\n| vertical  |垂直拖动      |\r\n\r\n\r\n## CSS 背景\r\n> 主要用于给一个元素添加盒子模型的填充。盒子模型默认的背景色是透明的。\r\n\r\n| 属性 | 描述     | 值  |\r\n| :------------- | :------------- |\r\n| background-color       | 背景颜色       | rgb,十六进制,英文单词 |\r\n| background-image       | 背景图片      | url(地址) |\r\n|background-repeat|设置背景平铺重复方向 |no-repeat,repeat-x,repeat-y |\r\n|background-attachment|设置背景图像是随对象内容滚动还是固定|scroll,fixed|\r\n|background-position|设置背景图像位置。| top,right,bottom,left,center,百分比,数值  |\r\n` background: #ffffff url(uek.png) no-repeat left content fixed; 依次：颜色-背景图-平铺-背景图像位置-固定 `\r\n\r\n## CSS背景之Sprite技术\r\n> 也叫做css背景图片精灵技术实现的方式：是将多张背景图片放到一个图片当中，通过定位的方式来获得相应位置的图片，使得一个图片一次载入，多次使用，使得页面的下载速度加快！<br/>\r\n> 核心技术:background-position\r\n\r\n![tushi](amWiki/images/sp.png)\r\n\r\n\r\n## CSS列表属性\r\n\r\n### 列表样式类型属性 list-style-type\r\n\r\n| 属性值       |      描述        | 属性值       |      描述        | 属性值       |      描述        |\r\n| :-------- - | :------------- | :-------- - | :------------- | :-------- - | :------------- |\r\n|   disc       | 缺省值，黑圆点   |   circle     | 空心圆点         |    none       |无列表项标记      |\r\n|   square     |小黑方块          |  decimal     | 数字排序        | upper-alpha   |大写字母排序      |\r\n|   lower-roman| 小写罗马字排序   | upper-roman   | 大写罗马字排序   |lower-alpha| 小写字母排序     |\r\n\r\n### 列表样式位置属性 list-style-position\r\n\r\n| 属性值          |     描述     |\r\n| :------------- | :------------- |\r\n| outside         | 以列表项内容为准对齐     |\r\n| inside          | 以列表项标记为准对齐     |\r\n\r\n### 列表样式图片属性 list-style-image\r\n> 列表项标记可以用图片来表示 ` list-style-image:url(uek.png) `\r\n\r\n### 列表样式实例\r\n```css\r\n  ul{\r\n    list-style:circle inside url(uek.png)\r\n  }\r\n```\r\n\r\n## 透明度\r\n> 在前端处理时经常会用到透明色的处理，但是在IE与标准的CSS规范中使用是不同的\r\n\r\n| 标准  | 属性     | 属性值 |\r\n| :--- | :------------- |:------------- |\r\n| w3c   | opacity       | 0~1 |\r\n| ie    |  filter:alpha(opacity = num) | 0~100 |\r\n\r\n```css\r\ndiv{\r\n  opacity:0.5;\r\n  filter:alpha(opacity=50);\r\n}\r\n```\r\n\r\n## 鼠标样式\r\n> 用于展示在鼠标的不同状态时候的样式。\r\n\r\n| 属性值 | 描述     | 属性值 | 描述     |\r\n| :------------- | :------------- |:------------- | :------------- |\r\n| hand,pointer | 手型。推荐pointer| w-resize| 向左的箭头|\r\n| crosshair    | 是十字型     |sw-resize| 左下的箭头|\r\n| text  |  移动到文本上的那种效果 |sw-resize  |  左下的箭头 |\r\n| wait      | 等待的那种效果      |s-resize |  向下的箭头 |\r\n|default      | 默认效果      |se-resize |  向右下的箭头 |\r\n| help     | 问号      |auto |  由系统自动给出效果 |\r\n|e-resize    | 向右的箭头      |n-resize     | 向上的箭头      |\r\n|ne-resize     | 向右上的箭头      |nw-resize     | 向左上的箭头      |\r\n\r\n## table设定样式\r\n> 设定table表格的细胞边框是否合并，每一个td的宽度是否是固定的大小，以及表头的位置\r\n\r\n| 属性 | 描述     | 值 |\r\n| :-------------| :------------- |:------------- |\r\n|border-collapse | 指定边框是否合并 | separate,collapse|\r\n| table-layout   | 固定或自动宽度   | fixed,auto|\r\n| caption-side  | 标题的位置       | top,left,right,bottom|\r\n","timestamp":1585877701769},{"name":"07-html5语义化标签.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/07-html5语义化标签.md","content":"## HTML5新增标签\r\n  在HTML5中新添加了一系列语义化的标签，能够更恰当的描述你的内容是什么。布局时就更加的灵活和多变，使用语义化标签有利于浏览器的seo，更加有利于网站的检索。\r\n\r\n## 为什么要使用语义化的标签？\r\n1. 可以更好地理解网页的框架。即使在没有CSS的情况下，HTML页面也能呈现出很好地内容结构、代码结构。\r\n2. 不同的语义化标签实际上为我们将网页划分了不同的模块，结构分明更利于分解模块，利于团队的合作和维护。\r\n3. 使用语义化标签有利于浏览器的seo，更加有利于网站的检索。\r\n\r\n## 文档声明\r\n* <!DOCTYPE> 声明必须位于 HTML5文档中的第一行，也就是位于`<html>` 标签之前。该标签告知浏览器文档所使用的HTML规范。\r\n\r\n* DOCTYPE 声明不属于 HTML 标签; 它是一条指令，告诉浏览器编写页面所用的标记的版本。 在所有 HTML文档中规定 DOCTYPE 是非常重要的，这样浏览器就能了解预期的文档类型。\r\n\r\n* HTML 4.01 中的 DOCTYPE 需要对 DTD 进行引用，因为 HTML4.01 基于 SGML（标准通用标记语言）。而 HTML 5 不基于 SGML，因此不需要对DTD （文档类型定义）进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行。）\r\n\r\n## meta标签\r\n` <meta name =\"viewport\" content =\"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1,user-scalable=no\">`\r\n\r\n* content 属性说明\r\n\r\n| 属性值 | 说明     |\r\n| :------------- | :------------- |\r\n|   width         | viewport 宽度(数值/device-width)      |\r\n|   height        | viewport 高度(数值/device-height)      |\r\n|   initial-scale      | 初始缩放比例      |\r\n|   maximum-scale      | 最大缩放比例      |\r\n|   minimum-scale      | 最小缩放比例      |\r\n|   user-scalable      | 是否允许用户缩放(yes/no)      |\r\n\r\n## 结构性标签\r\n  结构性标签（construct tag）主要负责Web的上下⽂文结构的定义，确保 HTML文档的完整性，这类标签包括以下几个。\r\n  * section <br>\r\n    用于表达书的一部分或一章，或者一章内的一节。在Web 页⾯面应 用中，该标签也可以 用于区域的章节表述。\r\n  * header <br>\r\n    页面主体上的头部，注意区别于head标签。这里可以给初学者提供一个判断的小技巧：head标签中的内容往往是不可见的，而header标签往往在一对body标签之中。\r\n  * footer <br>\r\n    页面的底部（页脚）。通常，人们会在这里标出网站的一些相关信息，例如关于我们、法律申明、邮件信息、管理入口等。\r\n  * nav <br>\r\n    是专门用于菜单导航、链接导航的标签，是navigator的缩写。\r\n  * article <br>\r\n    用于表示一篇文章的主体内容，一般为文字集中显示的区域。　\r\n  * 语义化页面展示  　　\r\n![语义化页面](amWiki\\images\\yuyi.jpg)\r\n## 块级性标签 <br>\r\n   块级块性标签（block tag）主要完成Web页面区域的划分，确保内容的有效分隔，这类标签包括以下几。\r\n * aside <br>\r\n   用以表达注记、贴士、侧栏、摘要、插入的引 用等作为补充主体的内容。从一个简单页面显示上，就是边栏，可以在左边，也可以在右边。从一个页面的局部看，就是摘要。\r\n * figure <br>\r\n   标签规定独立的流内容，通常与figcaption联合使 用。\r\n * code <br>\r\n   表示一段代码块。\r\n * dialog <br>\r\n   对话标签配合dt dd标签使用\r\n\r\n## 行内标签\r\n   行内语义性标签（in-line tag ）主要完成Web页面具体内容的引用和表述，是丰富内容展示的基础，这类标签包括以下几个。\r\n *  meter <br>\r\n   表示特定范围内的数值， 可用于工资、数量、百分比等。max表示最大值，min表示最小值，value代表当前值。\r\n   ```\r\n   <meter min=\"2\" max=\"10\"  value=\"3\"></meter>\r\n   ```\r\n * time <br>\r\n   表示时间值，属性datetime强调时间\r\n * progress <br>\r\n   用来表示进度条   \r\n\r\n## 多媒体标签\r\n * video <br>\r\n  视频标签，用于支持和实现视频（含视频流）文件的直接 播放，支持缓冲预载和多种视频媒体格式如MPEG-4、OggV和WebM等。\r\n```html\r\n<video width=\"320\" height=\"240\" controls>\r\n  <source src=\"video.mp4\" type=\"video/mp4\">\r\n  <source src=\"video.ogg\" type=\"video/ogg\">\r\n    您的浏览器不支持Video标签。\r\n</video>\r\n```\r\n> `<video>` 元素提供了 播放、暂停和音量控件来控制视频。同时 `<video>` 元素元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。\r\n`<video>`与`</video>` 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。\r\n`<video>` 元素支持多个 `<source>` 元素。`<source>` 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式。\r\n\r\n* audio\r\n  音频标签，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式。\r\n```html\r\n  <audio controls>\r\n    <source src=\"audio.ogg\" type=\"audio/ogg\">\r\n    <source src=\"audio.mp3\" type=\"audio/mpeg\">\r\n    您的浏览器不支持 audio 元素。\r\n</audio>\r\n```\r\n\r\n| 属性 | 值     | 描述 |\r\n| :------------- | :------------- | :----|\r\n|autoplay|\tautoplay|如果出现该属性，则音频在就绪后马上播放|\r\n|controls|\tcontrols|\t如果出现该属性，则向用户显示音频控件（比如播放/暂停按钮）|\r\n|loop|\tloop|\t如果出现该属性，则每当音频结束时重新开始播放|\r\n|muted|muted|\t如果出现该属性，则音频输出为静音。|\r\n|preload|\tauto、metadata、none|规定当网页加载时，音频是否默认被加载以及如何被加载。|\r\n|src|\tURL\t|规定音频文件的 URL。|\r\n\r\n## 列表标签\r\n * datalist <br>\r\n  标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。所有主流浏览器都支持 <datalist> 标签，除了 Internet Explorer 和Safari。\r\n```html\r\n<input list=\"browsers\" name=\"browser\">\r\n  <datalist id=\"browsers\">\r\n    <option value=\"Internet Explorer\">\r\n    <option value=\"Firefox\">\r\n    <option value=\"Chrome\">\r\n    <option value=\"Opera\">\r\n    <option value=\"Safari\">\r\n  </datalist>\r\n```\r\n\r\n\r\n## HTML5 新标签兼容性\r\n> 低版本浏览器无法识别一些 H5 的语义化标签，解决方法：浏览器不认识H5标签，所以可以在js中手动创建好这些标签，浏览器就能识别；并且需要给这些标签设置`display:block`，否则通过这种方法创建的新标签，默认是行元素。  下方如：\r\n\r\n* 自己写兼容\r\n```html\r\n<style>\r\n     section,article,aside,header,footer,nav,figure,figcaption,time,mark,main{\r\n        display:block;\r\n    }\r\n</style>\r\n<script>\r\n    document.createElement(\'section\');\r\n    document.createElement(\'article\');\r\n    document.createElement(\'aside\');\r\n    document.createElement(\'header\');\r\n    document.createElement(\'footer\');\r\n    document.createElement(\'nav\');\r\n    document.createElement(\'figure\');\r\n    document.createElement(\'figcaption\');\r\n    document.createElement(\'time\');\r\n    document.createElement(\'mark\');\r\n    document.createElement(\'main\');\r\n</script>\r\n```\r\n对于代码位置，我们需要注意，要将script标签放置到head中，而不是body的后面，这是因为，浏览器从上到下进行代码的执行与解析，在已经渲染之后再执行js就没有任何意义和价值了。\r\n\r\n* 借用封装好的js库 --- html5shiv.js\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head lang=\"en\">\r\n     <meta charset=\"UTF-8\">\r\n     <title>测试H5新标签兼容性</title>\r\n     <script src=\"js/html5shiv.js\"></script>\r\n   </head>\r\n   <body>\r\n     <header id=\"header\">header</header>\r\n     <footer id=\"footer\">footer</footer>\r\n     <script src=\"js/jquery-1.11.0.min.js\"></script>\r\n\r\n     <script>\r\n       $(\'#header\').css(\'color\',\'#f00\');\r\n       $(\'#footer\').css({\'width\':\'50px\',\'height\':\'50px\',\r\n                         \'border\':\'1px solid #ddd\',\r\n                         \'backgroundColor\':\'red\'});\r\n      $(\'#header\').html(\'h5标签兼容\');\r\n    </script>\r\n\r\n  </body>\r\n</html>\r\n```\r\n## 新增标签兼容性\r\n* `<address>` 标签定义文档或文章的作者/拥有者的联系信息。  兼容所有浏览器\r\n* `<area>` 标签定义图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。兼容所有浏览器\r\n* `<small>` 标签呈现小号字体效果。  兼容所有浏览器\r\n* `<base>` 标签为页面上的所有链接规定默认地址或默认目标。   兼容所有浏览器\r\n* `<bdo>` 元素可覆盖默认的文本方向。    兼容所有浏览器\r\n* `<blockquote>` 长文本引用。       兼容所有浏览器\r\n* `<caption>` 元素定义表格标题。    兼容所有浏览器\r\n* `<del>` 定义文档中已被删除的文本    兼容所有浏览器\r\n* `<sub>` 标签可定义下标文本。     兼容所有浏览器\r\n* `<sup>` 标签可定义上标文本。     兼容所有浏览器\r\n* `<article>` 标签规定独立的自包含内容。  IE9及以上\r\n* `<aside>` 标签定义其所处内容之外的内容。   IE9及以上\r\n* `<audio>` 标签定义声音，比如音乐或其他音频流。 IE9及以上\r\n* `<bdi>` 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。 只有 Firefox 和 Chrome 支持 `<bdi>` 标签\r\n* `<canvas>` 标签定义图形，比如图表和其他图像。    IE9及以上\r\n* `<footer>` 标签定义文档或节的页脚。    IE9及以上\r\n* `<nav>` 标签定义导航链接的部分。    IE9及以上\r\n* `<video>` 标签定义视频，比如电影片段或其他视频流。     Internet Explorer 9+, Firefox, Opera, Chrome 以及 Safari 支持 `<video>` 标签\r\n","timestamp":1585877701769},{"name":"08-html5表单新功能解析.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/08-html5表单新功能解析.md","content":"# html5表单新功能解析\r\n> HTML表单一直都是Web的核心技术之一，有了它我们才能在Web上进行各种各样的应用,才能和服务器进行方便快捷的交互。HTML5 Forms新增了许多新控件及其API，方便我们做更复杂的应用，而不用借助其它前端脚本语言(如:javascript),极大的解放了我们的双手。\r\n\r\n## 表单结构更自由\r\n* XHTML中需要放在form之中的诸如inpu/button/s人员配置:elect/textarea等标签元素，在HTML5中完全可以放在页面任何位置，然后通过新增的form属性指向元素所属表单的ID值，即可关联起来\r\n\r\n```css\r\n<form id=\"myform\"></form>\r\n<input type=\"text\" form=\"myform\" value=\"\">\r\n```\r\n\r\n## 多样的输入方式\r\n\r\n| input类型 | 描述     |\r\n| :------------- | :------------- |\r\n| email     | 输入邮箱     |\r\n| url     | 输入url地址     |\r\n| color    | 颜色选择     |\r\n| date  | 日期选择    |\r\n| number  | 输入数字    |\r\n| range  | 滑条    |\r\n| search  | 搜索框    |\r\n| date  | 日期选择    |\r\n\r\n\r\n### email输入类型\r\n> 说明：此类型要求输入格式正确的email地址,否则浏览器是不允许提交的,并会有一个错误信息提示,此类型必须指定name值,否则无效果.\r\n\r\n```css\r\n<input type=email name=email>\r\n```\r\n### url输入类型\r\n> 要求输入格式正确的URL地址,Opera中会自动在开始处添加http://.\r\n\r\n```css\r\n<input type=url name=url>\r\n```\r\n### 日期输入相关的类型\r\n> 这一系列是很酷的一个类型,完全解决了烦琐的JS日历控件问题.但目前MS只有Opera/Chrome新版本支持,且展示效果也不一样..\r\n\r\n```html\r\n<input type=date name=date>\r\n<input type=time name=time>\r\n<input type=month name=month>\r\n<input type=week name=week>\r\n<input type=datetime name=datetime>\r\n<input type=datetime-local name=datetime-local>\r\n\r\n```\r\n### number输入类型\r\n> 输入一个数字字符,若未输入则会抛出一个错误\r\n\r\n```html\r\n<input type=number max=10 min=0 step=1 value=5/>\r\n\r\n```\r\n\r\n| 属性    | 值    | 描述|\r\n| :------------- | :------------- | :------------- |\r\n| max      | number       | 规定允许的最大值|\r\n| mub      | number       | 规定允许的最小值|\r\n| step     | number       | 规定合法的数字间隔 （如果 step=\"3\"，则合法的数是 -3,0,3,6 等）|\r\n| value     | number       | 规定默认值|\r\n\r\n### range滑块类型\r\n> 特定值的范围的数值，以滑动条显示\r\n\r\n```html\r\n<input type=range max=10 min=0 step=1 value=5/>\r\n```\r\n| 属性    | 值    | 描述|\r\n| :------------- | :------------- | :------------- |\r\n| max      | number       | 规定允许的最大值|\r\n| mub      | number       | 规定允许的最小值|\r\n| step     | number       | 规定合法的数字间隔 （如果 step=\"3\"，则合法的数是 -3,0,3,6 等）|\r\n| value     | number       | 规定默认值|\r\n\r\n### search输入类型\r\n> 此类型表示输入的将是一个搜索关键字\r\n\r\n```html\r\n<input type=search name=search >\r\n```\r\n\r\n### tel输入类型\r\n> 此类型要求输入一个电话号码,但实际上它并没有特殊的验证,与text类型没什么区别.\r\n\r\n```html\r\n<input type=tel name=tel >\r\n```\r\n\r\n### color输入类型\r\n> 说明：此类型表单,可让用户通过颜色选择器选择一个颜色值,并反馈到该控件的value值中\r\n\r\n```html\r\n<input type=color name=color>\r\n\r\n```\r\n## 新增的属性\r\n### placeholder属性\r\n> 说明：这是一个很实用的属性,免去了用JS去实现点击清除表单初始值.浏览器支持也还不错,MS除了Firefox,其他标准浏览器都能很好的支持.\r\n\r\n```html\r\n<input id=placeholder placeholder=\"点击我会以清除\">\r\n```\r\n\r\n### required/pattern属性\r\n> 这是html5新加的验证属性\r\nrequired类型，值不能为空，并会有一个提示。有两种写法，这个很有用。并且可以用于textarea以及hidden/image/submit类型\r\npattern类型为正则验证，可以完成各种复杂的验证。这两种类型必须指定name值，否则无效果。\r\n\r\n```html\r\n<input id=placeholder name=require required>\r\n<input id=placeholder name=require1 required=\"required\">\r\n<input name=require2 pattern=\"^[1-9]\\d{5}$\">\r\n```\r\n\r\n### autofocus自动聚焦属性\r\n> 自动聚焦属性,可在页面加载时聚焦到一个表单控件,类似于js的focus()\r\n\r\n```html\r\n<input autofocus=true >\r\n```\r\n### autocomplete自动完成属性\r\n> 此属性是为表单提供自动完成功能。如果该属性为打开状态可很好地自动完成。一般来说，此属性必须启动浏览器的自动完成功能。\r\n\r\n```html\r\n<input autocomplete=on/off>\r\n```\r\n\r\n### novalidate 属性\r\n> novalidate 属性规定在提交表单时不应该验证 form 或 input 域。\r\n\r\n```html\r\n<form action=demo_form.asp method=get novalidate=true>\r\n\r\n```\r\n\r\n### multiple 属性\r\n> multiple 属性规定输入域中可选择多个.multiple 属性适用于以下类型的 ``<input>`` 标签：email 和 file。\r\n\r\n```html\r\n<input type=file name=img multiple=multiple />\r\n```\r\n\r\n### 表单重写属性\r\n> 表单重写属性（form override attributes）允许您重写 form 元素的某些属性设定。表单重写属性适用于以下类型的 `<input> `标签：submit\r\n```html\r\nformaction - 重写表单的 action 属性\r\nformenctype - 重写表单的 enctype 属性\r\nformmethod - 重写表单的 method 属性\r\nformnovalidate - 重写表单的 novalidate 属性\r\nformtarget - 重写表单的 target 属性\r\n```\r\n\r\n### list属性\r\n> list 属性引用数据列表，其中包含输入字段的预定义选项。\r\n\r\n```html\r\n<form action>\r\nWebpage: <input type=url list=url_list name=link />\r\n<datalist id=url_list>\r\n  <option label=uek value=uek/>\r\n  <option label=sxuek value=sxuek />\r\n  <option label=tyuek value=tyuek />\r\n</datalist>\r\n<input type=submit />\r\n</form>\r\n```\r\n","timestamp":1585877701769},{"name":"09-html5其他.md","path":"001-前端/07-HTML & CSS/003-Web基础/01-HTML5/09-html5其他.md","content":"# svg\r\n## SVG 简介\r\n* 可缩放矢量图形（Scalable Vector Graphics，SVG）是基于可扩展标记语言（XML），用于描述二维矢量图形的一种图形格式。SVG由W3C制定，是一个开放标准。SVG是一种矢量图格式。\r\n*   在 2003 年1月，SVG 1.1 被确立为 W3C 标准。参与定义 SVG 的组织有：Adobe、苹果、Auto Desk、Bit Flash、Corel、惠普、IBM、ILOG、INSO、Macromedia、微软、Netscape、OASIS、Open Text、Quark、RAL(CCLRC)、Sun、Visio、施乐等，所以SVG不是一个私有格式，而是一个开放的标准。也就是说，它并不属于任何个体的专利，而是一个通过协作、共同开发的工业标准。正是因为这点，才使得SVG能够得到更迅速的开发和应用。\r\n\r\n## 优势\r\n* SVG 可被非常多的工具读取和修改（比如记事本），支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果，易于修改和编辑。\r\n* SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。\r\n* SVG 是可伸缩的\r\n* SVG 图像可在任何的分辨率下被高质量地打印\r\n* SVG 可在图像质量不下降的情况下被放大\r\n* SVG可以方便的建立文字索引，从而实现基于内容的图像搜索，图像中的文本是可选的，同时也是可搜索的（很适合制作地图）。\r\n* SVG 可与现有技术可以互动融合。例如，SVG技术本身的动态部分（包括时序控制和动画）就是基于SMIL标准。另\r\n* SVG文件还可嵌入JavaScript（严格的说应该是ECMA Script)脚本来控制SVG对象，还可以与 Java 技术一起运行\r\n* SVG 文件是纯粹的 XML。\r\n* SVG 图形格式可以用来动态生成图形。例如，可用SVG动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户\r\n\r\n\r\nSVG的出现带来了一次技术革命。利用SVG能够创建更加丰富多彩的信息可视化和交互性的应用，尤其是可以创建具有动态的、数据驱动的、交互式图形、图像。另外，由于是纯文本格式的．SVG比传统的图形、图像格式如GIF和JPEG占用更少的空间。因此，SVG更加适合有线带宽，并可提高下载速度。SVG和XML的开放式标准特性使其成为国际性语言。SVG标准得到了IBM、Adobe、Microsoft、Corel等几十家大公司的支持，其最新的版本是SVG 1.2。\r\n总之，SVG技术的出现，变革了在Web上图文传递信息的方式，并将产生一种更适于Web信息发布的工作流模式，其中包括Web信息显示和印刷出版的组织方式。\r\n\r\n## SVG 实例\r\n\r\n```html\r\n<?xml version=\"1.0\" standalone=\"no\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg width=\"100%\" height=\"100%\" version=\"1.1\"\r\nxmlns=\"http://www.w3.org/2000/svg\">\r\n<circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/>\r\n</svg>\r\n```\r\n\r\n>* 第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。standalone=\"no\" 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。\r\n* 第二和第三行引用了这个外部的 SVG DTD。该 DTD 于\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"该 DTD 位于 W3C,含有所有允许的 SVG 元素。SVG 代码以 `<svg> ` 元素开始，包括开启标签 `<svg>` 和关闭标签 `</svg>` 。这是根元素。\r\n* width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。\r\n* SVG 的 `<circle>` 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。\r\n* stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。\r\n* fill 属性设置形状内的颜色。我们把填充颜色设置为红色。\r\n* 关闭标签的作用是关闭 SVG 元素和文档本身。\r\n\r\n\r\n## HTML引入SVG的方式\r\n\r\n* 使用 `<embed>` 标签\r\n```html\r\n<embed src=\"rect.svg\" width=\"300\" height=\"100\"\r\ntype=\"image/svg+xml\"\r\npluginspage=\"http://www.adobe.com/svg/viewer/install/\" />\r\n```\r\n\r\n* 使用 `<object>` 标签\r\n```html\r\n<object data=\"rect.svg\" width=\"300\" height=\"100\"\r\ntype=\"image/svg+xml\"\r\ncodebase=\"http://www.adobe.com/svg/viewer/install/\" />\r\n```\r\n\r\n* 使用 `<iframe>`标签\r\n```html\r\n<iframe src=\"rect.svg\" width=\"300\" height=\"100\">\r\n</iframe>\r\n `<iframe>` 标签可工作在大部分的浏览器中。\r\n```\r\n\r\n\r\n## H5的引入方式\r\n\r\n* 把 SVG 直接嵌入 HTML 页面\r\n```\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\">\r\n  <polygon points=\"100,10 40,180 190,60 10,60 160,180\"\r\n  style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\" />\r\n</svg>\r\n```\r\n\r\n## svg 的形状\r\n* SVG 有一些预定义的形状元素，可被开发者使用和操作\r\n* 矩形 `<rect>`\r\n* 圆形 `<circle>`\r\n* 椭圆 `<ellipse>`\r\n* 线 `<line>`\r\n* 折线 `<polyline>`\r\n* 多边形 `<polygon>`\r\n* 路径 `<path>`\r\n\r\n## SVG的样式\r\n> 主要是给svg定义的形状添加样式。\r\n| 样式和属性     | 含义    | 可能的值 |\r\n| :------------- | :------------- |:------|\r\n| 样式和属性     | 含义    | 可能的值 |\r\n| fill|\t填充 |\t颜色值|\r\n| stroke|\t描边 |\t颜色值 |\r\n| stroke-width |\t描边宽度\t| 数字（通常以像素为单位）|\r\n| opacity\t| 不透明度\t| 0.0（完全透明）和1.0（完全不透明）之间的数值|\r\n| font-family\t| 字体\t| text标签特有，CSS字体|\r\n| font-size\t| 字体大小\t| text标签特有，数字|\r\n| text-anchor\t| 对齐方式\t| text标签特有，left/center/right|\r\n\r\n\r\n\r\n\r\n\r\n## 形状实例\r\n* 矩形\r\n> x和y的指定左上角的坐标，width和height指定矩形的尺寸。\r\n\r\n  ```html\r\n  <rect x=\"20\" y=\"20\" width=\"250\" height=\"250\"\r\n  style=\"fill:blue;stroke:pink;stroke-width:5;\r\n  fill-opacity:0.1;stroke-opacity:0.9\"/>\r\n  ```\r\n\r\n* 圆形\r\n> cx和cy指定圆心的坐标，ŗ表示半径大小\r\n\r\n  ```html\r\n  <circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/>\r\n  ```\r\n\r\n* 椭圆\r\n> cx和cy指定圆心坐标，rx和ry分别指定横半轴纵半轴长度\r\n\r\n  ```html\r\n  <ellipse cx=\"250\" cy=\"25\" rx=\"100\" ry=\"25\"/>\r\n  ```\r\n\r\n* 线条\r\n>用x1和Y1到指定线的一端的坐标，x2和y2指定的另一端的坐标。stroke指定描边让线是可见的\r\n\r\n  ```html\r\n  <line x1=\"0\" y1=\"0\" x2=\"300\" y2=\"300\" style=\"stroke:rgb(99,99,99);stroke-width:2\"/>\r\n  ```\r\n\r\n* 多边形\r\n> points 表示多边形的每一个点\r\n\r\n  ```html\r\n  <polygon points=\"220,100 ,300,210 ,170,250\" style=\"fill:#cccccc;stroke:#000000;stroke-width:1\"/>\r\n  ```\r\n\r\n* 文本\r\n> x和y指定文本的位置。\r\n\r\n  ```html\r\n  <text x=\"250\" y=\"25\">Easy-peasy</text>\r\n  ```\r\n\r\n\r\n\r\n\r\n# H5离线缓存技术\r\n\r\n## 简介\r\n离线存储可以将站点的一些文件存储在本地，在没有网络的时候还是可以访问到以缓存的对应的站点页面，其中这些文件可以包括html，js，css，img等等文件，但其实即使在有网络的时候，浏览器也会优先使用已离线存储的文件，返回一个200（from cache）头。这跟HTTP的缓存使用策略是不同的。\r\n\r\n## 特点\r\n它是浏览器自己的一种机制，随着移动互联网时代的到来，网络可靠性降低，如果我们已经将需要的文件缓存下下来，一旦网络无法访问，也能继续访问。而且做好相应资源的缓存可以带来更好的用户体验，当用户使用自己的流量上网时，本地缓存不仅可以提高用户访问速度，而且大大节约用户的使用流量。\r\n\r\n### 什么是Manifest？\r\nhtml新增了一个manifest属性，可以用来指定当前页面的manifest文件。\r\n\r\n其实Manifest是一个简单的 文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，当第一次打开时，浏览器会自动缓存相应的资源。\r\n\r\n### Manifest 的特点：\r\n* 离线浏览：即当网络断开时，可以继续访问你的页面。\r\n* 访问速度快：将文件缓存到本地，不需每次都从网络上请求。\r\n* 稳定性：做了Manifest缓存，遇到突发网络故障或者服务器故障，继续访问本地缓存。\r\n\r\n### Manifest 的使用\r\n1. 创建一个和html同名的manifest文件，比如页面为index.html，那么可以建一个index.manifest的文件，然后给index.html的html标签添加如下属性即可：\r\n```\r\n<html lang=\"en\" manifest=\"index.manifest\"> 或<html manifest=\"http://www.example.com/index.manifest\">\r\n```\r\n    * manifest 的引入可以使绝对路径也可以是相对路径，如果你使用的是绝对路径，你的manifest文件必须和你的站点挂在同一个域名下。\r\n    * manifest文件你可以保存为任意的扩展名，但mine-type 必须是 text/cache-manifest。\r\n    * 在服务器上部署时需要在服务器上添加相应的mie-type\r\n2. manifest 标签应该包含到你需要缓存资源的页面，当第一次打开该页面时，浏览器会解析该页面中的mainfest，并缓存里面列举的资源，同时该页面也会自动会被浏览器缓存，即使该页面没有在Manifest中列出。\r\n    * 注意：\"/page-url/\", \"/page-url/?something\", \"/page-url/?something-else\"  Manifest 会当成不同的页面，如果page-url页面中包含了 Manifest 属性则浏览器会将该页面中列举出来的资源分别保存，所以Manifest最好使用在SPA（单页应用）项目中。\r\n    * 在Chrome中，可以使用 chrome://appcache-internals/ 查看你缓存在本地的资源文件。\r\n\r\n\r\n### Manifest文件结构\r\nmanifest文件，基本格式为三段： CACHE， NETWORK，与 FALLBACK，其中NETWORK和FALLBACK为可选项。\r\n1. 第一行CACHE MANIFEST为固定格式，必须写在前面。\r\n> 以#号开头的是注释，可以是版本号，时间戳等等。一般会在这写个版本号，用来在缓存的文件更新时，更改manifest的作用：浏览器已经缓存下来的缓存，只有当manifest文件发生了改变才会更新本地缓存，即使你的代码发生了更新，本地浏览器也是不知道的，所以每次发布代码时你可以更改下#后面的信息比如版本号或者时间，告诉浏览器相应的更新本地缓存。\r\n\r\n    * 第一行是CACHE MANIFEST 这是必须需要的。\r\n    * CACHE（必须） 标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。这里列举出来的文件，当第一次加载下来时，会被浏览器缓存在本地。\r\n    * NETWORk  这一部分是要绕过缓存直接读取的文件，可以使用通配符 *，大多数网站使用 * 。 当使用* 时 表示出 CACHE指定文件外，其它所有页面都需要联网访问\r\n    * FALLBACK  （可选） 当资源无法访问时，浏览器使用后备资源去替代。第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。\r\n\r\n```\r\nCACHE MANIFEST  \r\n#VERSION 2016-09-28 14:44\r\n\r\n#直接缓存的文件  \r\nCACHE:\r\n../index.html\r\n../css/index.css  \r\n../js/index.js\r\n../images/loading.gif\r\n\r\n#需要在线请求的文件路径，*代表除CACHE以外的文件都进行在线请求\r\nNETWORK:\r\n*\r\n#替代方案 ，当请求失败时需要跳转的页面\r\nFALLBACK:\r\n../error.html\r\n```\r\n\r\n### 更新缓存\r\n* 更新manifest文件\r\n> 给manifest添加或删除文件，都可更新缓存，如果我们更改了js，而没有新增或删除，前面例子中注释中的版本号，可以很好的用来更新manifest文件。\r\n\r\n* 通过javascript操作\r\n> html5中引入了js操作离线缓存的方法，下面的js可以手动更新本地缓存。\r\nwindow.applicationCache.update();\r\n\r\n* 清除浏览器缓存\r\n> 如果用户清除了浏览器缓存（手动或用其他一些工具）都会重新下载文件\r\n","timestamp":1585877701769},{"name":"01-css3简介.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/01-css3简介.md","content":"# CSS3简介\r\n> web页面=结构+表现+行为。\r\n\r\n* 利用CSS我们可以将页面内容和表现进行分离，极大的提高我们的开发速度\r\n* CSS2 提供的相关标准已经不能满足我们当下开发的需求\r\n>我们需要实现更加美观、用户体验更好的界面。CSS3，这个新一代的标准应运而生\r\n\r\n* CSS3中提供了一系列非常强大的功能\r\n>如新增选择器使我们能够更加灵活的选择页面的元素，新增了关于背景、边框、圆角、文本模型等相关属性可以是我们的页面更加的美观，动画属性能够让我们很轻松的实现动画，响应式让一个页面能够适配到各个终端。\r\n\r\n* 使用方便，效果美观\r\n>这些 CSS3 新特性可以说都是非常强大和完善的，你只需要加入几行简单的 CSS 代码便可以实现出一系列令人眼前一亮的效果，这比我们之前用 JavaScript 去模拟这样的效果要好得多，不仅降低了开发复杂度，变得易维护，在性能上也突飞猛进了。\r\n\r\n## CSS3模块 <br/>\r\n   CSS3被拆分成各个模块，一些重要要的CSS3模块。\r\n* 选择器\r\n* 盒模型\r\n* 背景、边框\r\n* 颜色模式\r\n* 文字特效\r\n* 2D、3D转换\r\n* 过渡、动画\r\n* 多列布局\r\n* 用户界面\r\n","timestamp":1585877701769},{"name":"010-css3 3D转换.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/010-css3 3D转换.md","content":"# css3 `＜3D 转换＞`\r\n> 通过 CSS3 3D 转换，能够使我们对元素在2d空间内模拟3D运动，如：元素绕着Y轴和X轴旋转，沿着Z轴进行移动、缩放、拉长或拉伸等等。\r\n\r\n## 3D兼容性\r\n![3d兼容](amWiki/images/3d.png)\r\n\r\n## css3D属性\r\n| **属性** | **描述** | **CSS** |\r\n| :--- |: --- |: --- |\r\n| transform | 向元素应用 2D 或 3D 转换函数。 | 3 |\r\n| transform-origin | 允许你改变被转换元素的位置。| 3 |\r\n| transform-style | 规定被嵌套元素如何在 3D 空间中显示。flat子元素将不保留其 3D 位置。preserve-3d 子元素将保留其 3D 位置 | 3 |\r\n| perspective | 规定 3D 元素的透视效果。 | 3 |\r\n| perspective-origin | 规定观察者的位置。 | 3 |\r\n| backface-visibility | 定义元素在不面对屏幕时是否可见。visible  背面可见hidden 背面不可见 | 3 |\r\n\r\n\r\n## css3`<3D 转换>`函数(transform-functions-3d)\r\n| **函数** | **描述** |\r\n| :--- |: --- |\r\n| matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) | 定义 3D 转换，使用 16 个值的 4x4 矩阵。 |\r\n| translate3d(x,y,z) | 定义 3D 转化。 |\r\n| translateX(x) | 定义 3D 转化，仅使用用于 X 轴的值。 |\r\n| translateY(y) | 定义 3D 转化，仅使用用于 Y 轴的值。 |\r\n| translateZ(z) | 定义 3D 转化，仅使用用于 Z 轴的值。 |\r\n| scale3d(x,y,z) | 定义 3D 缩放转换。 |\r\n| scaleX(x) | 定义 3D 缩放转换，通过给定一个 X 轴的值。 |\r\n| scaleY(y) | 定义 3D 缩放转换，通过给定一个 Y 轴的值。 |\r\n| scaleZ(z) | 定义 3D 缩放转换，通过给定一个 Z 轴的值。 |\r\n| rotate3d(x,y,z,angle) | 定义 3D 旋转。 |\r\n| rotateX(angle) | 定义沿 X 轴的 3D 旋转。 |\r\n| rotateY(angle) | 定义沿 Y 轴的 3D 旋转。 |\r\n| rotateZ(angle) | 定义沿 Z 轴的 3D 旋转。 |\r\n\r\n\r\n## 3D 实例\r\n> 要定义3d,那么首先需要的是在平面上建立一个三维的场景\r\n\r\n### 3D场景的建立\r\n```css\r\n#box{\r\n  width:800px;\r\n  height:800px;\r\n  perspective: 2000px; //定义透视点\r\n  perspective-origin: center center ; //默认的观察者位置是在中间的。当然我们可以改变。\r\n}\r\n\r\n```\r\n\r\n### 3D背面的元素可见\r\n> 当一个元素是背靠我们的时候，默认时候我们是看不见这个元素的\r\n\r\n```css\r\n#box{\r\n  width:800px;\r\n  height:800px;\r\n  backface-visibility: visible;//这样我们就可以看见这个元素的背面了。\r\n}\r\n\r\n```\r\n\r\n\r\n### 改变3D元素的变换轴\r\n> 默认的变化中心的点都是在中心的\r\n\r\n```css\r\ndiv{\r\n  transform-origin: center center 200px; //这个时候我们将这个元素的变化轴向Z轴移动了200px\r\n}\r\n\r\n```\r\n\r\n\r\n### 3D旋转变化\r\n> 默认是z轴旋转的，有了3d之后，那么x和y的变化就可以看见效果了\r\n\r\n```css\r\ndiv{\r\n  width:200px;\r\n  height:200px;\r\n  transform:rotate(360deg);\r\n//transform:rotate3d(1,100,10,360deg);\r\n//transform:rotate3d(x,y,z,Ddeg);   由原点指向(x,y,z)成方向轴，然后左手定则，确定旋转方向，进行D角度旋转，得到特效结果。\r\n}\r\n\r\n```\r\n\r\n\r\n### 3D平移变化\r\n\r\n```css\r\ndiv{\r\n  width:200px;\r\n  height:200px;\r\n  transform:translate3d(200px,200px,200px);\r\n//transform:rotateZ(200px);  \r\n}\r\n\r\n```\r\n","timestamp":1585877701769},{"name":"011-css3动画.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/011-css3动画.md","content":"# CSS3动画\r\n> 通过 CSS3，我们能够轻松创建动画，能够精确控制该元素在动画期间的每一个状态，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。\r\n\r\n\r\n\r\n## CSS3 `@keyframes`\r\n\r\n## `@keyframes`兼容性 \r\n![动画](amWiki/images/dh.png)\r\n\r\n\r\n\r\n### `@keyframes`语法\r\n| 值 |\t描述|\r\n|:----|:---|\r\n| animationname |\t必需。定义动画的名称。|\r\n| keyframes-selector| \t必需。动画时长的百分比。合法的值：  0-100%  from（与 0% 相同）to（与 100% 相同）|\r\n| css-styles \t|必需。一个或多个合法的 CSS 样式属性。|\r\n\r\n## `animation` 动画\r\n> 当我们在 `@keyframes` 中创建动画以后，要把它捆绑到某个选择器，否则不会产生动画效果。捆绑的时候要用到css3新属性，animate规定至少以下两项 CSS3 动画属性，即可将动画绑定到选择器：规定动画的名称、规定动画的时长\r\n\r\n\r\n### 实例\r\n```css\r\ndiv\r\n{\r\nanimation: keyframesName 5s;\r\n-moz-animation: keyframesName 5s;\t/* Firefox */\r\n-webkit-animation: keyframesName 5s;\t/* Safari 和 Chrome */\r\n-o-animation: keyframesName 5s;\t/* Opera */\r\n}\r\n```\r\n\r\n### CSS3 animate属性\r\n| 属性| 描述|\r\n|:----|:---|\r\n| animation |\t所有动画属性的简写属性，除了 animation-play-state 属性。 `animation: name duration timing-function delay iteration-count direction;`|\r\n| animation-name |\t规定` @keyframes `动画的名称。 `animation-name: keyframename/none;`|\r\n| animation-duration \t|规定动画完成一个周期所花费的秒或毫秒。默认是 0。` animation-duration: time;`|\r\n| animation-timing-function \t|规定动画的速度曲线。默认是 \"ease\"。请参考动画函数--`animation-timing-function`|\r\n| animation-delay |\t规定动画何时开始。默认是 0。`animation-delay: time;`|\r\n| animation-iteration-count \t|规定动画被播放的次数。默认是 1 ,`animation-iteration-count:n/infinite;`|\r\n| animation-direction \t|规定动画是否在下一周期逆向地播放。默认是 \"normal\"。normal 默认值:动画应该正常播放。 alternate 动画应该轮流反向播放。|\r\n| animation-play-state \t|规定动画是否正在运行或暂停。默认是 \"running\"`animation-play-state: paused/running; `paused:规定动画已暂停。running:规定动画正在播放。|\r\n\r\n\r\n### animation-timing-function\r\n| 值 \t|描述|\r\n|:----|:---|\r\n| linear| \t动画从头到尾的速度是相同的。\r\n| ease |\t默认。动画以低速开始，然后加快，在结束前变慢。\r\n| ease-in |\t动画以低速开始。\r\n| ease-out |\t动画以低速结束。\r\n| ease-in-out |\t动画以低速开始和结束。\r\n| cubic-bezier(n,n,n,n) |\t在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值； http://cubic-bezier.com/ 这个网站可以帮助我们去定义动画，或者是打开控制台去调整\r\n\r\n### 定格动画(需要借助JS实现)\r\n> 定义在动画结束的时候，我们做的工作。\r\n\r\n| 值 |\t描述|\r\n|:----|:---|\r\n| animationend | \t当animation 执行完成后js调用的事件|\r\n| animationend|\tmoz内核|\r\n| webkitAnimationEnd |\twebkit内核\r\n| oAnimationEnd\t| opera内核|\r\n| MSAnimationEnd|\tIE内核|\r\n\r\n| 值 |\t描述|\r\n|:----|:---|\r\n| transitionend |\t当transition 执行完成后 js调用的事件\r\n| transitionend\t| moz内核\r\n| webkitTransitionEnd | \twebkit内核\r\n| oTransitionEnd\t| opera内核\r\n| MSTransitionEnd\t| IE内核\r\n","timestamp":1585877701769},{"name":"012-css3单位.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/012-css3单位.md","content":"# 单位\r\n## 长度单位\r\n### 文本相对长度单位\r\n\r\n|长度单位 | 描述 |\r\n|:----|:----|\r\n| em | 相对于父元素文本字体大小|\r\n| ex | 相对于字符\'x\'的高度。通常为字体高度的一半|\r\n| eh | 数字\'0\'的宽度|\r\n| rem | 相对于根元素（html）font-size计算的倍数|\r\n\r\n### 视口相对长度单位\r\n\r\n|长度单位 | 描述 |\r\n|:----|:----|\r\n| vw | 相对于视口的宽度。视口被均分为100单位的vw|\r\n| wh | 相对于视口的高度。视口被均分为100单位的vh|\r\n| vmax | 相对于视口的宽度或高度，总是相对于大的那个。视口的宽度或高度被均分为100单位的vmax|\r\n| vmin | 相对于视口的宽度或高度，总是相对于小的那个。视口的宽度或高度被均分为100单位的vmax|\r\n\r\n### 绝对长度单位\r\n\r\n|长度单位 | 描述 |\r\n|:----|:----|\r\n|cm\t|\t厘米|\r\n|mm\t|\t毫米|\r\n|q\t|\t1/4毫米（quarter-millimeters）; 1q = 0.25mm|\r\n|in\t|\t英寸（inches）; 1in = 2.54cm|\r\n|pt\t|\t点（points）; 1pt = 1/72in|\r\n|pc\t|\t派卡（picas）; 1pc = 12pt|\r\n|px\t|\t像素（pixels）; 1px = 1/96in|\r\n\r\n\r\n## 角度单位\r\n\r\n|长度单位 | 描述 |\r\n|:----|:----|\r\n|角度单位\t|描述|\r\n|deg\t|\t度（Degrees）|\r\n|rad\t|\t弧度（Radians）|\r\n|turn\t|\t转、圈（Turns）|\r\n> 角度转换为弧度   弧度=角度* Math.PI / 180   \r\n> 1true=360deg=2rad\r\n","timestamp":1585877701769},{"name":"013-Grid布局.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/013-Grid布局.md","content":"# Grid的由来\r\n> CSS一直用来布局网页，但一直都不完美。 一开始我们使用table 做布局，然后转向浮动、定位以及inline-block，但所有这些方法本质上都是 Hack 的方式，并且遗漏了很多重要的功能（例如垂直居中）。 Flexbox的出现在一定程度上解决了这个问题，但是它的目的是为了更简单的一维布局，而不是复杂的二维布局（Flexbox和Grid实际上一起工作得很好）。 只要我们一直在制作网站，我们就一直在为解决布局问题不断探索， 而Grid是第一个专门为解决布局问题而生的CSS模块。\r\n\r\n## Gird简介和基本概念\r\n* grid布局又称CSS网格布局，（又名“网格”）是一个二维的基于网格的布局系统，其目的只在于完全改变我们设计基于网格的用户界面的方式。\r\n* grid中的一些概念\r\n    * 网格容器（Grid Container）元素应用display:grid，它是其所有网格项的父元素。\r\n    * 网格项（Grid Item）网格容器的直接子元素\r\n    * 网格线（Grid Line）组成网格线的分界线。它们可以是列网格线（column grid lines），也可以是行网格线（row grid lines）并居于行或列的任意一侧\r\n    * 网格轨道（Grid Track）两个相邻的网格线之间为网格轨道。\r\n    * 网格单元（Grid Cell）两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。\r\n    * 网格区（Grid Area）网格区是由任意数量网格单元组成\r\n* grid目前兼容性目前还可以，主流浏览器对它的支持力度很大，ie10 11宣布它未来不久会对它有很好的支持，目前则需要使用过时的语法。 所以grid布局目前常用于移动端布局\r\n![grid兼容](amWiki\\images\\grid支持.jpg)\r\n\r\n## 属性介绍\r\n### 父元素上的属性\r\n\r\n| 属性 | 说明 |\r\n| :------------- | :------------- |\r\n| display | 设置grid布局    |\r\n| grid-template-rows | 设置网格的行数    |\r\n|grid-template-columns\t| 设置网格的列数 |\r\n|grid-template-areas\t| 根据子元素的网格名字来排列 |\r\n|grid-column-gap\t| 用来指定竖网格轨道的大小 |\r\n|grid-row-gap\t| 用来指定行网格轨道的大小 |\r\n|grid-gap\t|  grid-column-gap和grid-row-gap这两个属性的缩写方式 |\r\n|justify-items\t| 网格中所有单元格中的内容在X轴的对齐方式 |\r\n|align-items\t| 网格中所有单元格中的内容在Y轴的对齐方式 |\r\n|justify-content\t| 来设置整个网格在网格容器中的X轴的排列方式 |\r\n|align-content\t| 来设置整个网格在网格容器中的Y轴的排列方式 |\r\n|grid-auto-columns\t| 设定隐藏的网格的高 |\r\n|grid-auto-rows\t| 设定隐藏的网格的宽 |\r\n|grid-auto-flow\t| 在布局的时候，选择网格填充的方法 |\r\n\r\n#### 设置grid布局\r\n\r\n```\r\ndisplay:grid | inline-grid |  subgrid;\r\n```\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| grid | 设置块级grid网格布局 |\r\n| inline-grid | 设置一个内联级的网格   |\r\n| subgrid | 如果这个网格本身就是父元素中的某一个单元网格，则这个值是用来表示继承父元素,希望它的行/列的大小继承自它的父级网格容器，而不是自己指定的。 |\r\n\r\n#### 设置网格的列数与行数\r\n\r\n1. grid-template-columns   它表示的是设置列数\r\n```css\r\ngrid-template-columns:100px 10% 1fr 2fr; /*写几个值表示有几列   值可以是px这种固定大小的，也可以是百分比，也可以使用fr这种单位；fr表示总空间减去固定空间和百分比的大小，然后再分配*/\r\ngrid-template-columns: [c1] 200px [c2] 200px [c3] 1fr [c4];/*这里的[]是在给网格线起名字，每个网格线可以有多个名字，用空格隔开就OK，在后面会说到网格线名字的作用*/\r\ngrid-template-columns:repeat(12 1fr);    /*这个repeat是重复的意思，也就是我们创建了12个大小相等的列*/\r\ngrid-template-columns: repeat(auto-fit, 100px);    /*auto-fit 自适应的意思，也就是说尽可能的每块100px填满网格容器*/\r\ngrid-template-columns: repeat(auto-fit, minmax(100px, 1fr));/*上面的这种repeat(auto-fit, 100px)在响应式布局中可能因为不到100像素然后产生留白，所以我们用minmax()来解决，我们用minmax(100px, 1fr)来代替100px   minmax() 函数定义大于或等于 min 且小于或等于 max 的大小范围*/\r\n```\r\n\r\n2. grid-template-rows 与grid-template-columns的使用方法相同  设置网格项的行数\r\n```CSS\r\ngrid-template-rows:100px 10% 1fr 2fr; /*写几个值表示有几行   值可以是px这种固定大小的，也可以是百分比，也可以使用fr这种单位；fr表示总空间减去固定空间和百分比的大小，然后再分配*/\r\n```\r\n3. 简单例子\r\n```css\r\n.box{\r\n    display:grid;\r\n    grid-template-columns: 40px 50px auto 50px 40px;\r\n    grid-template-rows: 25% 100px auto;\r\n}\r\n```\r\n![布局排列](amWiki\\images\\grid_排列.webp)\r\n\r\n```css\r\n.box{\r\n    display:grid;\r\n    grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end];\r\n    grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];\r\n}\r\n```\r\n![布局排列](amWiki\\images\\grid_name排列.webp)\r\n\r\n\r\n\r\n\r\n#### 通过网格单元的名字来布局  grid-template-areas\r\n\r\n>使用这个属性的时候，需要先用子元素上的grid-area属性给子元素起一个名字，然后再配合这个属性来时使用\r\n\r\n```css\r\n.box{\r\n\t\t\tbackground-color: #999;\r\n\t\t\tdisplay: grid;\r\n\t\t\tgrid-template-columns: 100px 80% 1fr 1fr;\r\n\t\t  grid-template-rows: 200px 300px 300px;\r\n\t\t  grid-template-areas: \"header header header header\"\r\n\t\t                       \"main main . sidebar\"\r\n\t\t                       \"footer footer footer footer\"\r\n\t\t   \t/*名字便是元素的名字，点(.)代表的意思是空一格，这个单元格中不放内容 grid_name.webp*/\r\n}\r\n.a{\r\n\t\t\tgrid-area:header;\r\n\t\t\t/*grid-area:;   是给子元素起一个名字*/\r\n\t\t\tbackground-color: blue;\r\n}\r\n.b{\r\n\t\t\tgrid-area:main;\r\n\t\t\tbackground: yellow;\r\n}\r\n.c{\r\n\t\t\tgrid-area:sidebar;\r\n\t\t\tbackground: red;\r\n}\r\n.d{\r\n\t   grid-area:footer;\r\n\t   background: green;\r\n}\r\n<div class=\"box\">\r\n\t\t<div class=\"a\">\r\n\t\t\t头部\r\n\t\t</div>\r\n\t\t<div class=\"b\">\r\n\t\t\t主题\r\n\t\t</div>\r\n\t\t<div class=\"c\">\r\n\t\t\t侧边栏\r\n\t\t</div>\r\n\t\t<div class=\"d\">\r\n\t\t\t底部\r\n\t\t</div>\r\n</div>\r\n```\r\n![名字布局](amWiki\\images\\grid_name.webp)\r\n\r\n#### 设置网格轨道的大小\r\n\r\n* grid-column-gap和grid-row-gap     用来指定横竖网格轨道的大小  只在两个单元格之间产生间距，不再边缘产生\r\n* grid-gap      grid-column-gap和grid-row-gap这两个属性的缩写方式  \r\n\r\n```CSS\r\n.box{\r\n    display:grid;\r\n    grid-template-columns: 100px 50px 100px;\r\n    grid-template-rows: 80px auto 80px;\r\n    grid-column-gap: 10px;\r\n    grid-row-gap: 15px;\r\n    /* grid-gap:15px 10px;     grid-gap: grid-row-gap grid-column-gap; */\r\n}\r\n```\r\n![间距](amWiki\\images\\grid_间距.webp)\r\n\r\n#### justify-items    网格中所有单元格中的内容在网格项X轴的对齐方式   默认是占满宽度整个X轴\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 内容在单元格的左端对齐|\r\n| end | 内容在单元格的右端对齐   |\r\n| center | 内容在单元格X轴的中间位置   |\r\n| stretch | 内容宽度占据整个单元格的X轴 (默认值)   |\r\n\r\n```css\r\n.box{\r\n    display:grid;\r\n    justify-items: center;\r\n}\r\n```\r\n![justify-items](amWiki\\images\\justify-items.webp)\r\n\r\n#### align-items     网格中所有单元格中的内容在网格项Y轴的对齐方式   默认是占满宽度整个Y轴  它的值与justify-items相同\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 内容在单元格的顶端对齐 |\r\n| end | 内容在单元格的底部对齐   |\r\n| center | 内容在单元格Y轴的中间位置   |\r\n| stretch | 内容高度占据整个单元格的Y轴 (默认值)   |\r\n\r\n\r\n```css\r\n.container{\r\n    display:grid;\r\n    align-items: center;\r\n}\r\n```\r\n![align-items](amWiki\\images\\align-items.webp)\r\n\r\n#### justify-content  如果我们使用PX这种固定大小的布局方式的时候，网格的大小可能小于网格容器的大小\r\n\r\n>这个值是用来设置整个网格在网格容器中的X轴的排列方式\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 网格与网格容器的左端对齐 |\r\n| end | 网格与网格容器的右端对齐  |\r\n| center | 网格处于网格容器的X轴的中间   |\r\n| stretch | 调整网格项的大小，使其宽度填充整个网格容器   |\r\n| space-around | 相当于给每一列单元格添加相同的左右margin  |\r\n| space-between | 在网格容器的X轴的两段对齐   |\r\n| space-evenly | 每一列之间的左右间距是相同的  与边缘也有相同的距离  |\r\n\r\n```CSS\r\n.box{\r\n    display:grid;\r\n    justify-content: center;\r\n}\r\n```\r\n![justify-content](amWiki\\images\\justify-content.webp)\r\n\r\n```CSS\r\n.box{\r\n    display:grid;\r\n    justify-content: space-evenly;\r\n}\r\n```\r\n![justify-content_space-evenly](amWiki\\images\\justify-content_space-evenly.webp)\r\n\r\n\r\n#### align-content   如果我们使用PX这种固定大小的布局方式的时候，网格的大小可能小于网格容器的大小\r\n>这个值是用来设置整个网格在网格容器中的Y轴的排列方式\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 网格与网格容器的顶部对齐 |\r\n| end | 网格与网格容器的底部对齐  |\r\n| center | 网格处于网格容器的Y轴的中间   |\r\n| stretch | 调整网格项的大小，使其高度填充整个网格容器   |\r\n| space-around | 相当于给每一行单元格添加相同的上下margin  |\r\n| space-between | 在网格容器的Y轴的两段对齐   |\r\n| space-evenly | 每一行之间的上下间距是相同的  与边缘也有相同的距离  |\r\n\r\n```CSS\r\n.box{\r\n    display: grid;\r\n    align-content: center;\r\n}\r\n```\r\n![align-content](amWiki\\images\\align-content.webp)\r\n```CSS\r\n.box{\r\n    display: grid;\r\n    align-content: space-evenly;\r\n}\r\n```\r\n![align-content_space-evenly](amWiki\\images\\align-content_space-evenly.webp)\r\n\r\n#### grid-auto-columns和grid-auto-rows       设定隐藏的网格轨道的大小\r\n>自动生成隐式网格轨道（列和行），当你定位的网格项超出网格容器范围时，将自动创建隐式网格轨道。网格轨道大小,可以是固定值，百分比或者是分数（fr单位）。\r\n\r\n#### grid-auto-flow     在布局是时候，选择网格填充的方法\r\n>在没有设置网格项的位置时，这个属性控制网格项怎样排列。\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| row | 按照行依次从左到右排列 |\r\n| column | 按照列依次从上倒下排列  |\r\n| dense | 按先后顺序排列   |\r\n\r\n```html\r\n<section class=\"container\">\r\n    <div class=\"item-a\">item-a</div>\r\n    <div class=\"item-b\">item-b</div>\r\n    <div class=\"item-c\">item-c</div>\r\n    <div class=\"item-d\">item-d</div>\r\n    <div class=\"item-e\">item-e</div>\r\n</section>\r\n```\r\n```CSS\r\n.container{\r\n    display: grid;\r\n    grid-template-columns: 60px 60px 60px 60px 60px;\r\n    grid-template-rows: 30px 30px;\r\n    grid-auto-flow: row;\r\n}\r\n.item-a{\r\n    grid-column: 1;\r\n    grid-row: 1 / 3;\r\n}\r\n.item-e{\r\n    grid-column: 5;\r\n    grid-row: 1 / 3;\r\n}\r\n```\r\n1. 设置grid-auto-flow：row，item-b、item-c和item-d在行上是从左到右排列  \r\n![grid-auto-flow：row](amWiki\\images\\row.webp)\r\n2. 设置grid-auto-flow：column;  \r\n![grid-auto-flow：column](amWiki\\images\\column.webp)\r\n\r\n#### grid的简写方式和属性的顺序,设置网格容器所有属性。\r\n> grid: none | grid-template-rows / grid-template-columns | grid-auto-flow [grid-auto-rows [ / grid-auto-columns] ];\r\n\r\n### 设置子元素上的属性\r\n\r\n| 属性 | 说明 |\r\n| :------------- | :------------- |\r\n|grid-area | 给单个子元素起名字    |\r\n|grid-column-start | 元素的位置哪跟竖线开始    |\r\n|grid-column-end\t| 哪跟竖线结束 |\r\n|grid-row-start\t| 哪跟横线开始 |\r\n|grid-row-end\t| 哪跟横线结束 |\r\n|grid-row\t| grid-row-start和grid-row-end的缩写 |\r\n|grid-column\t|  grid-column-start和grid-column-end这两个属性的缩写方式 |\r\n|grid-area\t| grid-row和grid-column的缩写 |\r\n|justify-self\t| 设置单个子元素在其所在的小网格中的X轴排列方式 |\r\n|align-self\t| 设置单个子元素在其所在的小网格中的Y轴排列方式 |\r\n|align-content\t| 来设置整个网格在网格容器中的Y轴的排列方式 |\r\n\r\n#### grid-area   给单个子元素起名字\r\n>这个属性就是配合父元素上的grid-template-areas属性来使用，grid-area就是给单个网格项起个名字\r\n\r\n#### 设置网格项位置的三种写法\r\n1. grid-column-start     grid-column-end    grid-row-start     grid-row-end\r\n```\r\n从左到右的四个属性的含义：  \r\n\t    \t哪跟竖线开始\r\n\t    \t哪跟竖线结束\r\n\t    \t哪跟横线开始\r\n\t    \t哪跟横线结束\r\n值写数字表示第几跟网格线       也可以写网格线的名字\r\n```\r\n\r\n2. grid-column     grid-row\r\n```\r\ngrid-column: 1 / 2;\r\ngrid-row: 1 / 2;\r\n```\r\n\r\n3. grid-area   grid-column和grid-row的缩写\r\n```css\r\ngrid-area: 1/1/2/2;\r\n/*第三种写法  行起始位置/列起始位置/行结束位置/列结束位置*/\r\n```\r\n\r\n```CSS\r\n.item-a{\r\n  grid-column-start: 2;\r\n  grid-column-end: five;\r\n  grid-row-start: row1-start\r\n  grid-row-end: 3\r\n}\r\n```\r\n![用线来定位](amWiki\\images\\line.webp)\r\n#### 设置单个子元素在其所在的网格项中的排列方式\r\n\r\n1. justify-self   用来设置单个元素在单个网格项中X轴的布局\r\n\r\n| 属性 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 元素与网格的左端对齐    |\r\n| end | 元素与网格的右端对齐    |\r\n| center\t| 元素放置在网格X轴的中间 |\r\n| stretch\t| 元素占满整个网格空间(默认值) |\r\n\r\n2. align-self   与justify-self:;类似，用来设置单个元素在单个网格中Y轴的布局方式，和justify-self有4个相同的值\r\n\r\n| 属性 | 说明 |\r\n| :------------- | :------------- |\r\n| start | 元素与网格的顶部对齐    |\r\n| end | 元素与网格的底部对齐    |\r\n| center\t| 元素放置在网格Y轴的中间 |\r\n| stretch\t| 元素占满整个网格空间(默认值) |\r\n","timestamp":1585877701769},{"name":"014-css3滤镜.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/014-css3滤镜.md","content":"# CSS3滤镜\r\n>CSS 滤镜就是提供类似 PS 的图形特效，像模糊，锐化或元素变色等功能。通常被用于调整图片，背景和边界的渲染。\r\n\r\n## 浏览器的支持情况\r\n![滤镜](amWiki/images/css3滤镜支持.jpg)\r\n\r\n## 属性值预览\r\n1. grayscale(100%) \r\n> 修改所有图片的颜色为黑白 (100% 灰度)\r\n\r\n2. blur(10px)\r\n> 设置高斯模糊，单位为px，值越大越模糊\r\n\r\n3. brightness(%)\r\n> 使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。可以超过100%;\r\n\r\n4. contrast(%)\r\n> 调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。\r\n\r\n5. hue-rotate(deg)\r\n> 给图像应用色相旋转。值为0deg，则图像无变化。超过360deg的值相当于又绕一圈。\r\n\r\n6. invert(%)\r\n> 反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。\r\n\r\n7. opacity(%)\r\n> 转化图像的透明程度。值定义转换的比例。0%则是完全透明,100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。\r\n\r\n8. saturate(%)\r\n> 转换图像饱和度。0%则是完全不饱和，100%则图像无变化。超过100%的值是允许的，则有更高的饱和度。效果跟grayscale好像\r\n\r\n9. sepia(%)\r\n> 将图像转换为深褐色。100%则完全是深褐色的，0%图像无变化。最大值为100%\r\n\r\n10. url()\r\n> URL函数接受一个XML文件，该文件设置了一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。\r\n\r\n11. drop-shadow(offset-x offset-y blur-radius spread-radius color)\r\n> 这个属性与box-shadow属性很像，但是它没有inset这个关键字，使用滤镜的这个属性，浏览器为了更好的性能提升会使用硬件加速，第一个值设置X轴的偏移程度，负数则是在图像的左边，第二个值则是设置Y轴的偏移程度，前两个值必填。第三个值是用来设置模糊程度，值越大越模糊，阴影越大，不允许设置负值。第四个值正数会使得阴影变大，负数使得阴影缩小  第五个颜色的值则是用来设定颜色*/\r\n\r\n### 效果查看\r\n![滤镜](amWiki/images/css3filters.png)\r\n","timestamp":1585877701769},{"name":"02-css3新增选择器.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/02-css3新增选择器.md","content":"# CSS3新增选择器\r\n  选择器就是我们定义的一条规则，通过这条规则我们就可以选择到页面当中的元素，而我们规定的获取元素的规则我们称之为选择器，而在CSS3中又有了一系列新的选择器，这些选择器的出现能够使我们更加灵活的获取页面元素\r\n\r\n## CSS1选择器\r\n\r\n| 选择器 | 类型     |说明|\r\n| :------------- | :------------- | :---- |\r\n| E  | 标签选择器|选择指定类型的元素|\r\n|E#id|\tID选择器\t|选择匹配E的元素，且匹配元素的id为\"id\"，E选择符可以省略。|\r\n|E.class|\t类名选择器|\t选择匹配E的元素，且匹配元素的class属性值为class，E选择符可以省略。|\r\n|E F|\t后代选择器|\t选择被包含在匹配E的元素内部的F元素。|\r\n|E:link\t|链接伪类选择器|\t选择匹配E的元素，且匹配元素被定义了超链接并未被访问。例：a:link|\r\n|E:visited|\t链接伪类选择器|\t选择匹配E的元素，且匹配元素被定义了超链接并已被访问。例：a:visited|\r\n|E:active\t|用户操作伪类选择器|\t选择匹配E的元素，且匹配元素被激活|\r\n|E:hover\t|用户操作伪类选择器\t|选择匹配E的元素，且匹配元素正被鼠标经过|\r\n|E:focus\t|用户操作伪类选择器|\t选择匹配E的元素，且匹配元素获取了焦点|\r\n|E::first-line\t|伪元素选择器|\t选择匹配E元素内的第一行文本|\r\n|E::first-letter|\t伪元素选择器\t|选择匹配E元素内的第一个字符|\r\n\r\n## CSS2定义的选择器\r\n\r\n| 选择器     | 类型     | 说明|\r\n| :------------- | :------------- | :---- |\r\n| *|\t通配选择器\t|选择文档中所有元素|\r\n|E[attr]|\t属性选择器\t|选择匹配E的元素，且该元素定义了attr属性。E选择符可以省略，表示选择定义了attr属性的任意类型的元素。|\r\n|E[attr=\"bar\"]|\t属性选择器\t|选择匹配E的元素，且该元素attr属性值为\"bar\"|\r\n|E[attr~=\"bar\"]|\t属性选择器\t|选择匹配E的元素，且该元素定义了attr属性，attr属性值是一个以空格符分隔的列表，其中一个列表的值为\"bar\"，E选择符可以省略。|\r\n|E[attr!=\"en\"]\t|属性选择器\t|选择匹配E的元素，且该元素定义了attr属性，attr属性值是一个用连字符（-）分隔的列表，值以\"en\"开头。|\r\n|E::before|\t伪元素选择器|\t在匹配E的元素前面插入内容|\r\n|E::after|\t伪元素选择器|\t在匹配E的元素后面插入内容|\r\n|E > F\t|子包含选择器\t|选择匹配F的元素，且该元素为所匹配E元素的子元素。|\r\n<!-- |E + F\t|相邻兄弟选择器\t|选择匹配F的元素，且该元素为所匹配E元素后面相邻的位置。| -->\r\n\r\n\r\n##  CSS3新增属性选择器\r\n\r\n| 选择器     | 类型     | 说明 |\r\n| :------------- | :------------- |:---|\r\n|E[attr^=\"bar\"] |\t属性选择器\t| 选择匹配E的元素，且该元素定义了attr属性，attr属性值以\"bar\"开始。E选择符可以省略，表示可匹配任意类型的元素。|\r\n|E[attr$=\"bar\"]|\t属性选择器|\t选择匹配E的元素，且该元素定义了attr属性，attr属性值以\"bar\"结束。E选择符可以省略，表示可匹配任意类型的元素。|\r\n|E[attr*=\"bar\"]|\t属性选择器\t|选择匹配E的元素，且该元素定义了attr属性，attr属性值包含\"bar\"。E选择符可以省略，表示可匹配任意类型的元素。|\r\n\r\n## 结构伪类选择器\r\n  结构伪类利用DOM实现元素过滤，通过DOM的相互关系来匹配特定的元素，减少文档内对class属性和ID属性的定义，使得文档更加简洁。\r\n\r\n| 选择器 |  说明|\r\n|:------------- |:------------- |\r\n|E:root|\t选择匹配E所在文档的根元素。在（X）HTML文档中，根元素就是html元素，此时该选择器与html类型选择器匹配的内容相同。|\r\n|E:first-child\t|\t选择匹配E的元素，且该元素为父元素的第一个子元素|\r\n|E:last-child\t|选择位于其父元素中最后一个位置，且匹配E的子元素。|\r\n|E:nth-child(n)|\t选择所有在其父元素中第n个位置的匹配E的子元素。|\r\n|E:nth-last-child(n)\t|选择位于其父元素中且匹配E的最后第n子元素。|\r\n|E:nth-last-of-type(n)|\t选择父元素中倒数第n个位置，且匹配E的子元素。|\r\n|E:first-of-type\t|选择位于其父元素中且匹配E的第一个同类型的子元素。该选择器的功能类似于 E:nth-of-type(1)|\r\n|E:last-of-type\t|选择位于其父元素中且匹配E的最后第一个同类型的子元素。该选择器的功能类似于 E:nth-last-of-type(1)|\r\n|E:only-child\t|选择其父元素只包含一个子元素，且该子元素匹配E。|\r\n|E:only-of-type|\t选择其父元素只包含一个同类型的子元素，且该子元素匹配E。|\r\n|E:empty\t|选择匹配E的元素，且该元素不包含子节点。|\r\n\r\n>注意：在此处选择器需要特别注意，这些选择器选择的都是E元素，后面的伪类只是对他的修饰，例如`E:first-child`选择的是E元素并且E必须是作为第一个子元素出现的，而不是选择E的第一个子元素\r\n\r\n>参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始。`tr:nth-child(3)`匹配所有表格中第3排的tr；tr:nth-child(2n+1)匹配所有表格的奇数行；`tr:nth-child(2n)`匹配所有表格的偶数行；`tr:nth-child(odd)`匹配所有表格的奇数行；`tr:nth-child(even)`匹配所有表格的偶数行；`E:nth-last-child(n)`\t选择所有在其父元素中倒数第n个位置的匹配E的子元素E:nth-of-type(n)\t选择父元素中第n个位置，且匹配E的子元素。\r\n注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。例：`p:nth-of-type(1)`。\r\n\r\n## UI伪类选择器\r\n\r\n| 选择器    |   说明 |\r\n| :------------- | :------------- |\r\n|:enabled |\t选择每个启用的 `<input>` 元素。|\r\n|:disabled| 选择每个禁用的 `<input>` 元素 |\r\n|:checked |\t选择每个被选中的 `<input>` 元素。|\r\n|:not(selector)| \t去除所有与给定选择器匹配的元素 |\r\n|::selection | 选择被用户选取的元素部分。|\r\n|::-webkit-input-placeholder ,:-moz-input-placeholder\t|表单 placeholder样式|\r\n|:requried:invalid ,:required:valid|表单验证失败和正确的样式\t|\r\n|:target\t目标伪类选择器类型。|被相关URL指向的元素。注意：该选择器是动态选择器，只有存在URL指向该匹配元素时，样式才起效果。例：demo.html#id|\r\n\r\n## 选择器优先级\r\n一个选择器的优先级由四个数字a,b,c,d确定。当比较两个选择器时，先比较a，a值大的优先级高，如果a相等则比较b，b值大的优先级高，以此类推。因此，无论b的值多大，也不会对a值的比较造成影响。\r\na由style确定，如果一个属性由元素上的style属性定义则a为1，否则a为0;\r\nb是id的数量\r\nc是class和伪类以及属性选择器的数量，后代选择器\r\nd是标签选择器以及伪元素的数量\r\ne通用选择器\r\n伪元素：\r\n对于div内部的元素，比如这个first-line first-letter before after\r\n伪类：选择原宿本身，比如hover  visited link active first-child focus\r\n\r\n* 示例\r\n\r\n```css\r\n*             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */\r\nli            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */\r\nli:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\r\nul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\r\nul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */\r\nh1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */\r\nul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */\r\nli.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */\r\n#x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */\r\nstyle=\"\"          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */\r\n\r\n```\r\n\r\n## 选择器兼容性\r\nie9开始 CSS3 选择器全部可以使用；\r\n\r\nIE7和IE8只支持以下CSS3选择器：兄弟元素选择器 `element1~element2` 和属性选择器`[attr^=val]`、`[attr$=val]`、`[attr*=val]`\r\n\r\n> 注意  `:first-child` 时CSS2选择器，ie7可以使用\r\n\r\n> `::before`和`::after`是CSS2选择器，ie8可以使用，但要注意在ie8时需写成 单冒号`:after`  (因为CSS3开始用单双冒号区分伪类和伪元素选择器)\r\n\r\n![css3选择器](amWiki/images/xuanzeqi.png)\r\n","timestamp":1585877701769},{"name":"03-css3边框.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/03-css3边框.md","content":"# CSS3 边框\r\n  通过 CSS3，能够创建圆角边框，向矩形添加阴影，使用图片来绘制边框不再需使用设计软件，比如 PhotoShop，来做这些效果，能够很轻松的在页面当中做出圆角，阴影等效果。在本节中你将了解到  `border-radius`，`box-shadow`，`border-image`。\r\n\r\n## CSS3 hack\r\n  因为css3并不是所有的浏览器都支持，有些浏览器虽然支持，但是效果也不是很好，所以这些浏览器在支持这些新特性的时候，给这些属性加入自己的厂名，等到css3标准化后再将厂名去掉，比方说：对于圆角的支持。\r\n```css\r\n.box{\r\n　　-moz-border-radius: 30px; /* FF1+ */\r\n    -o-border-radius: 30px;   /* opera */\r\n　　-webkit-border-radius: 30px; /* Saf3+, Chrome */\r\n　　border-radius: 30px; /* Opera 10.5, IE 9 */\r\n}\r\n```\r\n\r\n## CSS3圆角 `border-radius`\r\n\r\n ### 浏览器支持\r\n\r\n![border-radius](amWiki/images/border-radius.jpg)\r\n\r\n ### `border-radius`说明\r\n\r\n  border-radius 属性是一个最多可指定四个 border -*- radius 属性的复合属性    \r\n ### `border-radius`语法\r\n\r\n  `border-radius: 1-4 length|% / 1-4 length|%;`\r\n  按顺时针顺序设置每个 radius的值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。\r\n\r\n```css\r\n.box{\r\n  border-radius:10px;\r\n    /* 四个角 */\r\n}\r\n.box{\r\n  border-radius: 10px 15px;\r\n  /* 上左和下右，上右和下左 */\r\n}\r\n.box{\r\n  border-radius:5p 10px 15px;\r\n  /* 上左，上右和下左，下右 */\r\n}\r\n.box{　　\r\n　　border-radius: 5px 10px 15px 20px;\r\n    /* 上左，上右，下右，下左 */\r\n}\r\n```\r\n## 关于\'/\' 问题\r\n  第一个参数表示圆角的水平半径，第二个参数表示圆角的垂直半径\r\n\r\n```css\r\n.box{\r\n  border-radius:10px 15px;\r\n}\r\n.box{\r\n  -webkit-border-radius:10px 15px;\r\n  /* == */\r\n  border-radius:10px/15px;\r\n}\r\n```\r\n\r\n## CSS3阴影 `box-shadow`\r\n ### 浏览器支持\r\n ![border-radius](amWiki/images/box-shadow.jpg)\r\n\r\n\r\n ### `box-shadow`说明\r\n  box-shadow属性可以设置一个或多个下拉阴影的框。    \r\n ### `box-shadow`语法\r\n  `box-shadow: h-shadow v-shadow blur spread color inset;`\r\n  注意：`box-shadow` 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。\r\n\r\n> `-ms-filter: \"progid:DXImageTransform.Microsoft.dropshadow(OffX=3px, OffY=3px, Color=\'#ffffff\')\"; /* IE8 */`\r\n\r\n| 属性值 | 说明 |\r\n| :------------- | :------------- |\r\n| h-shadow | 必需的。水平阴影的位置。允许负值      |\r\n|v-shadow\t| 必需的。垂直阴影的位置。允许负值 |\r\n|blur\t| 可选。模糊距离 |\r\n|spread\t| 可选。阴影的大小 |\r\n|color\t| 可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表 |\r\n|inset\t| 可选。从外层的阴影（开始时）改变阴影内侧阴影 |\r\n\r\n```css\r\n\r\n\r\n  div{\r\n    /* offset-x | offset-y | blur-radius | spread-radius | color */\r\n    box-shadow: 10px 10px 5px 5px rgba(0, 0, 0, 0.2);\r\n  }\r\n  /* 设置多个阴影, 用逗号隔开 */\r\n  div{\r\n    box-shadow: 3px 3px red, 10px 0 5px olive;\r\n  }\r\n```\r\n\r\n## CSS3 `border-image`\r\n ### 浏览器支持\r\n ![border-image](amWiki/images/border-image.jpg)\r\n\r\n\r\n ### `border-image`说明\r\n  border-image属性可以能给元素的边框添加背景图片。`border-image`属性是复合属性用于设置`border-image-source`，`border-image-slice`，`border-image-width`，` border-image-outset` 和`border-image-repeat` 的值。    \r\n ### `border-image`语法\r\n  `border-image: source slice width outset repeat;`\r\n\r\n| 属性 | 说明     |\r\n| :------------- | :------------- |\r\n| border-image-source |\t用于指定要用于绘制边框的图像的位置 |\r\n| border-image-slice |\t图像边界向内偏移 |\r\n| border-image-width |\t图像边界的宽度 |\r\n| border-image-outset |\t用于指定在边框外部绘制 border-image-area 的量 |\r\n|  border-image-repeat |\t图像边框是否应平铺(repeat)、铺满(round)或拉伸(stretch)。 |\r\n\r\n```css\r\n  div{\r\n    border-image: url(uek.png) 30 round;\r\n  }\r\n```\r\n","timestamp":1585877701769},{"name":"04-css3背景.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/04-css3背景.md","content":"## CSS3 背景\r\n  CSS3 包含多个新的背景属性，它们提供了对背景更强大的控制。 可以自定义背景图的大小，可以规定背景图片的定位区域，CSS3 还允许我们为元素使用多个背景图像。\r\n### 浏览器支持\r\n![background](amWiki/images/background.jpg)\r\n\r\n\r\n| 属性 | 说明     |\r\n| :------------- | :------------- |\r\n| background-image | 设置背景图片 |\r\n| background-clip  | 背景剪裁属性是从指定位置开始绘制  |\r\n| background-origin  | 指定背景图片background-image 属性的原点相对区域  |\r\n| background-size | 背景图片的大小  |\r\n\r\n## `background-image`说明\r\n  CSS3中可以通过`background-image`属性添加背景图片。不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。\r\n  ### `background-image`语法\r\n ```css\r\n .box{\r\n    background-image: url(uek.png);\r\n }\r\n .box{\r\n    background-image: url(uek.png), url(fullstack.png);\r\n }\r\n```\r\n\r\n## `background-clip`说明\r\n  CSS3中background-clip背景剪裁属性是从指定位置开始绘制。\r\n\r\n| 属性值     | 说明     |\r\n| :------------- | :------------- |\r\n|  border-box    | 背景被裁剪到边框盒   |\r\n|  padding-box   | 背景被裁剪到内边距框 |\r\n|  content-box   | 背景被裁剪到内容框   |\r\n### `background-clip`语法\r\n```css\r\n.box{\r\n  background-image: url(uek.png);\r\n  background-clip: border-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/border-box.png)\r\n```css\r\n.box{\r\n  background-image: url(uek.png);\r\n  background-clip: padding-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/padding-box.png)\r\n```css\r\n.box{\r\n  background-image: url(uek.png);\r\n  background-clip: content-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/content-box.png)\r\n\r\n## `background-origin`说明\r\nCSS3中background-origin规定了指定背景图片background-image 属性的原点位置的背景相对区域。\r\n>当使用 `background-attachment` 为fixed时，该属性将被忽略不起作用。\r\n\r\n| 属性值     | 说明     |\r\n| :------------- | :------------- |\r\n|  border-box    | 背景图像相对于边框盒来定位   |\r\n|  padding-box   | 背景图像相对于内边距框来定位 |\r\n|  content-box   | 背景图像相对于内容框来定位   |\r\n\r\n### `background-origin`语法\r\n```css\r\n.box{\r\nbackground-image: url(uek.png);\r\nbackground-origin: border-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/origin-border.png)\r\n```css\r\n.box{\r\nbackground-image: url(uek.png);\r\nbackground-clip: padding-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/origin-padding.png)\r\n```css\r\n.box{\r\nbackground-image: url(uek.png);\r\nbackground-clip: content-box;\r\n}\r\n```\r\n![`border-box`](amWiki/images/origin-content.png)\r\n\r\n## `background-size`说明\r\n  CSS3中background-size设置背景图片大小。\r\n\r\n| 属性值     | 说明     |\r\n| :------------- | :------------- |\r\n|  length   | 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。|\r\n|  percentage   | 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 \"auto\"。 |\r\n|  cover   | 保持图像的纵横比并将调整背景图片的宽度或高度（较小者），以铺满整个元素，图像的某些部分也许无法显示在背景定位区域中。  |\r\n|  contain   | 调整背景图片的宽度或高度（较大者），使背景图片完全包含在元素中。背景可能有空白 |\r\n\r\n### `background-size`语法\r\n```css\r\n.box{\r\n  /* 一个值: 这个值指定图片的宽度，图片的高度隐式的为auto */\r\n  background-size: 50%;\r\n}\r\n.box{\r\n  /* 两个值: 第一个值指定图片的宽度，第二个值指定图片的高度 */\r\n  background-size: 50% auto;\r\n}\r\n.box{\r\n/* 逗号分隔的多个值：设置多重背景 */\r\n  background-size: 50%, 25%, 25%;\r\n}\r\n```\r\n","timestamp":1585877701769},{"name":"05-css3过渡倒影.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/05-css3过渡倒影.md","content":"# CSS3过度倒影\r\n  CSS3过渡就是在某个元素的状态或样式发生变化的时候，你可以给他指定在变化过程中的方式，比方说变化的时间，变化的速度，变化的运动方式，变化的属性等等，可以是我们很轻松的完成动画效果，不用再借助于js的复杂的算法。\r\n\r\n## 浏览器的支持情况\r\n![transition](amWiki/images/transition.jpg);\r\n\r\n\r\n\r\n| 属性 | 说明     |\r\n| :------------- | :------------- |\r\n| transition  | 简写属性，用于在一个属性中设置四个过渡属性 |\r\n| transition-property | 规定应用过渡的 CSS 属性的名称  |\r\n| transition-duration | 定义过渡效果花费的时间，默认0  |\r\n| transition-timing-function | 规定过渡效果的时间曲线，默认`ease`  |\r\n| transition-delay | 规定过渡效果何时开始，默认0  |\r\n\r\n## CSS3过渡效果函数\r\n| 属性值 | 说明     |\r\n| :------------- | :------------- |\r\n| linear |\t规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。|\r\n| ease | 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。|\r\n| ease-in |\t规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。|\r\n| ease-out | 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。|\r\n|ease-in-out | 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。|\r\n| step(num,[end])| 按照规定的步数完成动画 |\r\n|cubic-bezier(n,n,n,n) | 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。|\r\n\r\n## CSS语法\r\n```css\r\n/* 指定宽度进行过渡 */\r\n.box{\r\n  width: 200px;\r\n  transition: width 2s;\r\n}\r\n.box:hover{\r\n  width: 300px;\r\n}\r\n```\r\n> 如果没有指定动画时间，transition将没有任何效果，因为默认值是0。\r\n\r\n```css\r\n/* 在一个例子中使用所有过渡属性 */\r\n.box{\r\n  width: 200px;\r\n  transition-property: width;\r\n  transition-duration: 1s;\r\n  transition-timing-function: linear;\r\n  transition-delay: 2s;\r\n  /* 相应简写 */\r\n  transition: width 1s linear 2s;\r\n  /* 动画属性 时间  动画方式  延迟 */\r\n}\r\n.box:hover{\r\n  width: 300px;\r\n}\r\n```\r\n```css\r\n /* 要添加多个样式的变换效果，添加的属性由逗号分隔 */\r\n.box{\r\n  transition: width 2s, height 2s;\r\n }\r\n```\r\n\r\n## CSS3 倒影\r\n  CSS3倒影，能使我们在不借助图形软件的基础上(如:ps)，绘制出逼真的阴影效果，可以指定阴影的方向，阴影的位置以及阴影的渐变。由于此属性并不是W3C标准属性，在具体使用之时，还是需要添加浏览器的私有属性，根据浏览器的兼容性，使用box-reflect时需要添加-webkit和前缀。\r\n\r\n## 浏览器支持\r\n![box-reflect](amWiki/images/box-reflect.jpg);\r\n\r\n\r\n## CSS语法\r\n  `box-reflect：none | <direction> <offset>? <mask-box-image>?`\r\n  * direction\r\n\r\n|   属性值   | 说明     |\r\n| :------------- | :------------- |\r\n| above | 指定倒影在对象的上边 |\r\n| below | 指定倒影在对象的下边 |\r\n| left  | 指定倒影在对象的左边 |\r\n| right | 指定倒影在对象的右边 |\r\n\r\n  * offset\r\n\r\n|   属性值   | 说明     |\r\n| :------------- | :------------- |\r\n| length | 用长度值来定义倒影与对象之间的间隔。可以为负值 |\r\n| percentage |  用百分比来定义倒影与对象之间的间隔。可以为负值 |\r\n\r\n * mask-box-image\r\n\r\n| 属性值 | 说明     |\r\n| :------------- | :------------- |\r\n| none | 无遮罩图像 |\r\n| url | 使用绝对或相对地址指定遮罩图像 |\r\n| linear-gradient |使用线性渐变创建遮罩图像 |\r\n| radial-gradient |使用径向(放射性)渐变创建遮罩图像 |\r\n| repeating-linear-gradient | 使用重复的线性渐变创建背遮罩像 |\r\n| repeating-radial-gradient | 使用重复的径向(放射性)渐变创建遮罩图像 |\r\n\r\n```css\r\nimg{\r\n  /* 在底部产生倒影 */\r\n  -webkit-box-reflect: below;\r\n  box-reflect: below;\r\n}\r\n```\r\n![底部倒影](amWiki/images/reflex.png)\r\n```css\r\nimg{\r\n  /* 倒影在底部，而且需要让生成的倒影离自身有一个20px的间距 */\r\n  -webkit-box-reflect: below 20px;\r\n  box-reflect: below 20px;\r\n}\r\n```\r\n```css\r\nimg{\r\n    /*渐变生成的背景应用在生成的倒影中 */\r\n  -webkit-box-reflect: below 0 -webkit-linear-gradient(top,rgba(250,250,250,0),rgba(250,250,250,.0) 30%,rgba(250,250,250,0.3));\r\n  box-reflect: below 0 -webkit-linear-gradient(top,rgba(250,250,250,0),rgba(250,250,250,.0) 30%,rgba(250,250,250,0.3));\r\n  }\r\n```\r\n![底部倒影](amWiki/images/reflex-gradient.png)\r\n>目前只能使用线性渐变给生成的倒影添加遮罩效果，而径向渐变到目前还无任何效果。另外有一点特别需要提醒大家，给生成的倒影添加遮罩效果的时候，如果没有设置显式的间距<offset>将会让box-reflect失效。也就是说，当box-reflect属性中的<mask-box-image>属性值出现时，必须显式的设置<offset>值，如果不需要间距，将其设置为0。\r\n\r\n```css  \r\nimg{\r\n  /* 背景图片给倒影添加遮罩效果 */\r\n  -webkit-box-reflect: below 0 url(masking.png);\r\n  box-reflect: below 0 url(masking.png);\r\n}  \r\n/*img:after{\r\n  content: \'\';\r\n  display: block;\r\n  background: -moz-element(#moz-reflect) no-repeat;\r\n  transform: scaleY(-1);\r\n}*/\r\n/* 进一步验证*/\r\n```\r\n![底部倒影](amWiki/images/reflex-img.png)\r\n> 用于遮罩的图片必须是png\r\n","timestamp":1585877701769},{"name":"06-css3颜色和渐变.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/06-css3颜色和渐变.md","content":"# CSS3颜色和渐变\r\n> CSS3过渡就是在某个元素的状态或样式发生变化的时候，你可以给他指定在变化过程中的方式，比方说变化的时间，变化的速度，变化的运动方式，变化的属性等等，可以是我们很轻松的完成动画效果，不用再借助于js的复杂的算法。<br/>\r\n> 在CSS3中对颜色进行了很多扩展，我们不仅可以使用在css2中的rgb模式，十六进制模式，以及关键字模式，同时还支持RGBA模式，HSL 模式和HSLA模式，以及我们可以使用css3实现渐变色\r\n\r\n## 颜色的兼容性 \r\n![jianrong](amWiki/images/rgba.png);\r\n\r\n## RGBA模式\r\n> RGBA在RGB的基础上多了控制alpha透明度的参数。以上R、G、B三个参数，正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限。并非所有浏览器都支持使用百分数值。A参数代表透明度，取值在0~1之间，不可为负值。\r\n\r\n> 注意：如果想让背景实现全透明，可以使用，background:transparent\r\n\r\n```css\r\nbackground-color:rgba(192,192,192,0.5),\r\n\r\n```\r\n\r\n## HSL 模式和HSLA模式\r\n> HSL色彩模式是工业界的一种颜色标准，是通过对色调(H)、饱和度(S)、亮度(L)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，HSL即是代表色调，饱和度，亮度三个通道的颜色\r\n\r\n### 取值说明：\r\n* Hue(色调)，取值范围为：（0-360，） 0(或360)表示红色，120表示绿色，240表示蓝色，当然可取其他数值来确定其它颜色；\r\n* Saturation （饱和度）的值形式为百分比（0%：gray ，100%：full color）；\r\n* Lightness （亮度）值形式也为为百分比（0%：black，100%：white）；\r\n* Alpha（透明度）的取值（0 -1）\r\n\r\n```css\r\nbackground-color:hsl(120,65%,75%);\r\nbackground-color:hsla(120,65%,75%,0.3)\r\n```\r\n\r\n\r\n## 透明度\r\n> 用来定义元素的透明度，取值范围（0 - 1）IE取值范围 (0-100)\r\n\r\n> 注意：会用透明度，会使该元素下的所有元素都拥有透明属性。\r\n\r\n```css\r\n opacity:0.5，\r\n filter:Alpha(opacity=50)      适用于IE   运用IE所特有的滤镜\r\n```\r\n\r\n\r\n## 渐变\r\n> CSS3 渐变（gradients）可以让你在两个或多个指定的颜色之间显示平稳的过渡。 以前，你必须使用图像来实现这些效果，现在通过使用 CSS3 的渐变（gradients）即可实现。此外，渐变效果的元素在放大时看起来效果更好，因为渐变（gradient）是由浏览器生成的。\r\n\r\n### 渐变兼容性\r\n![jianrong](amWiki/images/gradients.png);\r\n\r\n\r\n### 渐变的类型\r\n* 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向\r\n* 径向渐变（Radial Gradients）- 由它们的中心定义\r\n\r\n\r\n### CSS3 线性渐变\r\n> 语法： background: linear-gradient(direction, color-stop1, color-stop2, ...);\r\n\r\n> linear-gradient:线性渐变 ;\r\n\r\n> direction:渐变的方向;\r\n\r\n> color-stop1:颜色，颜色截止；\r\n\r\n\r\n### 线性渐变实例\r\n* 简单渐变\r\n```css\r\n#box{\r\n  background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */\r\n  background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */\r\n  background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */\r\n  background: linear-gradient(red, blue); /* 标准的语法 */\r\n}\r\n```\r\n\r\n* 简单方向渐变\r\n```css\r\n#box {\r\n  background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */\r\n  background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */\r\n  background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */\r\n  background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */\r\n}\r\n```\r\n\r\n* 使用角度\r\n```css\r\n#box {\r\n  background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */\r\n  background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */\r\n  background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */\r\n  background: linear-gradient(180deg, red, blue); /* 标准的语法 */\r\n}\r\n```\r\n\r\n* 使用透明度\r\n```css\r\n#box {\r\n  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */\r\n  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/\r\n  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/\r\n  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */\r\n}\r\n```\r\n* 重复的渐变\r\n```css\r\n#box {\r\n  /* Safari 5.1 - 6.0 */\r\n  background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%);\r\n  /* Opera 11.1 - 12.0 */\r\n  background: -o-repeating-linear-gradient(red, yellow 10%, green 20%);\r\n  /* Firefox 3.6 - 15 */\r\n  background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%);\r\n  /* 标准的语法 */\r\n  background: repeating-linear-gradient(red, yellow 10%, green 20%);\r\n}\r\n```\r\n\r\n### CSS3 径向渐变\r\n> background: radial-gradient(center, shape size, start-color, ..., last-color);\r\n\r\n> 径向渐变由它的中心定义。为了创建一个径向渐变，您也必须至少定义两种颜色结点。颜色结点即您想要呈现平稳过渡的颜色。同时，您也可以指定渐变的中心、形状（原型或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。\r\n\r\n> radial-gradient:线性渐变 ;\r\n\r\n> center:渐变的中心点;\r\n\r\n> color-stop1:颜色/颜色截止；\r\n\r\n### 径向渐变实例\r\n\r\n* 简单实例\r\n```css\r\n#box {\r\n  background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */\r\n  background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */\r\n  background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */\r\n  background: radial-gradient(red, green, blue); /* 标准的语法 */\r\n}\r\n```\r\n\r\n* 不均匀的渐变\r\n```css\r\n#box {\r\n  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */\r\n  background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */\r\n  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */\r\n  background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */\r\n}\r\n```\r\n\r\n* 形状渐变\r\n> 语法：shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse\r\n\r\n  ```css\r\n  #box{\r\n    background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */\r\n    background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */\r\n    background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */\r\n    background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */\r\n  }\r\n  ```\r\n\r\n\r\n\r\n* 重复的径向渐变\r\n```css\r\n#box {\r\n  /* Safari 5.1 - 6.0 */\r\n  background: -webkit-repeating-radial-gradient(red, yellow 10%, green 15%);\r\n  /* Opera 11.6 - 12.0 */\r\n  background: -o-repeating-radial-gradient(red, yellow 10%, green 15%);\r\n  /* Firefox 3.6 - 15 */\r\n  background: -moz-repeating-radial-gradient(red, yellow 10%, green 15%);\r\n  /* 标准的语法 */\r\n  background: repeating-radial-gradient(red, yellow 10%, green 15%);\r\n}\r\n```\r\n\r\n\r\n## IE浏览器渐变\r\n>  filter: progid:DXImageTransform.Microsoft.Gradient(enabled=bEnabled, startColorStr=iWidth, endColorStr=iWidth);\r\n\r\n> enabled,滤镜是否激活，startColorStr，开始颜色和透明度，endColorStr，结束颜色和透明度。\r\n\r\n> filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0, startColorStr=#9999ff, endColorStr=#fff)\r\n\r\n```css\r\nfilter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0, startColorStr=#9999ff, endColorStr=#fff);\r\n```\r\n","timestamp":1585877701769},{"name":"07-css3用户界面.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/07-css3用户界面.md","content":"# css3用户界面\r\n> 我们使用css3的新属性，可以自由的控制页面当中某个元素的大小，可以设置外边框以突出重点，可以轻松的实现报纸版面的排列效果(多列)，可以重定义盒子模型的呈现形式\r\n\r\n\r\n## css3多列\r\n> 通过 CSS3，能够创建多个列来对文本进行布局 - 就像报纸那样\r\n\r\n### 多列兼容性 \r\n![jianrong](amWiki/images/column.png);\r\n\r\n### 属性\r\n```css\r\n column-rule:5px solid #000;  /*间距填充，不影响每列宽度*/\r\n column-fill: auto;  /*或者是balance */\r\n```\r\n| 属性 | 描述 | CSS |\r\n|: --- | :--- | :--- |\r\n| column-count | 规定元素应该被分隔的列数。 | 3 |\r\n| column-gap | 规定列之间的间隔。默认是1em | 3 |\r\n| column-rule | 设置所有 `column-rule-\\*` 属性的简写属性。 | 3 |\r\n| column-width | 规定列的最小宽度。 | 3 |\r\n\r\n```css\r\n.font{\r\n\t\t\twidth:300px;\r\n\t\t\theight:300px;\r\n\t\t\tborder:1px solid #000;\r\n\t\t\tmargin:0px auto;\r\n\t\t\tcolumn-count:3;  // 定义数量\r\n\t\t\tcolumn-width:1em;   // 定义每列的最小的宽度\r\n\t\t\tcolumn-rule: 1px dotted red;  // 定义间距填充的样式，不占位置\r\n\t\t\tcolumn-gap: 0em;  // 定义每一列的间距\r\n\t\t\tcolumn-fill: auto;\t// 定义是否是平衡每一列的显示高度\r\n\t\t\toverflow: hidden;\r\n\t\t}\r\n```\r\n\r\n\r\n## resize\r\n> resize 属性规定是否可由用户调整元素的尺寸。\r\n\r\n### 属性\r\n```css\r\nresize: none|both|horizontal|vertical;\r\n```\r\n| 值 | 描述 |\r\n| :--- | :--- |\r\n| none | 用户无法调整元素的尺寸。 |\r\n| both | 用户可调整元素的高度和宽度。 |\r\n| horizontal | 用户可调整元素的宽度。 |\r\n| vertical | 用户可调整元素的高度。 |\r\n\r\n## box-sizing\r\n> `box-sizing `属性允许您以特定的方式定义匹配某个区域的特定元素\r\n\r\n### 盒子模型兼容性\r\n![jianrong](amWiki/images/box-sizing.png);\r\n\r\n### 属性\r\n```css\r\n\tbox-sizing: content-box|border-box|inherit;\r\n```\r\n\r\n| 值 | 描述 |\r\n| :--- | :--- |\r\n| content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\r\n| border-box | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\r\n| inherit | 规定应从父元素继承 box-sizing 属性的值。 |\r\n\r\n## outline\r\n> outline （轮廓）是给元素周围绘制轮廓外边框，通过设置一个数值使边框边缘的外围偏移，可起到突出元素的作用\r\n\r\n### 轮廓兼容性\r\n![jianrong](amWiki/images/outline.png);\r\n\r\n### 属性\r\n```css\r\n\toutline：[outline-color] || [outline-style] || [outline-width] || [outline-offset] | inherit\r\n```\r\n\r\n| 属性值 | 描述     |\r\n| :------------- | :------------- |\r\n| outline-color     | 指定轮廓边框颜色。      |\r\n| outline-style   | 指定轮廓边框轮廓。      |\r\n| outline-width    | 指定轮廓边框宽度      |\r\n| outline-offset  | 指定轮廓边框偏移位置的数值,并在边框边缘进行绘制。轮廓不占用空间   |\r\n\r\n## outline-offset\r\n> outline-offset 属性对轮廓进行偏移，并在边框边缘进行绘制。轮廓不占用空间\r\n\r\n\r\n### 属性\r\n```css\r\noutline-offset: length|inherit;\r\n```\r\n| 属性 | 描述     |\r\n| :------------- | :------------- |\r\n| length        | 轮廓与边框边缘的距离。   |\r\n| inherit      |\t规定应从父元素继承 outline-offset 属性的值。   |\r\n","timestamp":1585877701769},{"name":"08-css3文本模型.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/08-css3文本模型.md","content":"# css3文本(text)模型\r\n> 我们可以使用css3的新特性，给文本添加阴影，指定换行模式，规定文本的轮廓等一些效果，极大的弥补了css2当中的不足\r\n\r\n## 属性模型\r\n| **属性** | **描述** | **CSS** |\r\n| :--- | :--- | :--- |\r\n| text-overflow | 规定当文本溢出包含元素时发生的事情。 | 3 |\r\n| text-fill-color | 给文字指定填充颜色 | 3  |\r\n| text-stroke | 给文字描边 |   3|\r\n| text-stroke-width | 给文字描边的宽度 |  3 |\r\n| text-stroke-color | 给文字描边的颜色 |  3 |\r\n| text-shadow | 向文本添加阴影。 | 3 |\r\n| word-break | 规定非中日韩文本的换行规则。 | 3 |\r\n| word-wrap | 允许对长的不可分割的单词进行分割并换行到下一行。 | 3 |\r\n\r\n\r\n### text-overflow\r\n> 规定当文本溢出包含元素时发生的事情。\r\n\r\n```css\r\n text-overflow:clip/ellipsis/string;\r\n```\r\n\r\n| 值 | 描述 |\r\n| :--- | :--- |\r\n| clip | 修剪文本。 |\r\n| ellipsis | 显示省略符号来代表被修剪的文本。 |\r\n| string | 使用给定的字符串来代表被修剪的文本。 |\r\n\r\n\r\n### text-shadow阴影\r\n> 向文本添加阴影。\r\n\r\n```css\r\ntext-shadow: h-shadow v-shadow blur color;\r\n```\r\n\r\n| 值 | 描述 |\r\n| :--- | :--- |\r\n| h-shadow | 必需。水平阴影的位置。允许负值。 |\r\n| v-shadow | 必需。垂直阴影的位置。允许负值。 |\r\n| blur | 可选。模糊的距离。 |\r\n| color | 可选。阴影的颜色。参阅 CSS 颜色值。 |\r\n\r\n### word-break\r\n> 规定非中日韩文本的换行规则\r\n\r\n```css\r\nword-break: normal|break-all|keep-all;\r\n\r\n```\r\n| 值| 描述 |\r\n|:--- | :--- |\r\n| normal | 使用浏览器默认的换行规则。 |\r\n| break-all | 允许在单词内换行。 |\r\n| keep-all | 只能在半角空格或连字符处换行。 |\r\n\r\n### word-warp\r\n> 允许对长的不可分割的单词进行分割并换行到下一行。\r\n\r\n```css\r\n word-wrap: normal|break-word;\r\n```\r\n\r\n| 值 | 描述 |\r\n| :--- | :--- |\r\n| normal | 只在允许的断字点换行（浏览器保持默认处理）。 |\r\n| break-word | 在长单词或 URL 地址内部进行换行。 |\r\n\r\n\r\n## 文本\r\n> 在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。通过 CSS3，web 设计师可以使用他们喜欢的任意字体。可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。你“自己的”的字体是在 CSS3 `@font-face` 规则中定义的。\r\n\r\n### 浏览器支持\r\n\r\n* Firefox、Chrome、Safari 以及 Opera 支持`.ttf `(True Type Fonts) 和 `.otf `(OpenType Fonts) 类型的字体。\r\n* Internet Explorer 9+ 支持新的` · `规则，但是仅支持 `.eot` 类型的字体 (Embedded OpenType)\r\n\r\n\r\n### 文字属性\r\n| 属性| 值 | 描述 |\r\n| --- | --- | --- |\r\n| font-family | name | 必需。规定字体的名称。 |\r\n| src | URL | 必需。定义字体文件的 URL。 |\r\n| font-stretch | normal `condensedultra-condensed `   `extra-condensedsemi-condensed` `expanded   ` `semi-expanded  `  `  extra-expandedultra-expanded` | 可选。定义如何拉伸字体。默认是 &quot;normal&quot;。 |\r\n| font-style |   normal   italic  oblique | 可选。定义字体的样式。默认是 &quot;normal&quot;。 |\r\n| font-weight | normal  bold   100~900 | 可选。定义字体的粗细。默认是 &quot;normal&quot;。 |\r\n\r\n#### 单行文字超出显示省略号\r\n> 要求容器要有宽度\r\n```css\r\n.hidden_one{\r\n\toverflow:hidden;\r\n\ttext-overflow:ellipsis;\r\n\twhite-space:nowrap; \r\n}\r\n```\r\n#### 多行文字超出显示省略号 \r\n> 要求容器不能固定高度 \r\n```css\r\n.hidd_more{\r\n\tdisplay: -webkit-box;\r\n\t-webkit-box-orient: vertical;\r\n\t-webkit-line-clamp: 3;     /* 固定显示3行*/\r\n\toverflow: hidden;\r\n}\r\n```\r\n\r\n\r\n### font-face兼容性\r\n![文字属性](amWiki/images/font-face.png)\r\n\r\n### 字体属性格式\r\n\r\n```css\r\n@font-face\r\n{\r\nfont-family: myFirstFont;\r\nsrc: url(\'Sansation_Light.ttf\'),\r\n     url(\'Sansation_Light.eot\'); /* IE9+ */\r\nfont-weight:bold;\r\n}\r\n\r\ndiv\r\n{\r\nfont-family:myFirstFont;\r\n}\r\n\r\n```\r\n","timestamp":1585877701769},{"name":"09-css3 2D转换.md","path":"001-前端/07-HTML & CSS/003-Web基础/02-CSS3/09-css3 2D转换.md","content":"# css3`＜2D 转换＞`\r\n> 通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸。\r\n\r\n## 2D兼容性\r\n![2d兼容](amWiki/images/2d.png)\r\n\r\n## css3`＜2D 转换＞`属性 \r\n| **属性** | **描述** | **CSS** |\r\n|: --- |: --- |: --- |\r\n| transform | 主流浏览器都支持此属性 | 3 |\r\n| transform-origin | 可能的值：Left center right length  % | 3 |\r\n\r\n\r\n## css3`＜2D 转换＞`函数(transform-functions-2d)\r\n| **函数** | **描述** |\r\n|: --- |: --- |\r\n| matrix(n,n,n,n,n,n) | 定义 2D 转换，使用六个值的矩阵。 |\r\n| translate(x,y) | 定义 2D 转换，沿着 X 和 Y 轴移动元素。 |\r\n| translateX(n) | 定义 2D 转换，沿着 X 轴移动元素。 |\r\n| translateY(n) | 定义 2D 转换，沿着 Y 轴移动元素。 |\r\n| scale(x,y) | 定义 2D 缩放转换，改变元素的宽度和高度。 |\r\n| scaleX(n) | 定义 2D 缩放转换，改变元素的宽度。 |\r\n| scaleY(n) | 定义 2D 缩放转换，改变元素的高度。 |\r\n| rotate(angle) | 定义 2D 旋转，在参数中规定角度。deg 角度  rad 弧度 |\r\n| skew(x-angle,y-angle) | 定义 2D 倾斜转换，沿着 X 和 Y 轴。 |\r\n| skewX(angle) | 定义 2D 倾斜转换，沿着 X 轴。 |\r\n| skewY(angle) | 定义 2D 倾斜转换，沿着 Y 轴。 |\r\n\r\n* 书写规则\r\n  ```css\r\n   div{\r\n     transform: rotate() scale() skew() translate();\r\n   }\r\n  // 注意：在写transform的时候，防止覆盖！！\r\n  ```\r\n\r\n* 旋转示例\r\n  ```css\r\n  div\r\n  {\r\n    transform: rotateX(30deg);\r\n    transition-origin:left top;\r\n  }\r\n  ```\r\n\r\n* 平移示例\r\n  ```css\r\n  div\r\n  {\r\n  transform: translate(50px,100px);\r\n  }\r\n  ```\r\n\r\n* 缩放示例\r\n  ```css\r\n  div\r\n  {\r\n  transform: scale(2,4);\r\n  }\r\n  ```\r\n\r\n* 斜切示例\r\n  ```css\r\n  div\r\n  {\r\n  transform: skew(30deg,20deg);\r\n  }\r\n  ```\r\n","timestamp":1585877701769},{"name":"01-html、css规范.md","path":"001-前端/07-HTML & CSS/003-Web基础/03-开发标准/01-html、css规范.md","content":"## 文件命名规范\r\n>文件名称统一用英文字母、数字和下划线的组合，其中不得包含汉字、空格和特殊字符\r\n\r\n命名原则的指导思想：\r\n1. 使得你自己和工作组的每一个成员能够方便的理解每一个文件的意义，\r\n2. 当我们在文件夹中使用“按名称排例”的命令时，同一种大类的文件能够排列在一起，以便我们查找、修改、替换、计算负载量等等操作\r\n\r\n* HTML 的命名原则\r\n    1. 引文件统一使用 index.htm index.html index.asp 文件名（小写）\r\n    2. 各子页命名的原则首先应该以栏目名的英语翻译取单一单词为名称。例如：  \r\n          关于我们 \\ aboutus    \r\n          信息反馈 \\ feedback       \r\n          产 品 \\ product    \r\n          如果栏目名称多而复杂并不好以英文单词命名，则统一使用该栏目名称拼音或拼音的首字母表示；\r\n\r\n* 图片的命名规范\r\n图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质\r\n    * 放置在页面顶部的广告、装饰图案等长方形的图片取名： banner\r\n    * 标志性的图片取名为： logo\r\n    * 在页面上位置不固定并且带有链接的小图片我们取名为 button\r\n    * 在页面上某一个位置连续出现，性质相同的链接栏目的图片我们取名： menu\r\n    * 装饰用的照片我们取名： pic\r\n    * 不带链接表示标题的图片我们取名： title\r\n```\r\n比如：banner_sohu.gif  banner_sina.gif  menu_aboutus.gif  menu_job.gif  title_news.gif\r\nlogo_police.gif  logo_national.gif  pic_people.jpg\r\n```\r\n\r\n\r\n\r\n\r\n## 代码规范\r\n### html编码规范\r\n1. head 区是指 html 代码的<head>和</head>之间的内容。\r\n  * 必须加入的标签\r\n      * 公司版权注释 <!--- the site is designed by ehm,inc 07/2005 --->\r\n      * 网页显示字符集\r\n            * 中文：`<meta charset=utf-8\">`\r\n      * 网页制作者信息 `<meta name=\"author\" content=\"webmaster@maketown.com\">`\r\n      * 网站简介 `<meta name=\"description\" content=\"xxxxxxxxxxxxxxxxxxxxxxxxxx\">`\r\n      * 搜索关键字 `<meta name=\"keywords\" content=\"xxxx,xxxx,xxx,xxxxx,xxxx,\">`\r\n      * 网页标题 `<title>xxxxxxxxxxxxxxxxxx</title>`\r\n  * 可以选择加入的标签\r\n      * 设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅。\r\n      ```\r\n      <meta http-equiv=\"expires\" content=\"wed, 26 feb 1997 08：21：57 gmt\">\r\n      ```\r\n      * 禁止浏览器从本地机的缓存中调阅页面内容。\r\n      ```\r\n      <meta http-equiv=\"pragma\" content=\"no-cache\">\r\n      ```\r\n      * 用来防止别人在框架里调用你的页面。\r\n      ```\r\n      <meta http-equiv=\"window-target\" content=\"_top\">\r\n      ```\r\n      * 自动跳转。\r\n      ```\r\n      <meta http-equiv=\"refresh\" content=\"5;url=http：//www.yahoo.com\">\r\n      ```\r\n      5 指时间停留 5 秒\r\n      * 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。\r\n      ```\r\n      <meta name=\"robots\" content=\"none\">\r\n      ```\r\n        content 的参数有 all,none,index,noindex,follow,nofollow。默认是 all。\r\n      * 收藏夹图标\r\n      ```\r\n      <link rel = \"shortcut icon\" href=\"favicon.ico\">\r\n      ```\r\n      * 所有的 javascript 的调用尽量采取外部调用.\r\n      ```\r\n      <script language=\"javascript\" src=\"script/xxxxx.js\"></script>\r\n      ```\r\n      * 附<body>标签：\r\n      ```\r\n      <body>标签不属于 head 区，这里强调一下，为了保证浏览器的兼容性，必须设置页面背景<body\r\n      bgcolor=\"#ffffff\">\r\n      ```\r\n2. 字体要求和设置\r\n    * 通用字体设置： `font-family: \"Helvetica Neue\",Helvetica,\"PingFang SC\",\"Hiragino Sans GB\",\"Microsoft YaHei\",\"微软雅黑\",Arial,sans-serif;`\r\n    * PC端字体要求：\r\n        * Windows 使用 `微软雅黑` 字体\r\n        * Mac 使用`苹方` 字体\r\n    * 移动端字体要求\r\n        * ios 默认中文字体是Heiti SC、英文字体是Helvetica\r\n        * android 默认中文字体是Droidsansfallback、英文和数字字体是Droid Sans\r\n        * 各个手机系统有自己的默认字体，且都不支持微软雅黑\r\n        * 如无特殊需求，手机端无需定义中文字体，使用系统默认\r\n        * 英文字体和数字字体可使用 Helvetica ，三种系统都支持\r\n\r\n    * 推荐参考字体\r\n        * pc端： “Microsoft Yahei”,”微软雅黑”,”宋体”,Tahoma,Arial,Helvetica,STHeiti\r\n        * 手机端：Arial,Helvetica,sans-serif\r\n\r\n\r\n\r\n### css 书写规范  \r\n\r\n[清除默认样式点击使用](https://github.com/allcky/u-reset.css/blob/master/u-reset.css)\r\n\r\n1. 协作开发及分工: 项目搭建者会根据各个模块,同时根据页面相似程序,事先写好大体框架文件,分配给前端人员实现内部结构&表现&行为;\r\n2. 共用css文件(清除默认样式等)由项目搭建者提供,协作开发过程中,每个页面请务必都要引入,此文件包含 reset 及头部底部样式, 此文件不可随意修改;\r\n2. class与id 的使用: id 是唯一的,class 是可以重复的,所以id仅使用在大的模块上,class可用在重复使用率高的地方; id原则上都是由项目搭建者分发框架文件时命名的;\r\n4. class 与 id 命名:大的框架命名比如 header/footer/wrapper/left/right 之类的由项目搭建者统一命名,避免使用中文拼音,尽量使用简易的单词组合; 总之, 命名要语义化, 简明化.\r\n\r\n5. 规避 class 与 id 命名:重复使用率高的命名, 请以自己代号加下划线起始, 比如 bao_clear;\r\n\r\n6. css 属性书写顺序, 建议遵循 布局定位属性-->自身属性-->文本属性-->其他属性. (尽量保证同类属性写在一起.)\r\n>属性列举: 布局定位属性主要包括: margin、padding、float（包括clear）、position（相应的top,right,bottom,left）、display、visibility、overflow 等；自身属性主要包括: width& height & background & border; 文本属性主要包括：font、color、text-align、text-decoration、text-indent等；其他属性包括: list-style(列表样式)、vertical-vlign、cursor、z-index(层叠顺序) 、zoom 等.所列出的这些属性只是最常用到的.\r\n\r\n7. 书写样式代码前, 考虑并提高样式重复使用率;\r\n\r\n8. 充分利用 html 自身属性及样式继承原理减少代码量\r\n\r\n9. 样式表中中文字体名, 请务必转码成 unicode 码, 以避免编码错误时乱码;\r\n10. 背景图片请尽可能使用 sprite 技术, 减小 http 请求, 考虑到多人协作开发, sprite 按模块制作;\r\n11. 使用 table 标签时(尽量避免使用 table 标签), 请不要用 width/height/cellspacing/cellpadding 等 table属性直接定义表现 , 应尽可能的利用 table 自身私有属性分离结构与表现 ,如thead,tr,th,td,tbody,tfoot,colgroup,scope;(cellspaing 及 cellpadding 的 css 控制方法 :table{border:0;margin:0;border-collapse:collapse;} table th, table td{padding:0;} , base.css 文件中我会初始化表格样式)\r\n15. 减少使用影响性能的属性, 比如 position:absolute || float ;\r\n16. 必须为大区块样式添加注释, 小区块适量注释;\r\n\r\n#### 常用类名和id的命名\r\n\r\n| 命名部分                 | 命名     | 命名部分 | 命名              |\r\n| ------------------------ | -------- | -------- | ----------------- |\r\n| 头                       | header   | 内容     | content/container |\r\n| 尾                       | footer   | 导航     | nav               |\r\n| 侧栏                     | sidebar  | 栏目     | column            |\r\n| 页面外围控制整体布局宽度 | wrapper  | 左右中   | left right center |\r\n| 登陆条                   | loginbar | 标志     | logo              |\r\n| 广告                     | banner   | 页面主体 | main              |\r\n| 热点                     | hot      | 新闻     | news              |\r\n| 下载                     | download | 子导航   | subnav            |\r\n| 菜单                     | menu     | 子菜单   | submenu           |\r\n| 搜索                     | search   | 友情链接 | friendlink        |\r\n| 页脚                     | footer   | 版权     | copyright         |\r\n| 滚动                     | scroll   | 内容     | content           |\r\n| 标签页                   | tab      | 文章列表 | list              |\r\n| 提示信息                 | msg      | 小技巧   | tips              |\r\n| 栏目标题                 | title    | 加入     | joinus            |\r\n| 指南                     | guild    | 服务     | service           |\r\n| 注册                     | regsiter | 状态     | status            |\r\n| 投票                     | vote     | 合作伙伴 | partner           |\r\n\r\n### 图片规范\r\n\r\n1. 所有页面元素类图片均放入 img 文件夹, 测试用图片放于 img/demoimg 文件夹;\r\n3. 命名全部用英文字母 || 数字 || _ 的组合，其中不得包含汉字 || 空格 || 特殊字符；尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如 ad_left01.gif || btn_submit.gif;\r\n4. 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间,使用的图片一定要经过压缩处理;\r\n5. 尽量避免使用半透明的 png 图片(若使用, 请参考 css 规范相关说明);\r\n6. 运用 css sprite 技术集中小的背景图或图标, 减小页面 http 请求, 但注意, 请务必在对应的 sprite psd 源图中划参考线, 并保存至 img 目录下.\r\n\r\n### 注释规范 （给一部分内容做注释处理的时候，开始和结束都要有）\r\n\r\n1. html 注释: 注释格式 `<!--这儿是注释-->`;\r\n2. css 注释: 注释格式 `/*这儿是注释*/`;\r\n     * 文件头部需要写清楚文件的用途、作者、创建日期、版本（可选）\r\n3. 注释需要表述清楚，表明代码块的总用区域、功能。\r\n","timestamp":1585877701769},{"name":"02-协同开发.md","path":"001-前端/07-HTML & CSS/003-Web基础/03-开发标准/02-协同开发.md","content":"## 前端协同开发\r\n\r\n开发较大型项目往往需要多名程序员协同开发。为了便于管理、修改，协同开发时多人会操作同一份代码，而不是各自为营。所以会制定一些开发标准、使用协同开发工具等：\r\n\r\n\r\n### 开发标准\r\n前端与前端协作提升开发效率的一个很重要的方法就是减少沟通：能够形成纸质的文档就不要口头沟通\r\n特别是线上协作的时候，面对面交流是很困难的。\r\n\r\n* 前端与前端文档要求：\r\n    1. 规定项目结构、命名规范、注释规则、文件保存规则等  (防止文件冲突)\r\n    2. 规定所用技术：使用的插件或库、兼容范围等\r\n    3. 成员任务分配\r\n\r\n* 前端与后端接口文档要求：\r\n    1. 格式简洁清晰：推荐用 API Blueprint(https://apiblueprint.org/)\r\n    2. 分组：当接口很多的时候，分组就很必要了\r\n    3. 接口名、接口描述、接口地址\r\n    4. http 方法、参数、headers、是否序列化\r\n    5. http 状态码、响应数据\r\n\r\n### 协同开发工具\r\n由于协同开发需要多人维护一份代码，所以往往会将代码保存在云端来使用，使用Github、Coding、码云等代码托管网站都能实现这一需求。\r\n\r\nGithub使用方法相见“附录 - Git与Github使用指南”章； Coding使用方法相见“附录 - Coding使用指南”章\r\n\r\n\r\n\r\n## 协同开发流程\r\n### 1. 项目启动会\r\n建立项目小组，通过项目启动会说明项目目标、阶段划分、人员安排、管理流程等关键事项，并将这些内容写入开发文档\r\n\r\n* 需要提前规定的内容包含： \r\n    1. 网站功能分析、页面划分、共有部分提取\r\n    2. 项目负责人选取、人员任务分配(精确到每个页面)\r\n    3. 选定所用技术栈：开发语言、库、框架、插件等，规定兼容范围\r\n    5. 项目负责人编写开发文档，文档中包含上述记录\r\n\r\n### 2. 协同开发\r\n使用版本控制工具(例如Git、svn)进行协同开发，方便代码管理； 并可借助代码托管平台(如Github、Coding)进行项目托管，便于下载上传维护。\r\n\r\n项目负责人需提前创建项目目录结构，并添加公有文件 (例如重置样式文件、字体文件、栅格等)，成员统一使用该结构进行代码编写。\r\n\r\n> 版本控制工具git、svn以及代码托管平台Github、Coding的使用见 `附录` 一章\r\n\r\n项目目录结构常见如下：\r\n```\r\nimages ------------- 图片文件夹\r\n    zhangsan ------------- 每个成员的图片文件夹(防止图片冲突)\r\n    lisi \r\ncss ---------------- CSS文件夹\r\njs ----------------- js文件夹\r\nfont --------------- 字体文件夹\r\n\r\nindex.html --------- 各个页面 (放到外部方便跳转)\r\nlogin.html \r\nmain.html \r\n```\r\n> 注： 由于协同开发多人图片如果放到统一文件夹内很容易造成命名冲突，所以一般图片会特殊处理：\r\n> 1. 将图片添加个人名字前缀，如： `zs-logo.png  和  ls-logo.png`\r\n> 2. 每个成员建立个人图片文件夹  如： `zs/logo.png  和  ls/logo.png`\r\n\r\n\r\n### 3. 网站测试\r\n网站各页面完成后，将个页面完成连接，并进行测试：\r\n\r\n*. 兼容性测试\r\n\r\n详见 `全端高级 -> 兼容` 一节，保证在不同版本、不同设备、不同平台的浏览器均能正常显示。\r\n\r\n\r\n","timestamp":1585877701769},{"name":"04-HTML标签汇总.md","path":"001-前端/07-HTML & CSS/003-Web基础/04-HTML标签汇总.md","content":"# HTML标签汇总\r\n\r\n## 网页主体标签\r\n| 标签 | 功能 |\r\n| ---- | ---- |\r\n| `<html></html>` | 网页的最大标签，用来包裹所有的内容 |\r\n| `<head></head>` | 用于定义文档的头部 |\r\n| `<body></body>` | 页面所有的内容都在这里 |\r\n| `<title></title>` | 网页的标题 |\r\n| `<meta></meta>` | 提供有关页面的元信息 |\r\n| `<link></link>` | 定义文档与外部资源的关系，最常见的用途是链接样式表 |\r\n| `<script></script>` | 标签用于定义客户端脚本,元素既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件 |\r\n| `<style></style>` | 用于为 HTML 文档定义样式信息。 |\r\n\r\n## 文本文字标签\r\n| 标签 | 功能 | 效果 |\r\n| ---- | ---- | ---- |\r\n| `<p></p>` | 段落标签 | <p>第一段</p><p>第二段</p> |\r\n| `<pre></pre>` | 定义预格式化的文本 | <pre>空格     空格</pre>|\r\n| `<b></b>` | 文本加粗 | <b>b标签</b> |\r\n| `<i></i>` | 文本倾斜| <i>文本倾斜了</i> |\r\n| `<h1></h1>` | 一级标题标签 | <h1>一级标题标签</h1> |\r\n| h2-h6 | 二级到6级标题标签 | <h2>二级标题</h2><h6>六级标题</h6> |\r\n| `<span></span>` | 普通文本，用来选中文字 | <span>span标签</span> |\r\n| `<a href=\"\"></a>` | 超链接标签 | <a href=\"https://www.baidu.com/\">点击跳转到百度</a> |\r\n| `<br/>` | 让文本强制换行 | 阿斯顿<br/>asd |\r\n| `<hr/>` | 设置一条水平线分割线 | <hr/> |\r\n| `<time></time>` | 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的 | 我在 <time datetime=\"2008-02-14\">情人节</time> 有个约会。</p> |\r\n\r\n## 图片、音频、视频、画布、iframe\r\n| 标签 | 功能 |\r\n| ---- | ---- |\r\n| `<img/>` | 用于引入图片 |\r\n| `<video></video>` | 定义视频 |\r\n| `<audio></audio>` | 标签定义声音 |\r\n| `<canvas></canvas>` | 定义图形，必须使用脚本来绘制图形 |\r\n| `<iframe></iframe>` | iframe 元素会创建包含另外一个文档的区域 |\r\n\r\n## 区域标签\r\n| 标签 | 功能 |\r\n| ---- | ---- |\r\n| `<div></div>` | 划分一个区域 |\r\n| `<ul></ul>` | 定义无序列表 |\r\n| `<ol></ol>` | 定义有序列表 |\r\n| `<li></li>` | 定义列表项目 |\r\n| `<header></header>` | 页面主体上的头部 |\r\n| `<nav></nav>` | 页面的导航部分 |\r\n| `<main></main>` | 网页的主体内容 |\r\n| `<article></article>` | 表示一篇文章的主体内容 |\r\n| `<footer ></footer >` | 页面的底部（页脚）标出网站的一些相关信息 |\r\n| `<aside></aside>` | 用以表达注记、贴士、侧栏、摘要、插入的引 用等作为补充主体的内容 |\r\n| `<code></code>` | 表示一段代码块。 |\r\n| `<figure></figure>` | 标签规定独立的流内容 |\r\n| `<section></section>` |  用于区域的章节表述 |\r\n\r\n\r\n## 表单标签\r\n| 标签 | 功能 | 效果 |\r\n| ---- | ---- | ---- |\r\n| `<form></form>` | 包含表单元素的区域 |  |\r\n| `<input type=\"text\">` | 文本输入框 | <input type=\"text\"> |\r\n| `<input type=\"password\">` | 密码输入框 | <input type=\"password\"> |\r\n| `<input type=\"radio\"> ` | 单选框选项| <input type=\"radio\" name=\"sex\" value=\"women\">女<input type=\"radio\" name=\"sex\" value=\"man\">男 |\r\n| `<input type=\"checkbox\">` | 复选框 | <input type=\"checkbox\" name=\"vehicle\" value=\"Bike\">I have a bike <input type=\"checkbox\" name=\"vehicle\" value=\"Car\">I have a car |\r\n| `<input type=\"submit\">` | 提交按钮 | <input type=\"submit\" value=\"Submit\"> |\r\n| `<input type=\"email\"/>` | 输入email | <input type=\"email\" name=\"email\" autocomplete=\"off\"/> |\r\n| `<input type=\"hidden\"/>` | 隐藏文本框 | <input type=\"hidden\" name=\"hidden_data\" value=\"page1\"/> |\r\n| `<input type=\"file\"/>` | 文件域 | <input type=\"file\" name=\"picture\"/> |\r\n| `<input type=\"button\"/>` | 普通按钮 | <input type=\"button\" value=\"按钮\"/> |\r\n| `<input type=\"reset\"/>` | 重置按钮 | <input type=\"reset\" value=\"重置\"/> |\r\n| `select` `option` | 下拉列表 | <select  name=\"dd\"  ><option  value=\"值1\" selected>文字1<option><option  value=\"值2\">文字2<option></select>|\r\n| `<textarea name=\"\"></textarea>` | 多行文本输入框 | <textarea name=\"\">多行文本输入框</textarea> |\r\n| `<button></button>` | 按钮标签 | <button>这是一个按钮</button> |\r\n\r\n\r\n## 表格标签\r\n| 标签 | 功能 |\r\n| ---- | ---- |\r\n| `<tabel></tabel>` | 定义表格 |\r\n| `<tr></tr>` | 定义表格的行 |\r\n| `<td></td>` | 定义表格的列 |\r\n| `<th></th>` | 表格中的表头内容 |\r\n| `<caption></caption>` | 表格的标题 |\r\n| `<thead></thead>` | 表格的表头 |\r\n| `<tbody></tbody>` | 定义表格主体 |\r\n| `<tfoot></tfoot>` | 定义表格页脚 |\r\n>不管thead、tbody、tfoot的代码先后顺序如何，html显示时，始终是先显示thead，再显示tbody，最后显示tfoot。\r\n","timestamp":1585877701769},{"name":"01-css3响应式.md","path":"001-前端/07-HTML & CSS/004-全端布局/01-响应式开发/01-css3响应式.md","content":"# 响应式布局\r\n> 现在很流行的一个设计理念，随着移动互联网的盛行，为解决如今各式各样的浏览器分辨率以及不同移动设备的显示效果，设计师提出了响应式布局的设计方案。所谓的响应式布局，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。也就说一个页面可以在多个终端呈现出你想要的效果，能够兼容各个终端。\r\n\r\n## 优点：\r\n* 面对不同分辨率设备灵活性强\r\n* 能够快捷解决多设备显示适应问题\r\n* 根据不同的显示器调整设计最适合用户浏览习惯的页面\r\n\r\n## 缺点：\r\n* 兼容各种设备工作量大，效率低下\r\n* 代码累赘，会出现隐藏无用的元素，加载时间加长\r\n* 其实这是一种折衷性质的设计解决方案，多方面因素影响而达不到最佳效果\r\n* 因为要适应不同的设备，页面的结构可能会有所不同，会导致页面的辨识度不强\r\n\r\n## `@media`兼容性\r\n![查询](amWiki/images/mt.png)\r\n\r\n> ie8及以下不支持 `@media`\r\n\r\n`Respond.js`可帮助IE6-8兼容 \"min/max-width\" 媒体查询条件: [Respond.js](https://scottjehl.github.io/Respond/dest/respond.src.js)\r\n\r\n使用方法：在页面中所有css文件的引用位置之后引用Respond.js。而且Respond.js的引用得越早，用户看到页面闪烁的机会越小。\r\n\r\n\r\n## 利用CSS3-Media Query实现响应式布局\r\n* media query:\r\n> 通过不同的媒体类型和条件定义样式表规则。媒体查询让CSS可以更精确作用于不同的媒体类型和同一媒体的不同条件\r\n\r\n* 语法结构及用法:\r\n> `@media `设备名 only (选取条件) not (选取条件) and(设备选取条件)，设备二{sRules}\r\n\r\n* 在link中使用`@media`\r\n```html\r\n<link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-width: \t600px)\"href=\"link.css\"/>\r\n```\r\n  * screen：指的是一种媒体类型；\r\n  * and：被称为关键词，与其相似的还有not,only。可能的操作符\r\n  * max-width:600px这个就是属性值，媒体特性，也就是就是媒体条件。\r\n\r\n* 在样式表中内嵌 `@media`\r\n```css\r\n@media screen and (max-width: 600px) {\r\n  选择器 {\r\n        属性：属性值；\r\n        }\r\n  }\r\n```\r\n\r\n## 常见的媒体类型\r\n| 值 |\t描述|\r\n|:--------|:--------|\r\n| all \t|默认。适用于所有设备。|\r\n| print |\t打印预览模式/打印页。|\r\n| screen |\t计算机屏幕。|\r\n\r\n## 常见的操作符\r\n| 值 |\t描述|\r\n|:--------|:--------|\r\n| and \t|逻辑与，连接设备名与选择条件、选择条件1与选择条件2。|\r\n| not \t|排除某种设备|\r\n| only\t|限定某种设备类型|\r\n| , \t|设备列表|\r\n\r\n\r\n## 属性值\r\n| 媒体特性 |\t值 |\t可用媒体类型 |\t接受min/max| \t简介|\r\n|:--------|:----|:-------------|:-----------|:----|\r\n| width |\t`<length>` |\t视觉屏幕/触摸设备 |\tyes |\t定义输出设备中的页面可见区域宽度(单位一般为px)|\r\n| heigth |\t`<length>`| \t视觉屏幕/触摸设备 |\tyes |\t定义输出设备中的页面可见区域高度(单位一般为px)|\r\n| device-width| \t`<length>`| \t视觉屏幕/触摸设备 |\tyes| \t定义输出设备的屏幕可见宽度(单位一般为px)|\r\n| device-heigth| \t`<length>` |\t视觉屏幕/触摸设备 |\tyes |\t定义输出设备的屏幕可见高度(单位一般为px)|\r\n| orientation \t|portrait /landscape |\t位图介质类型 |\tno |\t定义’height’是否大于或等于’width’。值portrait代表是，landscape代表否即设，备手持方向：portait为横向，landscape为竖向|\r\n| aspect-ratio  |\t`<ratio>`\t| 位图介质类型 |\tyes |\t定义’width’与’height’的比率，即浏览器的长宽比|\r\n| device-aspect-ratio |\t`<ratio> `\t| 位图介质类型 |\tyes |\t定义’device-width’与’device-height’的比率，即设备屏幕长宽比。如常见的显示器比率：4/3， 16/9，16/10 |\r\n| color| \t`<integer> `|\t视觉媒体 |\tyes |\t定义每一组输出设备的彩色原件个数。如果不是彩色设备，则值等于0|\r\n| color-index |\t`<integer> `| 视觉媒体 |\tyes | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0|\r\n| monochrome |\t`<integer>` |\t视觉媒体 |\tyes| \t定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0|\r\n| resolution |\t`<resolution>` |\t位图介质类型 |\tyes |\t定义设备的分辨率。如：96dpi，300dpi，118dpcm|\r\n| scan |\tprogressive / interlace |\t电视类 \t| no |\t定义电视类设备的扫描工序， progressive逐行扫描，interlace隔行扫描|\r\n| grid|\t`<integer>` |\t栅格设备| \tno| \t用来查询输出设备是否使用栅格或点阵。只有1和0才是有效值，1代表是，0代表否|\r\n\r\n\r\n## 设备检测\r\n* Phone4\r\n```html\r\n <link rel=\"stylesheet\" media=\"only screen and (-webkit-min-device-pixel-ratio: 2)\" type=\"text/css\" href=\"iphone4.css\" />\r\n```\r\n\r\n* iPad\r\n```html\r\n<link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\" type=\"text/css\" />\r\n<link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"landscape.css\"  type=\"text/css\" />\r\n```\r\n\r\n* android\r\n```html\r\n/*240px的宽度*/\r\n<link rel=\"stylesheet\" media=\"only screen and (max-device-width:240px)\" href=\"android240.css\" type=\"text/css\" />\r\n/*360px的宽度*/\r\n<link rel=\"stylesheet\" media=\"only screen and (min-device-width:241px) and (max-device-width:360px)\" href=\"android360.css\" type=\"text/css\" />\r\n/*480px的宽度*/\r\n<link rel=\"stylesheet\" media=\"only screen and (min-device-width:361px) and (max-device-width:480px)\" href=\"android480.css\" type=\"text/css\" />\r\n```\r\n\r\n\r\n### 响应式阈值选取\r\n响应式的阈值即不同设备宽度的临界值，该值由当前市面上设备分辨率比例得出，详见[百度流量研究院](https://tongji.baidu.com/data/screen)：\r\n\r\n| 阈值 | 内宽 | 设备 | \t描述|\r\n|:--------|:--------|:--------|:--------|\r\n| <768px \t| auto | 手机 | 超小屏幕 |\r\n| ≥768px \t| 750px | 平板 | 小屏幕 |\r\n| ≥992px \t| 970px | 桌面显示器  | 中等屏幕 |\r\n| ≥1200px \t| 1170px | 大桌面显示器  | 大屏幕 |\r\n\r\n<iframe src=\"https://tongji.baidu.com/data/screen\" frameborder=\"0\" style=\"width: 100%; height:600px;\"></iframe>\r\n\r\n### 简单案例查看\r\n>简单案例请查看example文件下的响应式\r\n","timestamp":1585877701769},{"name":"02-12栅格布局.md","path":"001-前端/07-HTML & CSS/004-全端布局/01-响应式开发/02-12栅格布局.md","content":"# 栅格布局\r\n> Bootstrap 框架实现响应式的原理便是通过十二栅格布局来完成的，12栅格的原理十分简单，重要的是这种思想。通过定义容器大小，平分12份。再调整内外边距，最后结合媒体查询，就制作出了强大的响应式网格系统。Bootstrap框架中的网格系统就是将容器平分成12份。我们通过十二栅格的启发，自己可以实现15栅格，18栅格等等自己想要实现的栅格布局\r\n\r\n## 十二栅格中的一些概念\r\n\r\n* container: 包裹整个栅格系统的容器\r\n    * 在不同的宽度区间内（响应式断点）提供宽度限制。当宽度变化时，采用不同的宽度。\r\n    * 提供一个padding，阻止内部内容触碰到浏览器边界\r\n\r\n* rows: 行\r\n    * 行元素用于防止里面的列溢出到其他的行。通常会使用clearfix来清除浮动，因为我们是通过浮动所有的块元素来制作栅格系统的。\r\n* columns: 列\r\n    * 列元素是栅格系统的核心，也是最复杂的一部分。因为列的定位可以有很多实现方式，同时还需要考虑它的宽度以及响应式设计等因素。\r\n    * 列的位置\r\n    > 使用float属性将每个元素浮动，上面的行已经清除浮动\r\n\r\n    * 列的宽度\r\n    > 由于容器总宽度是100%，我们想要6列，所以每列宽度为：100% / 6 = 16.66%\r\n     把一行分成六列，通过简单的计算，还可以定义列的多种宽度。\r\n\r\n* gutters: 各列的间的空隙\r\n\r\n## 具体实现\r\n栅格用于通过一系列的行（row）与列（column）的组合来创建页面布局.\r\n\r\n类名 | 描述        \r\n------|-------------\r\n.col-xs-1 ~ .col-xs-12 | 手机设备(768 > screen )\r\n.col-sm-1 ~ .col-sm-12 | 平板设备(768 < screen < 970)\r\n.col-md-1 ~ .col-md-12 | PC小屏 (970 < screen < 1200)\r\n.col-lg-1 ~ .col-lg-12 | PC大屏 (1200 < screen )\r\n.col-xs-offset-1 ~ .col-xs-offset-12 | 手机设备列偏移\r\n.col-sm-offset-1 ~ .col-sm-offset-12 | 平板设备列偏移\r\n.col-md-offset-1 ~ .col-md-offset-12 | PC小屏列偏移\r\n.col-lg-offset-1 ~ .col-lg-offset-12 | PC大屏列偏移\r\n.col-xs-push-1 ~ .col-xs-push-12 | 手机设备列右偏移\r\n.col-sm-push-1 ~ .col-sm-push-12 | 平板设备列右偏移\r\n.col-md-push-1 ~ .col-md-push-12 | PC小屏列右偏移\r\n.col-lg-push-1 ~ .col-lg-push-12 | PC大屏列右偏移\r\n.col-xs-pull-1 ~ .col-xs-pull-12 | 手机设备列左偏移\r\n.col-sm-pull-1 ~ .col-sm-pull-12 | 平板设备列左偏移\r\n.col-md-pull-1 ~ .col-md-pull-12 | PC小屏列左偏移\r\n.col-lg-pull-1 ~ .col-lg-pull-12 | PC大屏列左偏移\r\n.hidden-xs | 手机设备隐藏指定列\r\n.hidden-sm | 平板设备隐藏指定列\r\n\r\n1. 十二栅格主要是通过将父元素的宽度等性的分成12栏，利用 `@media` 去给每一个元素在不同屏幕下设置为占据不同栏数宽度，例如，某个元素，在大屏是占整个父元素的3栏（一行有4个相同元素），在中屏占整个父元素的6栏（一行有2个相同元素），在小屏占整个父元素的12栏（独占一行）。\r\n2. 十二栅格中出了划分十二列之外，还有一些其他的功能，比如有的时候，我们不希望相邻的两个列紧靠在一起，但又不想使用margin或者其他的技术手段来。这个时候就可以使用列偏移（offset）功能来实现。使用列偏移也非常简单，只需要在列元素上添加类名`col-md-offset-*`(其中星号代表要偏移的列组合数)，那么具有这个类名的列就会向右偏移。实现原理非常简单，利用十二分之一（1/12）的margin-left。然后有多少个offset，就有多少个margin-left。\r\n3. 还有个比较重要的功能，列排序（pull 和 push）,形象的比喻成我们人用左手去推拉页面上的元素，它是通过定位，然后我们给他们添加left(push)和right(pull)这两个属性，然后作用到我们的元素，产生想要的页面效果。列排序其实就是改变列的方向，就是改变左右浮动，并且设置浮动的距离。在Bootstrap框架的网格系统中是通过添加类名`col-md-push-*`和`col-md-pull-*` (其中星号代表移动的列组合数)。\r\n\r\n## 案例查看\r\n>简单案例请查看example文件下的12栅格\r\n\r\n\r\n### 12栅格原理less源码\r\n```less\r\n@pad:15px;\r\n@colpad:15px;\r\n@cols:12;\r\n@sm-width:750px;\r\n@md-width:970px;\r\n@lg-width:1170px;\r\n\r\n.container{\r\n    // 固定宽度容器\r\n    &{\r\n        padding-left:@pad;\r\n        padding-right:@pad;\r\n        margin-left:auto;\r\n        margin-right: auto;\r\n        display: block;\r\n    }\r\n    // 100%宽度容器\r\n    &-fluid{\r\n        width: 100%;\r\n        padding-left:@pad;\r\n        padding-right:@pad;\r\n        display: block;\r\n    }\r\n    &:before,&:after,&-fluid:before,&-fluid:after{\r\n        dipsplay:table;\r\n        line-height: 0;\r\n        content: \'\';\r\n    }\r\n    &:after,&-fluid:after{\r\n        clear: both;\r\n    }\r\n    // 容器 行\r\n    & .row,&-fluid .row{\r\n        display: block;\r\n        overflow: hidden;\r\n        margin-right: -@pad;\r\n        margin-left: -@pad;\r\n    }\r\n}\r\n// 图片响应式\r\n.img-responsive{\r\n    max-width: 100%;\r\n    display: block;\r\n    height: auto;\r\n}\r\n/* 超小屏幕（手机，小于 768px） */\r\n@media screen and (max-width: 767px){\r\n    .hidden-xs{\r\n        display: none;\r\n    }\r\n}\r\n\r\n/* 小屏幕（平板，大于等于 768px） */\r\n@media screen and (min-width: 768px) and (max-width:991px){\r\n    .hidden-sm{\r\n        display: none;\r\n    }\r\n}\r\n\r\n/* 中等屏幕（桌面显示器，大于等于 992px） */\r\n@media screen and (min-width:992px) and (max-width: 1199px){\r\n    .hidden-md{\r\n        display: none;\r\n    }\r\n}\r\n\r\n/* 大屏幕（大桌面显示器，大于等于 1200px） */\r\n@media screen and (min-width: 1200px){\r\n    .hidden-lg{\r\n        display: none;\r\n    }\r\n}\r\n\r\n.response(@type,@i:1) when(@i< (@cols+1)){\r\n    .col-@{type}-@{i}{\r\n        width:@i*100%/@cols;\r\n    }\r\n    .col-@{type}-offset-@{i}{\r\n        margin-left:@i*100%/@cols;\r\n    }\r\n    .col-@{type}-pull-@{i}{\r\n        right:@i*100%/@cols;\r\n    }\r\n    .col-@{type}-push-@{i}{\r\n        left:@i*100%/@cols;\r\n    }\r\n    .response(@type,@i+1);\r\n}\r\n[class*=\"col-\"]{\r\n    float:left;\r\n    position:relative;\r\n    overflow:hidden;\r\n    padding-left:@colpad;\r\n    padding-right:@colpad;\r\n}\r\n/* 超小屏幕（手机，小于 768px） */\r\n.col-xs-offset-0{\r\n    margin-left: 0px;\r\n}\r\n.col-xs-pull-0{\r\n    right:0;\r\n}\r\n.col-xs-push-0{\r\n    left:0;\r\n}\r\n.response(xs);\r\n/*小屏幕 平板 (≥768px)*/\r\n@media screen and (min-width:768px){\r\n    img[data-md-src]{\r\n        content:attr(data-md-src,url);\r\n    }\r\n    .container{\r\n        width: @sm-width;\r\n    }\r\n    .col-sm-offset-0{\r\n        margin-left: 0px;\r\n    }\r\n    .col-sm-pull-0{\r\n        right:0;\r\n    }\r\n    .col-sm-push-0{\r\n        left:0;\r\n    }\r\n    .response(sm);\r\n}\r\n/*中等屏幕 桌面显示器 (≥992px)*/\r\n@media screen and (min-width:992px){\r\n    img[data-md-src]{\r\n        content:attr(data-md-src,url);\r\n    }\r\n    .container{\r\n        width: @md-width;\r\n    }\r\n    .col-md-offset-0{\r\n        margin-left: 0px;\r\n    }\r\n    .col-md-pull-0{\r\n        right:0;\r\n    }\r\n    .col-md-push-0{\r\n        left:0;\r\n    }\r\n    .response(md);\r\n}\r\n/* 大屏幕（大桌面显示器，大于等于 1200px） */\r\n@media screen and (min-width:1200px){\r\n    img[data-lg-src]{\r\n        content:attr(data-lg-src,url);\r\n    }\r\n    .container{\r\n        width: @lg-width;\r\n    }\r\n    .col-lg-offset-0{\r\n        margin-left: 0px;\r\n    }\r\n    .col-lg-pull-0{\r\n        right:0;\r\n    }\r\n    .col-lg-push-0{\r\n        left:0;\r\n    }\r\n    .response(lg);\r\n}\r\n```\r\n","timestamp":1585877701769},{"name":"01-app分类.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/01-app分类.md","content":"## APP的分类以及差异\r\n目前主流应用程序分为三类：Web App、Native App、Hybrid App\r\n\r\n### Web App\r\n\r\n>指利用html语言基于浏览器，开发的app，存放于服务器。在使用时不需要下载安装\r\n\r\n#### 优点\r\n\r\n  * 开发成本低\r\n  * 更新快\r\n  * 更新无需通知用户，不需要手动升级\r\n  * 能够跨多个平台和终端\r\n\r\n#### 缺点\r\n\r\n  * 临时性的入口\r\n  * 无法获取系统级别的通知，提醒，动效等等\r\n  * 用户留存率低\r\n  * 设计受限制诸多\r\n  * 体验较差\r\n\r\n### Native App\r\n\r\n>Native APP 指的是原生程序，一般依托于操作系统利用Object C(IOS) JAVA(android)开发的app，所有的页面存在本地，此类App有很强的交互，是一个完整的App，可拓展性强。需要用户下载安装使用。\r\n\r\n#### 优点\r\n\r\n  * 打造完美的用户体验\r\n  * 性能稳定\r\n  * 操作速度快，上手流畅\r\n  * 访问本地资源（通讯录，相册）\r\n  * 设计出色的动效，转场，\r\n  * 拥有系统级别的贴心通知或提醒\r\n  * 用户留存率高\r\n\r\n#### 缺点\r\n  * 分发成本高（不同平台有不同的开发语言和界面适配）\r\n  * 维护成本高（例如一款App已更新至V5版本，但仍有用户在使用V2， V3， V4版本，需要更多的开发人员维护之前的版本）\r\n  * 更新缓慢，根据不同平台，提交–审核–上线 等等不同的流程，需要经过的流程较复杂\r\n\r\n\r\n\r\n### Hybrid App\r\n  >Hybrid APP指的是半原生半Web的混合类App。需要下载安装，看上去类似Native App，但只有很少的UI WebView，访问的内容是 Web 。\r\n\r\n\r\n## Web App、Native App、Hybrid App 技术特征\r\n| | Web App | Native App | Hybrid App|\r\n|:---|:---|:---|:---|\r\n|**APP 特性**|\r\n| 图像渲染 | html、css、canvas | 本地渲染 | 混合 |\r\n| 性能 |  慢   | 快 |  慢  |\r\n| 原生界面 | 模仿 | 原生界面 | 模仿 |\r\n| 发布| Web| App store | App store |\r\n|**本机设备访问**|\r\n| 照相机 | 不支持 | 支持 | 支持 |\r\n| 系统通知 | 不支持 | 支持 | 支持 |\r\n| 定位 | 支持 | 支持 | 支持 |\r\n|**网络支持**|\r\n| 网络要求 | 大部分依赖网络 | 支持离线 | 大部分依赖网络 |\r\n\r\n## Web App受限因素\r\n相比Native App，Web App体验中受限于以上5个因素：网络环境，渲染性能，平台特性，受限于浏览器，系统限制\r\n\r\n### 网络环境，渲染性能\r\n* Web APP对网络环境的依赖性较大\r\n\r\n>因为Web APP中的H5页面，当用户使用时，去服务器请求显示页面。如果此时用户恰巧遇到网速慢，网络不稳定等其他环境时，用户请求页面的效率大打折扣，在用户使用中会出现不流畅，断断续续的不良感受。\r\n\r\n* H5技术自身渲染性能较弱\r\n\r\n>对复杂的图形样式，多样的动效，自定义字体等的支持性不强。\r\n\r\n因此，基于网络环境和渲染性能的影响，在设计H5页面时，应注意以下几点：\r\n\r\n  * 简化不重要的动画/动效\r\n  * 简化复杂的图形文字样式\r\n  * 减少页面渲染的频率和次数\r\n\r\n### 受限于浏览器\r\n通常Web App生存于浏览器里，宿主是浏览器。不同的浏览器自身的属性不尽相同，如：浏览器自带的手势，页面切换方式，链接跳转方式，版本兼容问题等等。\r\n  * UC 浏览器和百度浏览器自身支持手势切换页面。手指从左侧滑动页面，返回至上一级。百度手机助手H5页面，顶部Banner支持手势左右滑动切换。这一操作与浏览器自身手势是冲突的。\r\n  * 基于浏览器的Web APP在打开新的模块中的页面时，大多会新开窗口来展现。例如用户在使用购物类APP时，浏览每日精选模块时，每当打开新的商品时，默认新开一个窗口。这样的优劣势显而易见：优势是能够记录用户浏览过的痕迹，浏览过的商品，以便后续横向对比；劣势是过多的页面容易使用户迷失在页面中\r\n\r\n因此，Web App基于浏览器的特性，从设计角度应该遵循以下了两点：\r\n\r\n  * 少用手势，避免与浏览器手势冲突。\r\n  * 减少页面跳转次数，尽量在当前页面显示。\r\n\r\n### 系统限制，平台特性\r\n  由于Html5语言的技术特性，无法调用系统级别的权限。例如，系统级别的弹窗，系统级别的通知，地理信息，通讯录，语音等等。且与系统的兼容性也会存在一些问题。以上限制通常导致APP的拓展性不强，体验相对较差。\r\n\r\n  * 百度地图Web版地图基于浏览器展现，因此，不能全屏显示地图，给用户的眼界带来局限感；相反，Native 版地图以全屏展现的形式，很好的拓展了用户的视野。整个界面干净简洁，首页去除冗余功能。\r\n","timestamp":1585877701769},{"name":"02-移动端环境搭建.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/02-移动端环境搭建.md","content":"# 移动端环境搭建\r\n## 利用 chrome 浏览器  deviceToolbar 来调试移动端页面的尺寸  \r\n* 用谷歌浏览器打开你要测试的网页\r\n* 在浏览器的空白位置右键，选择审查元素，进入浏览器开发控制台，或者直接按f12。\r\n* 点击切换设备访问模式，切换到移动设备访问模式\r\n* 光标变成小黑点儿表示，模拟成功，可以进行调试\r\n* 环境解析<br/>\r\n  ![调试图片](amWiki/images/console.png)\r\n  * 顶端显示 `iphone`,可以去选择要调试的手机，\r\n  * 375*667  为手机的逻辑像素\r\n  * 100%   是为了适应当前观察窗口，而做的缩放，你可以选择看整个手机大小，为100%，也可以去选择其它的值。\r\n  * ![调试图片](amWiki/images/shouji.png) 切换手机的横屏和竖屏。\r\n  * ![调试图片](amWiki/images/dian.png) 设置调试信息。\r\n    * show device frame  展示设备\r\n    * show media query  展示当前页面的媒体查询阈值\r\n    * show rulers 展示当前页面的标尺\r\n    * add devicePixelRatio  展示当前页面的逻辑像素和独立像素的比\r\n    * add  device type 展示设备的内容\r\n    * add network throttling  选择不同网络限制\r\n    * capture screenshot 当前页面截图\r\n    * reset to defaults   重置设置\r\n\r\n\r\n## 利用本地服务器创建端口\r\n> 手机和电脑连接同一个网络，利用本地服务器进行真机调试。\r\n\r\n* 打开本地服务器\r\n* 将文件放入www文件夹\r\n* 找到本机的IP，打开吗，命令提示窗口，输入ipconfig回车\r\n* 用手机浏览器访问电脑的ip\r\n* 找到相对应的网页，进行查看。\r\n\r\n\r\n## 利用hbuilder等工具进行虚拟机调试\r\n>利用hbuilder打包成移动app在手机端安装测试。\r\n\r\n* 在hbuilder里新建移动app\r\n* 将网页里面的内容分别倒入相对应的文件夹\r\n* 然后连接手机，打开手机的开发者模式。\r\n* 将手机连接电脑。\r\n* 点击运行里面的真机运行。那么这个app将会自动安装在你的电脑上面。\r\n\r\n\r\n\r\n\r\n## 混合APP制作流程\r\n>混合app的开发创建我们可以使用HBuilder来进行项目的搭建，当然也可以用其他的编辑器来先做好，然后再用HBuilder创建项目，替换掉其中的文件。\r\n\r\n1. 项目的搭建\r\n    >使用HBuilder可以快速的搭建好一个项目，具体HBuilder搭建项目的步骤参考前面开发工具中的HBuilder打包工具的使用。\r\n\r\n2. 在编写项目时，必须查看设备规范，对开发规范有一定了解。\r\n\r\n3. 在调试的时候有两种方式，可以选择谷歌浏览器中的移动端开发，选择几款型号的手机进行调试；  也可以使用HBuilder中的真机调试，通过自己的手机去进行调试。 其中通过手机真机测试必不可少\r\n\r\n4. 调试完成，测试完成之后就是打包上线，打包上线的具体流程在前面的开发工具中的HBuilder打包工具的使用中有具体的介绍。\r\n","timestamp":1585877701769},{"name":"03-移动端视口viewport.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/03-移动端视口viewport.md","content":"# viewport\r\n> viewport就是设备的屏幕上能用来显示我们的网页的那一块区域\r\n\r\n## viewport的三种分类\r\n* layout viewport 默认的布局视口 <br/>\r\n移动端设备的屏幕不是很宽,但是又想完整的呈现各种页面(pc端的页面),所以移动端浏览器把视口默认的定义为一个较宽的值,一般为980px,可以通过`document.documentElement.clientWidth`获取到,  \r\n但是一般布局视口都会比我们的屏幕大,所以会出现滚动条,用户体验很不友好,于是出现了visual viewport\r\n![图示](amWiki/images/iphone.png)\r\n\r\n\r\n*  visual viewport  视觉视口<br/>\r\n一般来说视觉视口,就是我们移动设备屏幕的大小`window.innerWidth`,我们都知道移动设备的屏幕尺寸小于桌面端的屏幕尺寸,那么要想在有限的窗口内表达更多的像素, 移动端的设备就必须要通过物理手段来解决,在有限的屏幕内显示更多的像素点,于是就有了各种高清屏,比方说2k\\4k\\视网膜屏等,这些设备的dpi很高,dpi指的就是屏幕像素密度,我们也叫做物理像素,比方说:安卓分为ldpi、mdpi、hdpi、xhdpi等不同的等级,而css所表示的一个像素我们叫做独立像素 像素比:`devicePixelRatio = 物理像素 / 独立像素`,可以通过`window.devicePixelRatio` 获取,不过有些浏览器不支持,在有的浏览器里面会用物理像素表示独立像素,有的浏览器里面会用独立像素单独表示,就会出现要不然很小,要不然很大的情况.如何解决这个问题:浏览器帮我们创建了一个理想视觉窗口,让我们可以自己定义该视口有多大,并且强制用独立像素来表达  \r\n![图示](amWiki/images/iphone1.png)\r\n\r\n*  ideal viewport 理想视口 <br/>\r\n现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。浏览器把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。<br/>\r\nideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。<br/>\r\n但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等。<br/>\r\n![图示](amWiki/images/iphone2.png)\r\n\r\n## 利用meta标签对viewport进行控制\r\n\r\n* 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。\r\n\r\n```html\r\n\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">\r\n```\r\n\r\n该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。<br/>\r\nwidth\t设置layout viewport  的宽度，为一个正整数，或字符串\"width-device\"\r\ninitial-scale\t设置页面的初始缩放值，为一个数字，可以带小数\r\nminimum-scale\t允许用户的最小缩放值，为一个数字，可以带小数\r\nmaximum-scale\t允许用户的最大缩放值，为一个数字，可以带小数\r\nheight\t设置layout viewport  的高度，这个属性对我们并不重要，很少使用\r\nuser-scalable\t是否允许用户进行缩放，值为\"no\"或\"yes\", no 代表不允许，yes代表允许\r\n这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。\r\n\r\n## 把当前的viewport宽度设置为 ideal viewport 的宽度\r\n> 要得到ideal viewport就必须把默认的layout viewport的宽度设为移动设备的屏幕宽度。因为meta viewport中的width能控制layout viewport的宽度，所以我们只需要把width设为`device-width`这个特殊的值就行了。\r\n\r\n```html\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n```\r\n","timestamp":1585877701769},{"name":"04-移动端布局之百分比、响应式布局.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/04-移动端布局之百分比、响应式布局.md","content":"# 百分比布局\r\n> 我们通常把使用百分比的布局称为流动布局。\r\n为了让内容能够随着浏览器窗口的大小的变化全部显示，我们需要使用百分比来布局。流动布局就是使用百分比来代替px作为单位。 优点是流动布局可以很好解决自适应需求\r\n\r\n## 原理\r\n* 固定布局的宽度/基准参考值=流动布局百分比<br/>\r\n什么是固定布局的宽度呢？一般是我们将px单位的，叫做固定布局。基准参考值可以是你父元素的width。\r\n计算子元素所占的百分比。这里的百分比其实是width的百分比，那么高度一般我们是不做处理的。当margin、padding的单位为%时，它们是基于**父级块的宽度**的百分比。\r\n\r\n\r\n* 图片的处理<br/>\r\n响应式图片的处理，我们一般是给图片设置最大的宽度\r\n```css\r\nimg{\r\n  max-width: 200px;\r\n  height: auto;\r\n}\r\n```\r\n\r\n\r\n\r\n# 移动端响应式布局\r\n> 响应式布局的概念在前一阶段我们已经做了详细的讨论，但是这里的响应式布局方式，到了移动端的时候，其实就只有一个尺寸，也就是在750px.我们通常将750作为移动端和pc端的区分。\r\n\r\n\r\n## 移动端常见的手机尺寸\r\n> 注意在这里的尺寸，我们说的是设备的物理像素宽度\r\niPhone的屏幕尺寸各不相同，这确实是让人很头疼的事情。Android机型现在基本是统一的。\r\n\r\n### iOS\r\n| 设备 | 物理像素     |\r\n| :------------- | :------------- |\r\n| iPhone3G/3GS      |    320*480  |\r\n| iPhone4/4s      |  320*480    |\r\n| iPhone5/5s/5c      |  320*568    |\r\n| iPhone6      |  375*667    |\r\n| iPhone6+     |  414*736    |\r\n| Android     |  360*640    |\r\n\r\n## 阈值选定\r\n> 在以上机型的基础上，我们一般将移动端的手机阈值定为三个\r\n\r\n* 小于320\r\n* 大于320，小于414\r\n* 414以上，750以下\r\n\r\n所以在移动端布局的时候，如果我们去采用响应式布局，那么阈值为 320 、414\r\n","timestamp":1585877701769},{"name":"05-移动端布局之rem.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/05-移动端布局之rem.md","content":"# REM 布局解析\r\n\r\n## 什么是rem？\r\n> rem:W3C官网描述是“font size of the root element”，即rem是相对于根元素。也就是说rem其实就是一个单位，1rem=1*html字体大小\r\n\r\n```css\r\nhtml{\r\n  font-size: 100px;\r\n}\r\ndiv{\r\n  width:2rem;\r\n  height:2rem;\r\n  margin-left: 0.5rem;\r\n  /* 那么这里的实际值，其实就是2* 1*100px =200px 像素。 */\r\n}\r\n```\r\n\r\n## 支持rem的浏览器\r\n![rem](amWiki/images/rem.png);\r\n\r\n\r\n\r\n## rem布局方式 (js篇)\r\n> 最简单的方式，引入如下代码\r\n\r\n```javascript\r\n(function (doc, win) {\r\n        var docEl = doc.documentElement,\r\n            resizeEvt = \'orientationchange\' in window ? \'orientationchange\' : \'resize\',\r\n            recalc = function () {\r\n                var clientWidth = docEl.clientWidth;\r\n                if (!clientWidth) return;\r\n                if(clientWidth>=640){\r\n                  // 这里的640 取决于设计稿的宽度\r\n                    docEl.style.fontSize = \'100px\';\r\n                }else{\r\n                    docEl.style.fontSize = 100 * (clientWidth / 640) + \'px\';\r\n                }\r\n            };\r\n\r\n        if (!doc.addEventListener) return;\r\n        win.addEventListener(resizeEvt, recalc, false);\r\n        doc.addEventListener(\'DOMContentLoaded\', recalc, false);\r\n    })(document, window);\r\n```\r\n\r\n### 上述代码解析\r\n* 代码的大意为 <br/>\r\n如果页面的宽度超过了640px，那么页面中html的`font-size`恒为100px，否则，页面中html的`font-size`的大小为： 100 * (当前页面宽度 / 640)\r\n* 为什么是640px？<br/>\r\n对于手机屏幕来说，640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px * 1px 的 css pixel，所以设备像素数为640 x 1136px，而它的CSS逻辑像素数为320 x 568px。如果要切移动端页面，你可以先把效果图宽度等比例缩放到640px，很好用。\r\n* 为什么要设置html的`font-size`？<br/>\r\nrem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如：`height`,`width`,`padding`,`margin`,`font-size`。甚至，`left`,`top`等）你都可以放心大胆的用rem作单位。如果你把html的`font-size`设为20px，前面说过，rem就是html的字体大小，那么1rem = 20px\r\n但是这样的话计算特别麻烦，所以我们一般采用1rem=100px。\r\n* 为什么不设置成1rem=1px不是更好计算？<br/>\r\n浏览器一般都有最小字体限制，比如谷歌浏览器，最小中文字体就是12px，所以实际上没有办法让1rem=1px。\r\n\r\n\r\n\r\n## rem布局方式 (`@media`篇)\r\n> 引入如下的css,一般我们在做web app都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做media query设置也可以实现适配.原理和上述JS的原理相同，这种方式只适配了主流的浏览器。而上述所有设备都可以适配。CSS如下：\r\n\r\n```css\r\nhtml {\r\n  font-size: 100px; }\r\n\r\nbody {\r\n  font-size: 16px; }\r\n\r\n@media screen and (min-width: 320px) {\r\n  html {\r\n    font-size: 42.66667px; } }\r\n\r\n@media screen and (min-width: 360px) {\r\n  html {\r\n    font-size: 48px; } }\r\n\r\n@media screen and (min-width: 375px) {\r\n  html {\r\n    font-size: 50px; } }\r\n\r\n@media screen and (min-width: 412px) {\r\n  html {\r\n    font-size: 54.93333px; } }\r\n\r\n@media screen and (min-width: 414px) {\r\n  html {\r\n    font-size: 55.2px; } }\r\n```\r\n\r\n### 移动端字号单位\r\n由于手机屏幕较小，且各种屏幕尺寸不同，会导致单位字体变化，显得格格不入。 移动端的字体选择。对于只需要适配手机设备，使用px即可。对于需要适配各种移动设备， 例如需要适配iPhone和iPad等分辨率差别比较挺大的设备，就要使用rem了，有时还需要配合媒体查询一起使用：\r\n![](assets/003/03/05-1542110977000.png)","timestamp":1585877701769},{"name":"06-设备规范.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/06-设备规范.md","content":"﻿## Android\r\n### 开发规范  \r\n1. ```\r\n720*1280（4.4-4.8寸）\r\n字体：思源黑体 英文roboto\r\n36px 大字体\r\n32px 中字体\r\n24px 小字体\r\n字体不能小于24px\r\n控件状态栏高为50px\r\n导航栏高96px\r\n菜单栏高96px\r\n主菜单有文字描述高度106px\r\n启动图标120*120px\r\n操作栏图标整体大小64*64px  实际区域48*48px\r\n小图标整体大小32*32 实际区域24*24列表高度100px\r\n```\r\n2. ```\r\n1920*1080（5寸）\r\n字体微软雅黑英文roboto\r\n大小\r\n60px大字体 42字体中字体  32px小字体不能小于32\r\n控件状态栏75px\r\n顶部操作栏145\r\n文字标签140px\r\n、底部工具栏160px\r\n底部导航栏160px\r\n启动图标120*120px\r\n操作栏图标95*95px\r\n大图标78*78px\r\n中图标66*66px\r\n小图标48*48px\r\n```\r\n\r\n## ios\r\n### 开发规范\r\n|  手机型号 | 分辨率（px）\t| 状态栏高度（px）|\t导航栏高度（px）|\t标签栏高度（px）|\r\n| :------------- | :------------- |:------------- | :------------- |\r\n|IPhone 6 Plus设计尺寸 物理尺寸|\t1242*2208 1080*1920\t|60\t|132|\t147|\r\n|IPhone 6\t|750*1334\t|40\t|88|\t98|\r\n|IPhone 5/5s/5c|\t640*1136|\t40\t|88|\t98|\r\n|IPhone 4/4s|\t640*960\t|40|\t88|\t98|\r\n|IPad  3/4/Air/Air2|\t2048*1536\t|40\t|88|\t98|\r\n|IPad 1/2\t1024*768|\t20|\t44\t|49|\r\n|IPad Mini\t|1024*768\t|20\t|44\t|49|\r\n\r\n\r\n\r\n\r\n## H5页面 (web App)\r\n1. H5页面前端代码里面必须包含\r\n<meta content=\"initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width\" name=\"viewport\" />\r\n<meta content=\"telephone=no\" name=\"format-detection\" />\r\n2. 单个页面内容不能过多\r\n>h5经常需要分享到各种社交APP上，他们的内部浏览器大部分会带有顶部栏和底部栏，所以我们需要在顶部和底部留一定的空间\r\n\r\n3. 移动端浏览器导航条宽度有限，简短的标题可以使其展示完整。\r\n4. 二维码图片使用 img 标签引入\r\n>二维码图片不要写为元素背景，不然长按没有办法触发扫描功能。应使用 img 标签引入.\r\n\r\n5. 二维码图片记得扫描测试\r\n>在QQ或者微信上扫描我们的二维码，QQ或者微信有时候会对这个地址进行温馨提醒，这样不友好，所以二维码的测试是必要的\r\n\r\n6. 关于H5页面链接的分享-QQ\r\n>手机上接收链接消息的用户可能会看到链接的相关信息，如页面标题、描述和图片。相关信息设置方式如下：\r\n```html\r\n<title>QQ中链接的标题由此处获取</title>\r\n<meta name=\"description\" content=\"QQ中链接的描述由此处获取\">\r\n<!-- QQ默认获取的图片有可能出现缩放问题，效果不佳，可以通过如下方法进行设置 -->\r\n<meta itemprop=\"image\" content=\"http://*.*.com/static/images/share.png\" />\r\n```\r\n7. CSS 动画属性前缀 webkit\r\n>使用 CSS3 来制作动画效果的话， webkit 前缀一定记得加，要不然在某些手机下动画效果是没有的。\r\n\r\n8. 记得图片一定要压缩\r\n\r\n\r\n## 微信小程序\r\n### 注意事项\r\n|设备\t|rpx换算px (屏幕宽度/750)|\tpx换算rpx (750/屏幕宽度)|\r\n| :------------- | :------------- |:------------- |\r\n|iPhone5|\t1rpx = 0.42px|\t1px = 2.34rpx|\r\n|iPhone6|\t1rpx = 0.5px|\t1px = 2rpx|\r\n|iPhone6s|\t1rpx = 0.552px\t|1px = 1.81rpx|\r\n\r\n1. tabBar 是一个数组，只能配置最少2个、最多5个tab，tab 按数组的顺序排序。（底部导航栏）\r\n2. 在进行页面布局的时候推荐使用flex布局，\r\n3. 不要使用px，小程序为了保证兼容和自适应使用了新的单位rpx\r\n4. 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。\r\n","timestamp":1585877701769},{"name":"07-移动端布局之弹性盒模型.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/07-移动端布局之弹性盒模型.md","content":"# Flex的由来\r\n> 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\r\n\r\n## Flex的简介\r\n* Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。\r\n* 任何一个容器都可以指定为Flex布局。\r\n* 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。\r\n```css\r\n.box{\r\n      display: flex; //(新版)\r\n      display:-webkit-box; (旧版)\r\n    }\r\n```\r\n\r\n## Flex的基本概念\r\n* 采用Flex布局的元素，称为Flex容器（flex  container），简称”容器”。\r\n* 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”\r\n* 主轴：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；\r\n交叉轴的开始位置叫做cross start，结束位置叫做cross end。\r\n* 交叉轴：项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\r\n![显示](amWiki/images/-1.png)\r\n\r\n## 容器的属性\r\n\r\n###  项目排列的方向\r\n* flex-direction 属性决定主轴的方向<br/>\r\n\r\n| 属性 | 表现      | 表现图示|\r\n| :-------------  |  :------------- | :-----|\r\n| row（默认值）      |   从左到右     |  ![默认图示](amWiki/images/111.png)|\r\n| row-reverse       |   从右到左    | ![默认图示](amWiki/images/222.png)|\r\n| column            |   从上到下    |![默认图示](amWiki/images/333.png)|\r\n| column–reverse    |  从下到上   |![默认图示](amWiki/images/444.png)|\r\n\r\n\r\n```css\r\nflex-direction: row | row-reverse |column |column-reverse\r\n```\r\n\r\n* 兼容写法\r\n\r\n```css\r\n-webkit-box-orient:horizontal | vertical\r\n-webkit-box-direction:normal |reverse\r\n```\r\n| 属性 | 表现     |\r\n| :------------- | :------------- |\r\n| horizontal     |   水平方向      |\r\n| vertical     |   垂直方向     |\r\n| normal           |   顺序正常    |\r\n| reverse   | 反向  |\r\n\r\n\r\n\r\n### 项目包裹方式\r\n\r\n* flex-wrap\r\n> 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\r\n\r\n| 属性 | 表现     | 表现图示|\r\n| :------------- | :------------- |:------------- |\r\n| nowrap默认       | 不换行      | ![图](amWiki\\images\\555.png) |\r\n| wrap       | 换行      | ![图](amWiki\\images\\666.png) |\r\n| wrap-reverse：| 换行，第一行在下方。     |![图](amWiki\\images\\777.png) |\r\n\r\n```css\r\nflex-wrap:nowrap | wrap | wrap-reverse\r\n```\r\n\r\n### 项目水平对齐方式\r\n* justify-content\r\n> justify-content属性定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\r\n\r\n| 属性 | 表现     | 表现图示|\r\n| :------------- | :------------- |:------------- |\r\n| flex-start（默认值）| 左对齐    | ![图](amWiki\\images\\888.png) |\r\n| flex-end    | 右对齐    | ![图](amWiki\\images\\999.png) |\r\n| center| 居中     |![图](amWiki\\images\\0000.png) |\r\n| space-between| 两端对齐，项目之间的间隔都相等。  |![图](amWiki\\images\\1111.png) |\r\n| space-around| 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。|![图](amWiki\\images\\2222.png) |\r\n\r\n```css\r\njustify-content:flex-start | flex-end | center | space-between | space-around\r\n```\r\n\r\n* 兼容写法\r\n\r\n```css\r\n-webkit-box-pack: start | end |center |justify\r\n```\r\n| 属性     | 表现    |\r\n| :------------- | :------------- |\r\n|  start      | 左对齐      |\r\n|  end     | 右对齐      |\r\n|  center   | 居中    |\r\n|  justiry   | 两端对齐   |\r\n\r\n\r\n###  项目的垂直对齐方式\r\n* align-items属性\r\n> align-items属性定义项目在交叉轴上如何对齐。它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\r\n\r\n```css\r\nalign-items:flex-start | flex-end | center | baseline | stretch  \r\n```\r\n| 属性 | 表现     | 表现图示|\r\n| :------------- | :------------- |:------------- |\r\n| stretch（默认值) | 如果项目未设置高度或设为auto,将占满整个容器的高度。 | ![图](amWiki\\images\\3333.png) |\r\n| flex-start | 交叉轴的起点对齐   | ![图](amWiki\\images\\4444.png) |\r\n| flex-end | 交叉轴的终点对齐    |![图](amWiki\\images\\5555.png) |\r\n| center| 交叉轴的中点对齐。  |![图](amWiki\\images\\6666.png) |\r\n| baseline|  项目的第一行文字的基线对齐。|![图](amWiki\\images\\7777.png) |\r\n\r\n\r\n\r\n* 兼容写法\r\n\r\n| 属性 | 描述     |\r\n| :------------- | :------------- |\r\n|  start     | 顶对齐      |\r\n|  end     | 底对齐      |\r\n|  center     | 居中对齐      |\r\n\r\n```css\r\n-webkit-box-align:start | end |center\r\n```\r\n\r\n### 多行对齐方式  \r\n* align-content属性\r\n>  align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\r\n\r\n| 属性 | 表现     | 表现图示|\r\n| :------------- | :------------- |:------------- |\r\n| flex-start | 交叉轴的起点对齐   | ![图](amWiki\\images\\flex-start.png) |\r\n| flex-end | 交叉轴的终点对齐    |![图](amWiki\\images\\flex-end.png) |\r\n| center| 交叉轴的中点对齐。  |![图](amWiki\\images\\center.png) |\r\n| space-between | 与交叉轴两端对齐,轴线之间的间隔平均分布。 |![图](amWiki\\images\\space-between.png) |\r\n| space-around|  每根轴线两侧的间隔都相等。轴线之间的间隔比轴线与边框的间隔大一倍|![图](amWiki\\images\\space-around.png) |\r\n| stretch（默认值）| 轴线占满整个交叉轴。|![图](amWiki\\images\\stretch.png) |\r\n\r\n\r\n```css\r\nalign-content:  flex-start | flex-end | center | space-between | space-around | stretch\r\n```\r\n\r\n## 项目的属性\r\n### 项目的顺序\r\n* order\r\n> order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\r\n\r\n  ```css\r\n    order:<int>  \r\n  ```\r\n  ![图](amWiki\\images\\order.png)<br/>\r\n\r\n* 兼容写法\r\n```css\r\n-webkit-box-ordinal-group:<int>   \r\n```\r\n\r\n### 项目占比(放大)\r\n* flex-grow\r\n> flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\r\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍\r\n\r\n  ```css\r\n  flex-grow:<int>\r\n  ```\r\n  ![图](amWiki\\images\\flex1.png)<br/>\r\n  ![图](amWiki\\images\\flex2.png)\r\n\r\n\r\n* 兼容写法\r\n```css\r\n-webkit-box-flex : <int>  \r\n```\r\n\r\n### 项目占比(缩小)  \r\n* flex-shrink\r\n> flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效\r\n\r\n  ```css\r\n   flex--shrink:<int>\r\n  ```\r\n  ![图](amWiki\\images\\shrink.png)\r\n\r\n###  项目所占空间大小\r\n* flex-basis\r\n> flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\r\n\r\n  ```css\r\n    flex-basis:<size> | auto\r\n  ```\r\n\r\n### 项目自己的对齐方式\r\n>  `优先级高于容器的 align-items`    \r\n\r\n* align-self\r\n> align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\r\n\r\n  ```css\r\n    align-self: auto | flex-start | flex-end | center | baseline | stretch;\r\n  ```\r\n  ![图](amWiki\\images\\self.png)\r\n\r\n### 案例\r\n```html\r\n<!--防止移动端兼容问题我们布局是采用两行-->\r\n<div class=\"rows\">\r\n\t<div><a href=\"javascript:;\">天猫</a></div>\r\n\t<div><a href=\"javascript:;\">聚划算</a></div>\r\n\t<div><a href=\"javascript:;\">天猫国际</a></div>\r\n\t<div><a href=\"javascript:;\">外卖</a></div>\r\n\t<div><a href=\"javascript:;\">天猫超市</a></div>\r\n</div>\r\n<div class=\"rows\">\r\n\t<div><a href=\"javascript:;\">天猫</a></div>\r\n\t<div><a href=\"javascript:;\">聚划算</a></div>\r\n\t<div><a href=\"javascript:;\">天猫国际</a></div>\r\n\t<div><a href=\"javascript:;\">外卖</a></div>\r\n\t<div><a href=\"javascript:;\">天猫超市</a></div>\r\n</div>\r\n```\r\n```css\r\n/* 去掉默认样式*/\r\nbody,body *{\r\n  -webkit-text-size-adjust: 100%;\r\n}\r\nbody,h1{\r\n\tmargin: 0;\r\n}\r\na,input,button{\r\n\t/*-webkit-tap-highlight-color:none;*/\r\n\t-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n}\r\na{\r\n\ttext-decoration: none;\r\n}\r\nbutton{\r\n\t-webkit-appearance: none;\r\n}\r\n\r\n/*正式布局*/\r\n.rows{\r\n\tdisplay: -webkit-box;\r\n\tdisplay: flex;\r\n}\r\n.rows div{\r\n\t/* 所有的盒子就一样大 */\r\n\twidth: 0px;\r\n\t-webkit-box-flex: 1;\r\n\tflex-grow: 1;\r\n}\r\n.rows div a{\r\n\tfont-size: 0.44rem;\r\n\tcolor: #666;\r\n\ttext-align: center;\r\n\tline-height: 1.04rem;\r\n\tdisplay: block;\r\n}\r\n.rows div a:before{\r\n\tcontent: \'\';\r\n\tdisplay: block;\r\n\tmargin: 0 auto;\r\n\twidth: 1.72rem;\r\n\theight: 1.7rem;\r\n\tbackground: red;\r\n\tbackground-size: 1.72rem 1.7rem;\r\n}\r\n.rows:nth-of-type(1) div:nth-of-type(1) a:before{\r\n\tbackground-image: url(img/1.webp);\r\n}\r\n.rows:nth-of-type(1) div:nth-of-type(2) a:before{\r\n\tbackground-image: url(img/2.webp);\r\n}\r\n.rows:nth-of-type(1) div:nth-of-type(3) a:before{\r\n\tbackground-image: url(img/3.webp);\r\n}\r\n.rows:nth-of-type(1) div:nth-of-type(4) a:before{\r\n\tbackground-image: url(img/4.webp);\r\n}\r\n.rows:nth-of-type(1) div:nth-of-type(5) a:before{\r\n\tbackground-image: url(img/5.webp);\r\n}\r\n.rows:nth-of-type(2) div:nth-of-type(1) a:before{\r\n\tbackground-image: url(img/6.webp);\r\n}\r\n.rows:nth-of-type(2) div:nth-of-type(2) a:before{\r\n\tbackground-image: url(img/7.webp);\r\n}\r\n.rows:nth-of-type(2) div:nth-of-type(3) a:before{\r\n\tbackground-image: url(img/8.webp);\r\n}\r\n.rows:nth-of-type(2) div:nth-of-type(4) a:before{\r\n\tbackground-image: url(img/9.webp);\r\n}\r\n.rows:nth-of-type(2) div:nth-of-type(5) a:before{\r\n\tbackground-image: url(img/10.webp);\r\n}\r\n```\r\n","timestamp":1585877701769},{"name":"08-hack.md","path":"001-前端/07-HTML & CSS/004-全端布局/02-移动端开发/08-hack.md","content":"#### 什么是 hack ？\r\n> 由于不同的浏览器，对CSS的解析认识不一样，因此会导致生成的页面效果不一样，这时就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。这个针对不同的浏览器写不同的CSS code的过程，就叫`CSS hack`。\r\n\r\n# 移动端布局常见问题\r\n\r\n## webkit内核中的一些私有的meta标签\r\n```html\r\n<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\">\r\n<!-- 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览； -->\r\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\r\n<!-- iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览； -->\r\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\r\n<!-- iphone的私有标签，它指定的iphone中safari顶端的状态条的样式； -->\r\n<meta content=\"telephone=no\" name=\"format-detection\">\r\n<!-- 告诉设备忽略将页面中的数字识别为电话号码 -->\r\n```\r\n\r\n\r\n## 横竖屏限制问题    \r\n```html\r\n  <meta name=\"x5-orientation\" content=\"portrait | landscape\" />\r\n```\r\n> 只支持x5内核\r\n\r\n```html\r\n  <meta name=\"screen-orientation\" content=\"portrait\">\r\n```\r\n> 只支持uc浏览器\r\n\r\n## 全屏限制问题  \r\n```html\r\n  <meta name=\"x5-fullscreen\" content=\"true\" />  \r\n```\r\n>只支持x5内核\r\n\r\n```html\r\n  <meta name=\"full-screen\" content=\"yes\">\r\n```\r\n>只支持uc浏览器\r\n\r\n## 禁止识别电话号码和邮箱\r\n```html\r\n  <meta name=\"format-detection\" content=\"telephone=no, email=no\" />\r\n```\r\n> 禁止识别后页面当中所有的邮箱和电话将不会识别,如果有特殊需求,要配合一下代码实现\r\n\r\n```html\r\n  <a href=\"tel:110\">请拨打电话110</a>\r\n  <a href=\"mailto:qq@.com\">请发送邮件qq@.com</a>        \r\n```\r\n## 消除链接\\表单\\按钮 默认背景\r\n\r\n```\r\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n```\r\n\r\n## 消除按钮圆角\r\n\r\n```\r\n  -webkit-appearance: none;\r\n```\r\n\r\n## 移动端字体\r\n  * ios系统  \r\n    + 默认中文字体是Heiti SC   \r\n    + 默认英文字体是Helvetica   \r\n    + 默认数字字体是HelveticaNeue   \r\n    + 无微软雅黑字体   \r\n  * android 系统\r\n    + 默认中文字体是Droidsansfallback  \r\n    + 默认英文和数字字体是Droid Sans  \r\n    + 无微软雅黑字体  \r\n  * winphone 系统\r\n    + 默认中文字体是Dengxian(方正等线体)  \r\n    + 默认英文和数字字体是Segoe  \r\n    + 无微软雅黑字体     \r\n  * 结论  \r\n    + 各个手机系统有自己的默认字体，且都不支持微软雅黑  \r\n    + 如无特殊需求，手机端无需定义中文字体，使用系统默认  \r\n    + 英文字体和数字字体可使用 Helvetica ，三种系统都支持    \r\n\r\n```\r\n  body{font-family:Helvetica;}\r\n```\r\n\r\n## 禁止用户设置字体大小\r\n\r\n```\r\n -webkit-text-size-adjust:100%\r\n```\r\n\r\n## 禁止文字选中\r\n\r\n```\r\n  -webkit-user-select:none  //安卓不支持\r\n```\r\n\r\n## 字体增强 font boosting\r\n\r\n>移动端设备为了使用户能看清楚大批量的字体,会自动对字体进行放大,但是只要指定了容器的高度,就能解决\r\n\r\n```\r\n  p{max-height:9999999px}\r\n```      \r\n\r\n## 调用原生滚动事件\r\n\r\n```\r\n -webkit-overflow-scrolling:touch\r\n```\r\n\r\n## CSS动画页面闪白,动画卡顿\r\n\r\n>  解决方法:\r\n  * 尽可能地使用合成属性`transform`和`opacity`来设计CSS3动画，不使用`position`的left和top来定位\r\n  * 使用 CSS3 动画的时尽量利用3D加速，从而使得动画变得流畅。动画过程中的动画闪白可以通过 `backface-visibility` 隐藏\r\n\r\n```\r\n  -webkit-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);\r\n```\r\n## fixed定位缺陷\r\n  * ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位\r\n  * android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位\r\n  * ios4下不支持`position:fixed`\r\n\r\n>解决方案： 可用iScroll插件解决这个问题  \r\n\r\n## 阻止旋转屏幕时自动调整字体大小\r\n```\r\n  html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 {-webkit-text-size-adjust:none;}\r\n```\r\n## 上下拉动滚动条时卡顿、慢\r\n```\r\nbody {-webkit-overflow-scrolling:touch; overflow-scrolling: touch;}\r\n```\r\n> Android3+和iOS5+支持CSS3的新属性为overflow-scrolling\r\n\r\n## 禁止复制、选中文本\r\n\r\n```\r\n  -webkit-user-select:none;user-select:none;\r\n```\r\n> 解决移动设备可选中页面文本(视产品需要而定)\r\n\r\n## ios和android下触摸元素时出现半透明灰色遮罩\r\n>设置alpha值为0就可以去除半透明灰色遮罩，备注：`transparent`的属性值在android下无效。\r\n\r\n```\r\n  -webkit-tap-highlight-color:rgba(255,255,255,0)\r\n```\r\n\r\n## 关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)\r\n> iOS 浏览器横屏时会重置字体大小，设置 `text-size-adjust` 为 none 可以解决 iOS 上的问题，但桌面版Safari 的字体缩放功能会失效，因此最佳方案是将 `text-size-adjust` 为 100% 。\r\n\r\n```css\r\n  /* -webkit-text-size-adjust: 100%;\r\n  text-size-adjust: 100%; */\r\n```\r\n\r\n## Android 2.0以下平台中圆角的问题\r\n>android 2.0以下的平台中问题特别的多，比如说边框圆角这个问题吧。\r\n在对一个元素定义圆角时，为完全兼容android 2.0以下的平台，我们必须要按照以下技巧来定义边框圆角：\r\n1＼-webkit这个前缀必须要加上（在iOS中，你可以不加，但android中一定要加）；\r\n2＼如果对针对边框做样式定义，比如`border:1px solid #000;`那么`-webkit-border-radius`这属性必须要出现在border属性后。\r\n3＼假如我们有这样的视觉元素，左上角和右上角是圆角时，我们必须要先定义全局的(4个角的圆角值)`-webkit-border-radius:5px;`然后再依次的覆盖左下角和右下角，`-webkit-border-bottom-left-radius:0;-webkit-border-bottom-right-border:0;`否则在android 2.0以下的平台中将全部显示直角，还有记住！-webkit这个前缀一定要加上！\r\n\r\n## 去除iOS和Android中的输入URL的控件条\r\n>能否让我们的webapp更加像nativeapp，我不想让用户看见那个输入url的控件条？\r\n答案是可以做到的。我们可以利用一句简单的javascript代码来实现这个效果\r\n`setTimeout(scrollTo,0,0,0);`\r\n\r\n## iOS 4.3版本中safari对页面中5位数字的自动识别和自动添加样式\r\n>iOS系统4.3版本对safari造成了一个bug：即使你添加了如下的meta标签，safari仍然会对页面中的5位连续的数字进行自动识别，并且将其重新渲染样式，也就是说你的css对该标签是无效的。\r\n`<meta name=\"format-detection\" content=\"telphone=no\" />`        \r\n比如说支付宝wap站点中显示金额的标签，我们都做了如下改写：        \r\n`<button class=\"t-balance\"style=\"background:none;padding:0;border:0;\">95009.00</button>`\r\n\r\n## iOS中如何获取滚动条的值\r\n>桌面浏览器中想要获取滚动条的值是通过`document.scrollTop`和`document.scrollLeft`得到的，但在iOS中你会发现这两个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？  \r\n通过`window.scrollY`和`window.scrollX`我们可以得到当前窗口的y轴和x轴滚动条的值。\r\n\r\n## iOS中禁止用户选中文字\r\n>我们通过指定文字标签的`-webkit-user-select`属性为none便可以禁止iOS用户选中文字。\r\n\r\n## iOS中禁止用户保存图片＼复制图片\r\n>元素的`-webkit-touch-callout`属性，同样为一个img标签指定`-webkit-touch-callout`为none也会禁止设备弹出列表按钮，这样用户就无法保存＼复制你的图片了。\r\n\r\n## iOS中彻底禁止用户在新窗口打开页面\r\n>有时我们可能需要禁止用户在新窗口打开页面，我们可以使用a标签的`target=\"_self\"`来指定用户在新窗口打开，或者target属性保持空，但是你会发现iOS的用户在这个链接的上方长按3秒钟后，iOS会弹出一个列表按钮，用户通过这些按钮仍然可以在新窗口打开页面，这样的话，开发者指定的target属性就失效了，但是可以通过指定当前元素的`-webkit-touch-callout`样式属性为none来禁止iOS弹出这些按钮。这个技巧仅适用iOS对于Android平台则无效。\r\n\r\n## 关闭iOS中键盘自动大写\r\n>在iOS中，当虚拟键盘弹出时，默认情况下键盘是开启首字母大写的功能的，根据某些业务场景，可能我们需要关闭这个功能，移动版本webkit为input元素提供了`autocapitalize`属性，通过指定`autocapitalize=”off”`来关闭键盘默认首字母大写。\r\n","timestamp":1585877701769},{"name":"01-页面测试.md","path":"001-前端/07-HTML & CSS/005-全端高级/01-页面测试.md","content":"# 网页测试\r\n>web测试主要分为6个阶段，分别是功能测试，性能测试，用户界面测试，兼容测试，安全测试，接口测试。涉及到页面重构阶段的主要是兼容测试，功能测试，用户界面测试。\r\n\r\n## 用户界面测试\r\n>用户界面测试是站在用户的角度去思考问题，寻找网页的缺点。寻找开发无关人员，最好是最终用户来使用。\r\n\r\n1. 用户能否能评直觉找到需要找的信息的位置\r\n2. 整个网站的界面风格是否统一\r\n3. 用户在使用的过程中是否感到舒适，乐意继续使用下去\r\n4. 尽量寻找多的最终用户来测试，并且收集他们的反馈信息\r\n\r\n## 功能测试\r\n>页面重构阶段的功能测试主要是测试链接是否正确，有无遗漏的页面  \r\n\r\n1. 点击链接，测试页面是否跳转到我们想要跳转到的页面\r\n2. 项目中是否存在孤立的页面，也就是没有链接能够指向的页面\r\n\r\n## 兼容测试\r\n>由于市面上的浏览器的种类很多，同一个浏览器的不同版本之间差别也很大，所以我们需要对页面进行兼容测试，保证我们的页面能够在各种浏览器中很好的呈现我们想要的效果。\r\n\r\n1. 平台测试 -- 市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等，因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试。<a href=\"https://tongji.baidu.com/data/os\">点击查看操作系统的市场占有率</a>\r\n2. 浏览器兼容测试 -- 我们在做浏览器兼容测试的时候选择浏览器时需要考虑一下几点\r\n    * 浏览器的市场占有率以及项目面向的主要群体 <a href=\"https://tongji.baidu.com/data/browser\">点击查看浏览器的市场占有率</a>\r\n    * 浏览器的内核 目前主流的内核主要分为4种，分别需要在4种内核中选择几个代表性的浏览器，将项目页面用不同内核不同版本的浏览器打开，查看页面表现是否完整。     \r\n    * ie浏览器的兼容(ie捆绑windows，所以他的市场占比很高，测试时根据项目要求来选择兼容ie版本)\r\n    * (比较常用的几款浏览器)chrome、Firefox、Safari、IE7、IE8、IE9、IE11、搜狗、QQ、2345浏览器\r\n3. 分辨率测试 -- <a href=\"https://tongji.baidu.com/data/screen\">点击查看分辨率的市场占有率</a>，将我们的项目页面放置在不同的分辨率下来查看我们的页面是否表现为我们想要的样子。\r\n\r\n4. 组合测试 -- 组合测试就是将系统平台、浏览器、分辨率这三个因素结合起来，打乱成不同的组合，进行综合测试。\r\n ","timestamp":1585877701769},{"name":"02-pc端兼容.md","path":"001-前端/07-HTML & CSS/005-全端高级/02-pc端兼容.md","content":"# 浏览器兼容\r\n## 兼容问题产生的原因\r\n>不同浏览器使用内核及所支持的HTML（标准通用标记语言下的一个应用）等网页语言标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。\r\n\r\n## 查看兼容问题的方法\r\n去下面这个网页可以查看一些标签和css属性的兼容情况，不确定是否兼容的时候可以去查看 <br/>\r\n<a href=\"https://www.caniuse.com/\">点击查看</a>\r\n\r\n## PC端兼容问题\r\n>CSS网站设计的浏览器兼容性问题比较突出各个浏览器对CSS的支持略有不同，但这些细小的不同也会使网站在各个浏览器中有较大的显示差异，甚至是面目全非，所以我们要学会如何处理这些问题。\r\n\r\n\r\n### 共性问题\r\n1. 浏览器给一些标签默认样式\r\n  + 解决：清除默认样式，保证在每个浏览器样式统一。\r\n\r\n  ```\r\n  body,p,ul,h1,h2,h3,h4,h5,h6,ol,dl,dd,form,input,ul,ol{\r\n    margin:0;padding:0;list-style:none;font-weight:normal;\r\n  }\r\n  img{border:none;}\r\n  ```\r\n2. img标签底部间隙问题\r\n  + 问题：div中包含一张图片，底部可能有2px 4px或更多的间隙，不同font-size会影响这个间隙的大小。\r\n  + 解决：将图片的垂直对齐方式vertical-align，值为top或bottom；将图片转换为块标签，display:block；将包含图片的父容器的字体大小设为零，font-size:0；\r\n\r\n3. img标签IE下图片有边框\r\n  + 问题：html 图片img加了超链接（a标签）之后产生难看的蓝色边框！（IE6-10）\r\n  + 解决：img{border:0;}\r\n\r\n4. margin-top没有加到指定元素身上\r\n  + 问题：在一个容器中给子元素一个上边距，父元素和子元素一起往下移动这是一个bug。\r\n  + 解决：\r\n    1. 通过给父元素一个像素的透明边框:border:1px solid rgba(0,0,0,0);\r\n    2. 通过给父元素一个:padding-top来模拟margin-top;\r\n\r\n5. 父容器（子元素浮动）高度为0\r\n  + 问题：父元素的高度不确定，且子元素个数不确定、而且还是float，会引发父元素高度为0问题，浮动的子元素层级高于父元素导致撑不开父元素的高度!\r\n  + 解决：\r\n    1. 在使用float元素的父元素结束前加一个高为0宽为0且有clear:both样式的空div\r\n      `<div style=\"clear:both;\"></div>`\r\n    2. 在父容器上添加overflow:hidden\r\n\r\n\r\n### 兼容ie9需要特别注意\r\n2. 所有css文件 写清类型  type=\"text/css\" 要写上\r\n3. ie9及以下不支持`display:flex;`和`display:grid;`布局，网页需要兼容ie9则不能使用。\r\n4. `@keyframes` `linear-gradient` `text-shadow` `multiple columns` `gradients` 属性在ie6-9都不支持\r\n5. `transition` `border-image` 属性在ie6-10都不支持\r\n6. `transform`2d转换属性不支持ie6-8，ie9需要加前缀来支持\r\n7. H5标签不支持ie9以下版本浏览器,`main`标签不支持ie9-11;\r\n8. calc属性IE9部分支持   IE6-8都不支持\r\n\r\n### 兼容ie8需要特别注意\r\n1. 因为IE8加入了“兼容性视图”功能，这样的话就可以在IE8中就会使用IE6或IE7的内核渲染页面。使用meta标签来强制IE8使用最新的内核渲染页面`<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">`\r\n2. `box-shadow` `border-radius` 属性在ie6-8都不支持\r\n3. IE8不支持last-child\r\n4. IE8不支持background-size: cover设置全屏背景\r\n5.\r\n\r\n### 兼容ie6需要特别注意\r\n1. IE6使用 `margin:0 auto;` 元素无法水平居中\r\n1. IE6双倍边距 bug\r\n  + 问题：当我们给元素添加浮动的并指定左外边距的时候，IE6会出现双倍边距\r\n  + 解决：给浮动的元素指定 display:inline;\r\n2. IE6下png图片不支持透明度\r\n  * 问题：在ie6下png图片不支持透明度\r\n  * 解决：\r\n\r\n  ```css\r\n    filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=image,src=\"opacity.png\");\r\n    _background:none;\r\n  ```\r\n\r\n3. IE6不支持固定定位\r\n  + 问题：IE6不支持固定定位；（利用绝对定位模拟固定定位）\r\n  + 解决：\r\n  ```css\r\n  选择器{\r\n      width:200px;height:200px;background:red;\r\n      position:fixed;bottom:50px;right:50px;\r\n      *position:absolute;\r\n      *top:expression(eval(document.documentElement.scrollTop+200));\r\n  }\r\n  *html{\r\n      background-image:url(blank:about);\r\n      background-attachment:absolute;\r\n  }\r\n  ```\r\n4. IE6对!important不能很好的支持\r\n>在同一个选择器(即同一个{})内有重复的属性的话，此选择器内的此属性的 !important 在 IE6 里无效。\r\n\r\n5. IE6在解析百分比时，会按四舍五入方式计算从而导致50%加50%大于100%的情况\r\n\r\n6. IE6不支持子选择器\r\n\r\n7. IE6中元素具有href属性才能触发hover\r\n\r\n8. IE6调整窗口大小的Bug\r\n>当把body居中放置，改变IE浏览器大小的时候，任何在body里面的相对定位元素都会固定不动了。解决办法：给body定义position:relative;就行了。\r\n\r\n9. IE6下子元素超出父级宽高，会把父级的宽高撑开\r\n>不要使得子元素超过父元素，或者使用`overflow：hidden`\r\n\r\n\r\n## CSS hack\r\n* 各浏览器兼容CSS\r\n\r\n```css\r\n.bb{\r\n    background-color:#f1ee18; /*所有识别*/\r\n    background-color:#00deff\\9; /*IE6、7、8识别*/\r\n    +background-color:#a200ff; /*IE6、7识别*/\r\n    _background-color:#1e0bd1; /*IE6识别*/\r\n  }\r\n```\r\n![css hack表](amWiki/images/hack.png)\r\n","timestamp":1585877701769},{"name":"03-移动端兼容.md","path":"001-前端/07-HTML & CSS/005-全端高级/03-移动端兼容.md","content":"# CSS移动端兼容性\r\n## 综合\r\n1. 移动端开发需要加入的代码\r\n```\r\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">  \r\n<meta name=\"viewport\" content=\"initial-scale=1,user-scalable=no\",maximum-scale=1,minimum-scale=1>\r\n```\r\n2. 在移动端图片上传图片 使用`accept=\"image/*\"` multiple,兼容低端机的问题\r\n3. click 300ms 延时响应 使用 Fastclick\r\n```javascript\r\nwindow.addEventListener( \"load\", function() {\r\n    FastClick.attach( document.body );\r\n    }, false );\r\n```\r\n4. input 有placeholder情况下不要设置行高，否则会偏上\r\n5. 忽略将页面中的数字识别为电话号码\r\n```html\r\n<meta name=\"format-detection\" content=\"telephone=no\" />\r\n<!-- （iOS上会明显 有时候会把数字当成电话号码） -->\r\n```\r\n6. webkit表单元素的默认外观重置\r\n```css\r\n.css{-webkit-appearance:none;}\r\n/* （ios上的下拉框会有圆角，所以要写border-radius:0） */\r\n```\r\n7. 在input框获得焦点时文字被清空用value 在input框输入文字时被清空用placeholder\r\n8. 禁用 radio 和 checkbox 默认样式\r\n```css\r\ninput[type=\"radio\"]::-ms-check,input[type=\"checkbox\"]::-ms-check{\r\n    display: none;/*这样就可以用class自定义样式*/\r\n}\r\n```\r\n9. `<button></button>`元素一定要写上type属性不然会默认提交表单，出现想不到的bug\r\n10. ios和android下触摸元素时出现半透明灰色遮罩\r\n```CSS\r\nElement {\r\n    -webkit-tap-highlight-color:rgba(255,255,255,0)\r\n}\r\n```\r\n11. 旋转屏幕时，字体大小调整的问题\r\n```CSS\r\nhtml, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6{\r\n    -webkit-text-size-adjust:100%;\r\n}\r\n```\r\n12. 通过transform进行skew变形，rotate旋转会造成出现锯齿现象\r\n```css\r\n.box{\r\n    -webkit-transform: rotate(-4deg) skew(10deg) translateZ(0);\r\n    transform: rotate(-4deg) skew(10deg) translateZ(0);\r\n    outline: 1px solid rgba(255,255,255,0)\r\n}\r\n```\r\n13. html5调用安卓或者ios的拨号功能\r\n>html5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。\r\n```html\r\n<a href=\"tel:4008106999,1034\">400-810-6999 转 1034</a>\r\n<!-- 拨打手机直接如下 -->\r\n<a href=\"tel:15677776767\">点击拨打15677776767</a>\r\n```\r\n\r\n14. 长时间按住页面出现闪退\r\n```CSS\r\nelement {\r\n    -webkit-touch-callout: none;\r\n}\r\n```\r\n15. 在ios和andriod中,audio元素和video元素在无法自动播放(应对方案：触屏即播)\r\n```js\r\n$(\'html\').one(\'touchstart\',function(){\r\n    audio.play()\r\n})\r\n```\r\n\r\n16. calc的兼容性处理\r\nCSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。\r\nAndroid浏览器目前仍然不支持calc\r\n\r\n\r\n## ios\r\n1. input标签，设置type=button属性，disabled设置true，会出现样式文字和背景异常问题，解决方案：使用opacity=1\r\n2. 有时对非可点击元素如(label,span）添加单机监听事件，不会触发，解决方案：修改样式，cursor:pointer\r\n3. input为fixed定位在IOS下的bug问题，单击焦点输入，输入跳转到中间，可以使用内容滚动框也是fixed来设置\r\n4. 在h5嵌入app中，IOS如果出现垂直滚动条时，手指开始滚动页面后，滚动很快停止\r\n5. IOS手机中如果出现一个元素的层级非常高可还是被别的元素遮盖的，那么就将该元素与别的元素同级\r\n6. 苹果手机固定定位有bug 检查html和body是不是设置了overflow-x:hidden\r\n7. iphone及ipad下输入框默认内阴影\r\n```CSS\r\nElement{\r\n    -webkit-appearance:none;\r\n}\r\n```\r\n8. ios 设置input 按钮样式会被默认样式覆盖\r\n```CSS\r\ninput,textarea {\r\n    border: 0;\r\n    -webkit-appearance: none;\r\n}\r\n```\r\n9. 关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)\r\n>iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。\r\n```CSS\r\n.box{\r\n    -webkit-text-size-adjust:100%;\r\n    -ms-text-size-adjust:100%;\r\n    text-size-adjust:100%;\r\n}\r\n```\r\n\r\n10. 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格\r\n```js\r\n// 可以通过正则去掉\r\nthis.value = this.value.replace(/\\u2006/g,\'\');\r\n```\r\n\r\n\r\n## 安卓\r\n1. 移动端字体小于12px使用四周边框或者背景色块，安卓文字偏上bug问题，可以使用整体放大1倍再缩放，而且字体不要是奇数\r\n2. 忽略Android平台中对邮箱地址的识别\r\n```html\r\n<meta name=\"format-detection\" content=\"email=no\" />\r\n```\r\n3. 某些Android手机圆角失效\r\n```cs\r\nbackground-clip: padding-box;\r\n```\r\n\r\n4. android下取消输入语音按钮\r\n```css\r\ninput::-webkit-input-speech-button {display: none}\r\n```\r\n5. 移动端字体小于12px使用四周边框或者背景色块，安卓文字偏上bug问题，可以使用整体放大1倍再缩放，而且字体不要是奇数\r\n","timestamp":1585877701769},{"name":"04-优化.md","path":"001-前端/07-HTML & CSS/005-全端高级/04-优化.md","content":"# 优化\r\n### 清理 HTML 文档\r\n1. 恰当放置 CSS\r\n> 把css外部文件引入的时候放入到head标签中，这并没有提升页面的加载速度，但是它不会让访问者长时间看着空白屏幕或者无格式的文本（FOUT）等待。如果网页大部分可见元素已经加载出来了，访问者才更有可能等待加载整个页面，从而带来对前端的优化效果。这就是知觉性能。\r\n\r\n2. 语义化HTML：好处在于可以使代码简洁清晰，支持不同设备，利于搜索引擎，便于团队开发\r\n\r\n4. 使用外部的CSS\r\n> 内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。\r\n\r\n5. 尽量少用iframe\r\n6. 尽量少用Table来布局。\r\n7. 避免使用来添加水平线，可使用CSS的border-bottom 来代替。\r\n8. 给图片加上正确的宽高值：这可以减少页面重绘，同时防止图片缩放\r\n9. 防止src属性和link的href属性为空：当值为空时，浏览器很可能会把当前页面当成其属性值加载\r\n\r\n\r\n### 优化css性能\r\n1. 不要使用@import 指令 来引入外部样式表。这是一个过时的方法，它会阻止浏览并行下载。link 标签才是最好的选择，它也能提高网站的前端性能\r\n2. 浏览器时从右向左匹配选择符的，所以我们把权重大的选择器放在后面\r\n3. 尽量避免后代选择器   （通常后代选择器是开销最高的，如果可以，请使用子选择器代替。）\r\n4. 依靠继承\r\n6. 属性缩写\r\n5. 减少查询层级和减少查询范围\r\n6. 避免使用 CSS Filter（CSS滤镜）\r\n7. 不要使用通配符\r\n8. 避免使用后代选择器,少用子选择器\r\n\r\n### 减少外部HTTP请求\r\n消除任何影响访问者体验不好的成分。这些成分可能是：\r\n* 不必要的图片\r\n     * 图片地图：点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。\r\n     ```\r\n     <img src=\"planets.jpg\" border=\"0\" usemap=\"#planetmap\" alt=\"Planets\" />\r\n    <map name=\"planetmap\" id=\"planetmap\">\r\n         <area shape=\"rect\" coords=\"180,139,14\" href =\"venus.html\" alt=\"Venus\" />\r\n         <area shape=\"rect\" coords=\"129,161,10\" href =\"mercur.html\" alt=\"Mercury\" />\r\n         <area shape=\"rect\" coords=\"0,0,110,260\" href =\"sun.html\" alt=\"Sun\" />\r\n         <area shape=\"rect\" coords=\"140,0,110,260\" href =\"star.html\" alt=\"Sun\" />\r\n    </map>\r\n    使用图片地图的缺点：指定坐标区域时，矩形或圆形比较容易指定，而其它形状手工指定比较难\r\n     ```\r\n     * 图片精灵：多个图片合成一张图片，然后通过设置背景图片，设置background-position来显示想要显示的图片（使用CSS Sprites还有可能降低下载量，可能大家会认为合并后的图片会比分离图片的总和要大，因为还有可能会附加空白区域。实际上，合并后的图片会比分离的图片总和要小，因为它降低了图片自身的开销，譬如颜色表、格式信息等。）\r\n     * 字体图标\r\n* 过多的 css\r\n     * #ffffff ->#fff      0px ->0      尽量使用缩写    padding-top:10px;padding-left:10px;padding-bottom:10px;padding-right:10px; => padding:10px;\r\n     * 合并相同的类\r\n     * 移除不使用的类\r\n     * 除了移除空白、注释之外\r\n* 多余的插件\r\n* 合并样式表   \r\n    将多个样式表合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。\r\n然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。\r\n\r\n### 压缩 CSS 和 HTML\r\n\r\n### 压缩文件（图片等）\r\n\r\n### 重绘(repaint)与回流(reflow)   （回流必将引起重绘，而重绘不一定会引起回流。）\r\n回流何时发生：\r\n当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：\r\n1. 添加或者删除可见的DOM元素；\r\n2. 元素位置改变；\r\n3. 尺寸改变——边距、填充、边框、宽度和高度;\r\n4. 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；\r\n5. 页面渲染初始化；\r\n6. 浏览器窗口尺寸改变——resize事件发生时；\r\n\r\n#### 减少重绘和回流\r\n>减少回流、重绘就是需要减少对render tree的操作，并减少对一些style信息的请求，合理利用浏览器优化策略。有一下方法：\r\n\r\n1. 直接改变className，如果动态改变样式，使用cssText(减少设置多项内联样式)\r\n2. 让要操作的元素进行“离线处理”，处理完后一起更新\r\n     * 当用DocumentFragment进行缓存操作，引发一次回流和重绘\r\n     * 使用display:none技术，只引发两次回流和重绘\r\n     * 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘\r\n3. 不要经常访问会引起浏览器flush队列的属性，确实要访问，利用缓存\r\n4. 让元素脱离动画流，减少render tree的规模，动画效果应用position属性的fixed值或absolute值\r\n5. 尽可能在DOM树的最末端改变class，尽可能在DOM树的里面改变class（可以限制回流的范围）\r\n6. 牺牲平滑度换区速度\r\n7. 避免使用table布局\r\n8. IE中避免使用JavaScript表达式\r\n","timestamp":1585877701769},{"name":"05-前端SEO优化.md","path":"001-前端/07-HTML & CSS/005-全端高级/05-前端SEO优化.md","content":"## SEO  (搜索引擎优化)\r\n> SEO（Search Engine n. ，译为搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，为网站提供生态式的自我营销解决方案，让其在行业内占据领先地位，获得品牌收益\r\n\r\nSEO包含`站外SEO`和`站内SEO`两方面：\r\n\r\n### 站内SEO\r\n1. meta标签优化：例如：`title`，`ketwords`，`description`等的优化；\r\n2. 内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接；\r\n3. 网站内容更新：每天保持站内的更新(主要是文章的更新等)。\r\n\r\n### 站外SEO\r\n1. 外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性；\r\n2. 外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升；\r\n3. 外链选择：与一些和你网站相关性比较高,整体质量比较好的网站交换友情链接,巩固稳定关键词排名。\r\n\r\n\r\n在编写HTML页面时，主要考虑的是`站内SEO`优化，具体做法如下： \r\n\r\n#### 1. 网站url\r\n1. 尽量不在url中放置session id、统计代码等不必要的内容\r\n2. 错误的url需跳转到404页面\r\n\r\n#### 2. title信息\r\n> 搜索引擎在判断一个网页内容权重时，`title`是主要参考信息之一，网页的`title`用于告诉用户和搜索引擎这个网页的主要内容是什么，而且当用户在百度网页搜索中搜索到你的网页时，`title`会作为最重要的内容显示在摘要中\r\n\r\ntitle中要包含：\r\n1. 首页：网站名称 或者 网站名称_提供服务介绍or产品介绍 。\r\n2. 频道页：频道名称_网站名称。\r\n3. 文章页：文章title_频道名称_网站名称。\r\n\r\n\r\n#### 3. meta信息\r\n必须在网页`<head>`中添加`description`内容摘要以及`keywords`关键字 ： \r\n\r\n* 网站简介： `<meta name=\"description\" content=\"xxxxxxxxxxxxxxxxxxxxxxxxxx\">`\r\n* 搜索关键字： `<meta name=\"keywords\" content=\"xxxx,xxxx,xxx,xxxxx,xxxx,\">`\r\n\r\n\r\n`keywords`主要作用是告诉搜索引擎本页内容是围绕哪些词展开的，因此`keywords`的每个词都要能在内容中找到相应匹配，才有利于排名。`keywords`一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。\r\n\r\n1. 首页keywords写法: 一般是“网站名称,主要栏目名,主要关键词”。\r\n2. 栏目页keywords写法: 一般是“栏目名称,栏目关键字,栏目分类列表名称”。\r\n3. 分类列表页keywords写法: 这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。\r\n4. 文章页keywords写法: 建议大家提取文章中的关键词，\r\n\r\n`description`也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而`description`则是完整的一句话。`description`一般不超过150个字符，描述内容要和页面内容相关。\r\n\r\n1. 首页description写法: 一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。\r\n2. 栏目页description写法: 一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。\r\n3. 分类列表页description: 一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。\r\n4. 文章页description写法: 一般将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。 或者可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。\r\n\r\n\r\n#### 图片alt\r\n```html\r\n<img src=\"\" alt=\"前端开发\">\r\n```\r\n\r\n由于图片无法被搜索引擎检索，所以为图片加alt说明能让搜索引擎了解图片的内容。同理，使用图片做导航时，也可以使用alt注释，用alt告诉搜索引擎所指向的网页内容是什么。\r\n\r\n\r\n#### iframe框架\r\n不建议使用iframe框架结构，通过iframe显示的内容可能会被百度丢弃。","timestamp":1585877701769},{"name":"01-github简介.md","path":"001-前端/07-HTML & CSS/006-附录/01-Git与Github使用指南/01-github简介.md","content":"# github简介  \r\n## 什么是github  \r\n\r\n很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？  \r\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！   \r\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。  \r\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。  \r\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。  \r\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：  \r\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。  \r\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了（github是一个基于git的代码托管平台，付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。），它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。  \r\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\r\nGitHub是2008年由Ruby on Rails编写而成。GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。    \r\n1.github是一个基于git的web 协作社区，它有多种机制让大家协同的和你一起的对项目进行贡献。  \r\n2.github全平台、全设备支持，你可以在任何终端上，随时随地的共享你的代码、评论或着其他有意义的信息。  \r\n3.它是这个世界上最大的开源软件社区。  \r\n## github有什么用  \r\n1.代码托管  \r\n就是我们做的最多的，上传代码，云端备份，可以想象成一个云盘。  \r\n2.项目管理    \r\nGitHub最初是为了开发的管理而生，当然也就具备了项目管理的潜质，特别是与开发密切联系的项目中，它的优势尽显。    \r\n3.Github Pages  \r\n可以为项目建立静态主页(即gh-pages分支), 就是可以搭建个人网站。  \r\n4.个人简历，找工作，面试加分。    \r\n一个好的github可以为面试加不少分，让你赢在起跑线上。而且现在越来越多知名公司活跃在GitHub，发布开源库并招募各类人才     \r\n##   git与github的不同    \r\n![嵌套](amWiki/images/git1.jpg)  \r\nGit是版本控制系统，Github是在线的基于Git的代码托管服务。  \r\nGitHub是2008年由Ruby on Rails编写而成。GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。    \r\n","timestamp":1585877701769},{"name":"02-github使用指南.md","path":"001-前端/07-HTML & CSS/006-附录/01-Git与Github使用指南/02-github使用指南.md","content":"##  github网站中的页面内容信息解释  \r\n![git2](amWiki/images/git2.png)  \r\n1.  LOGO：点击 GitHub 的 LOGO 就进入控制面板  \r\n2.  Searth：搜索窗口，在这里输入想找的用户或代码片段，就可以搜索到与之相关的信息。可以寻找查看各大开源项目  \r\n3.  Pull Requests：显示用户已进行过的 Pull Request。通过这里，开发者可以很方便地追踪 Pull Request 的后续情况。  \r\n4.  Issues：在这里可以查看用户拥有权限的仓库或分配给自己的Issue。当用户同时进行多个项目时，可以在这里一并查看 Issue  \r\n5.  Marketplace：向开发者提供工具改进和定制工作流。  \r\n6.  Gist：Gist功能主要用于管理及发布一些没必要保存在仓库中的代码，比如小的代码片段等。笔者就经常把一些随便编写的脚本代码等放在 Gist中。系统会自动管理更新历史，并且提供了 Fork 功能。另外，通过 Gist 还可以很方便地为同事编写代码示例。  \r\n7.  Create a new：创建 respository，gist，organization  \r\n8.  用户信息：点击后会显示用户的个人信息页面  \r\n\r\n    \r\n![git2](amWiki/images/git3.png)  \r\n\r\n1.  Watch/ Start/ Fork\r\n眼睛图标旁边写着 Watch 字样。点击这个按钮就可以 Watch 该仓库，今后该仓库的更新信息会显示在用户的公开活动中。  \r\nStar 旁边的数字表示给这个仓库添加Star 的人数。这个数越高，代表该仓库越受关注。  \r\nWatch 与Star 有所不同，Watch 之后该仓库的相关信息会在后述Notifications 中显示，让用户可以追踪仓库的内容  \r\nStar 更像是书签，让用户将来可以在Star 标记的列表中找到该仓库。另外，Star 数还 GitHub 上判断仓库热门程度的指标之一。  \r\n旁边的分叉图标是 Fork 按钮，后面的数字代表该仓库被 Fork 至各用户仓库的次数。这个数字越大，表示参与这个仓库开发的人越多。  \r\n2.  Code  \r\n显示该仓库中的文件列表。仓库名下方是该仓库的简单说明  \r\n3.  Issues  \r\n用于 BUG 报告、功能添加、方向性讨论等，将这些以 Issue 形式进行管理。Pull Request 时也会创建 Issue。旁边显示的数字是当前处于 Open 状态的Issue数。  \r\n4.  Pull requests  \r\n在 Pull Requests 中可以列表查看并管理 Pull Request 。代码的更改和讨论都可以在这里进行。旁边显示的数字表示尚未 Close 的 Pull Request  \r\n5.  Wiki  \r\nWiki是一种比 HTML 语法更简单的页面描述功能。常用于记录开发者之间应该共享的信息或软件文档。数字表示当前Wiki的页面数量。  \r\n6.  Setting  \r\n点击它可以打开账户设置页面。在这里可以进行个人信息、安全管理、付费方案的设置，在使用 GitHub 时请务必浏览一遍  \r\n7.  Insights    \r\nPulse: 显示该仓库最近的活动信息。该仓库中的软件是无人问津，还是在火热地开发之中，从这里可以一目了然。Graphs：以图表形式显示该仓库的各项指标。让用户轻松了解该仓库的活动  \r\n8.  commits  \r\n在这里可以查看当前分支的提交历史。左侧的数字表示提交数。  \r\n9. branches  \r\n可以查看仓库的分支列表。左侧的数字表示当前拥有的分支数。   \r\n10. releases  \r\n显示仓库的标签（Tag）列表。同时可以将标签加入时的文件以归  \r\n11.  contributors  \r\n显示对该仓库进行过提交的程序员名单。如果您也对该仓库发送过 Pull Request 并且被采纳，那么在这里就能找到自己的名字。左边的数字是程序员的人数。  \r\n注意：README。一般而言，README 中记录着该仓库中软件的说明或使用方法以及许可协议等信息，请务必加以阅读。    \r\n","timestamp":1585877701769},{"name":"03-git的安装.md","path":"001-前端/07-HTML & CSS/006-附录/01-Git与Github使用指南/03-git的安装.md","content":"# git的安装  \r\n\r\n## 一. git的下载  \r\n请到git的官网上直接下载，下面是官网地址和跳转链接：  \r\n\r\nhttp://git-scm.com/download/    \r\n[点击这里可以直接跳转到git下载页面](http://git-scm.com/download/)   \r\n\r\n## 二. 测试笔记本是否安装git\r\n\r\n1.使用WIN+R快捷键，输入cmd，回车，打开Dos命令行；  \r\n2.输入git或者git --version，回车；  \r\n![git安装教程](amWiki/images/git11.png)   \r\n注意：上图说明该笔记本上未配置git  \r\n\r\n## 三. git的安装  \r\n1. 下载好git安装包之后，直接双击安装，点击next  \r\n![git安装教程](amWiki/images/git12.png)  \r\n2. 安装的路径，默认是在C盘，你也可以自定义路径；  \r\n![git安装教程](amWiki/images/git13.png)  \r\n3. 点击下一步，这些是默认勾选的，如果你不需要Git Bash Here和Git GUI Here，可以不勾选这两项；  \r\n![git安装教程](amWiki/images/git14.png)  \r\n4. 默认文件夹为Git，建议不要修改，点击下一步；  \r\n![git安装教程](amWiki/images/git15.png)  \r\n5. 如果用于普通使用，勾选第一项；如果个人使用，可勾选第二项；  \r\n![git安装教程](amWiki/images/git16.png)  \r\n6. 默认勾选第一项；  \r\n![git安装教程](amWiki/images/git17.png)  \r\n7. 默认勾选第一项；  \r\n![git安装教程](amWiki/images/git18.png)  \r\n8. 默认勾选第一项，点击next；  \r\n![git安装教程](amWiki/images/git19.png)  \r\n9. 默认勾选第一项，点击Install，进行安装；  \r\n![git安装教程](amWiki/images/git20.png)   \r\n10. 等待安装完成；  \r\n![git安装教程](amWiki/images/git21.png)  \r\n\r\n## 四. 接下来进行git的环境变量配置  \r\n1. 找到Git文件夹，进入到cmd文件夹目录下，复制该文件路径；\r\n以我的地址为例：C:\\Program Files\\Git\\cmd；  \r\n![git安装教程](amWiki/images/git22.png)     \r\n注意：路径一定要到cmd这个文件夹下；  \r\n2.  右键我的电脑>点击属性>点击高级系统设置  \r\n\r\n  * 进入系统属性>点击高级>选中系统变量下的Path点击编辑>将刚才复制的路径粘贴到变量值后面>点击确定>确定>确定即可；   \r\n  * 以我的为例：追加;C:\\Program Files\\Git\\cmd;  \r\n注意：  \r\n  - 在添加Path路径时，如果之前变量值的末尾以英文分号结尾，可以直接添加，否则一定记得先添加添加英文分号，再追加新增的变量值；  \r\n  - 也可以养成这样的习惯，每次添加新的变量值之后都以英文分号结尾；  \r\n  ![git安装教程](amWiki/images/git23.png)  \r\n\r\n# 五. 测试git环境是否配好  \r\n1. 记得重新打开cmd，输入git命令即可，如下图说明配置成功；  \r\n![git安装教程](amWiki/images/git24.png)  \r\n> 一定要重新打开cmd，不然之前打开的cmd还是找不到git;  \r\n\r\n2. 或者输入git --version，如下所示说明配置成功；  \r\n![git安装教程](amWiki/images/git25.png)  \r\n注意： 输入git -v或者git -version都是无效命令，git --version才有效！！！    \r\n![git安装教程](amWiki/images/git26.png)   \r\n","timestamp":1585877701769},{"name":"04-git的使用说明.md","path":"001-前端/07-HTML & CSS/006-附录/01-Git与Github使用指南/04-git的使用说明.md","content":"# 1. 创建版本库   \r\n## 1.1版本库  \r\n版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。所以创建一个版本库也非常简单，如下我是E盘 目录下新建一个testgit版本库。  \r\n  >$ cd E:(找到E盘)\r\n  $ cd www(假如在www文件夹下)  \r\n  $ mkdir testgit（新建名叫testgit的文件夹）  \r\n  $ cd testgit（找到testgit文件夹）  \r\n  $ pwd （显示当前目录）  \r\n  /e/testgit  \r\n\r\npwd命令用于显示当前目录。在我的电脑上，这个仓库位于/e/testgit  \r\n如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。  \r\n\r\n第二步，通过git init命令把这个目录变成Git可以管理的仓库：  \r\n  >$ git init  \r\n  Initialized empty Git repository in E:/testgit/.git/  \r\n\r\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。  \r\n如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。  \r\n也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。  \r\n以上全部步骤在git上操作如下图：  \r\n![git使用说明图](amWiki/images/git31.png)  \r\n电脑磁盘下的.git    \r\n![git使用说明图](amWiki/images/git32.png)  \r\n## 1.2 把文件添加到版本库中    \r\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。  \r\n\r\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。  \r\n\r\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。  \r\n\r\n演示demo:  \r\n我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：`Git is a version control system`。    \r\n\r\n一定要放到testgit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。  \r\n\r\n<b>第一步，用命令git add告诉Git，把文件添加到仓库：</b>  \r\n`$ git add readme.txt`  \r\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。    \r\n\r\n<b>第二步，用命令git commit告诉Git，把文件提交到仓库：</b>  \r\n  >$ git commit -m \"wrote a readme file\"  \r\n  [master (root-commit) cb926e7] wrote a readme file  \r\n   1 file changed, 2 insertions(+)     \r\n   create mode 100644 readme.txt  \r\n\r\n如下图：  \r\n![git使用说明图](amWiki/images/git33.png)  \r\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。  \r\n嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。  \r\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。  \r\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：  \r\n> $ git add file1.txt  \r\n  $ git add file2.txt file3.txt  \r\n  $ git commit -m \"add 3 files.\"  \r\n\r\n<b>小结:</b>  \r\n初始化一个Git仓库，使用git init命令。  \r\n添加文件到Git仓库，分两步：  \r\n第一步，使用命令git add <file>，注意，可反复多次使用，添加多个文件；  \r\n第二步，使用命令git commit，完成。  \r\n现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：  \r\n![git使用说明图](amWiki/images/git34.png)  \r\n说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行123456内容，继续使用git status来查看下结果，如下：  \r\n![git使用说明图](amWiki/images/git35.png)  \r\n上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。  \r\n接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：  \r\ngit diff readme.txt 如下：  \r\n![git使用说明图](amWiki/images/git36.png)  \r\ngit diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式.  \r\n如上可以看到，readme.txt文件内容从两行Git is a version control system.Git is free software.改成 二行 添加了一行123456内容。  \r\n知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit。)  \r\n<b>小结:</b>  \r\n要随时掌握工作区的状态，使用git status命令。  \r\n如果`git status`告诉你有文件被修改过，用git diff可以查看修改内容。   \r\n![git使用说明图](amWiki/images/git37.png)   \r\n# 2.操作追踪  \r\n## 2.1 版本回退  \r\n如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再修改一次内容为：  \r\nGit is a distributed version control system.  \r\nGit is free software distributed under the GPL.  \r\n继续执行命令如下：  \r\n> $ git add readme.txt  \r\n$ git commit -m \"append GPL\"  \r\n[master 3628164] append GPL  \r\n 1 file changed, 1 insertion(+), 1 deletion(-)  \r\n\r\n 不断对文件进行修改，然后不断提交修改到版本库里，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。  \r\n现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log演示如下所示：  \r\n![git使用说明图](amWiki/images/git38.png)   \r\n`git log`命令显示从最近到最远的提交日志，我们可以看到2次提交，最近的一次是`append GPL`，最早的一次是wrote a readme file。.如果嫌上面显示的信息太多的话，我们可以使用命令 `git log –pretty=oneline` 演示如下：  \r\n![git使用说明图](amWiki/images/git39.png)  \r\n需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。  \r\n\r\n现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset  –hard HEAD^那么如果要回退到上上个版本只需把HEAD^改成 HEAD^^以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  –hard HEAD~100即可。  \r\n未回退之前的readme.txt内容如下：   \r\n![git使用说明图](amWiki/images/git40.png)  \r\n如果想回退到上一个版本就可以使用`git reset`命令：\r\n> $ git reset --hard HEAD^  \r\n\r\n再来查看下 readme.txt内容，通过命令cat readme.txt查看  \r\n最后我们用git log再看看现在版本库的状态。  \r\n![git使用说明图](amWiki/images/git41.png)  \r\n现在我想回退到最新的版本:只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是fc632000db...，于是就可以指定回到未来的某个版本：  \r\n>$ git reset --hard fc632000db\r\nHEAD is now at fc632000db append GPL  \r\n\r\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。  \r\n再看看readme.txt的内容：  \r\n![git使用说明图](amWiki/images/git42.png)  \r\n果然，我胡汉三又回来了。  \r\nGit的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL.\r\n假如我已经关掉过一次命令行或者commit id内容的版本号我并不知道呢？要如何知道commit id内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：  \r\n![git使用说明图](amWiki/images/git43.png)  \r\n`git reflog`用来记录你的每一次命令.  \r\n\r\n<b>小结:</b>   \r\n1. HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。  \r\n2. 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。  \r\n3. 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。  \r\n## 2.2 工作区与暂存区的区别  \r\n<b>工作区</b>：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。  \r\n\r\n<b>版本库(Repository)</b>：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。  \r\n\r\n我们前面说过使用Git提交文件到版本库有两步：  \r\n\r\n第一步：是使用 `git add` 把文件添加进去，实际上就是把文件添加到暂存区。  \r\n\r\n第二步：使用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支上。  \r\n\r\n  因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，`git commit`就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。    \r\n现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：  \r\nGit is a distributed version control system.  \r\nGit is free software distributed under the GPL.  \r\nGit has a mutable index called stage.  \r\n接着在目录下新建一个文件为test.txt 内容为test  \r\n先用`git status`查看一下状态：  \r\n![git使用说明图](amWiki/images/git44.png)  \r\nGit非常清楚地告诉我们，readme.txt被修改了，而test还从来没有被添加过，所以它的状态是Untracked。  \r\n现在我们先使用`git add `命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：    \r\n![git使用说明图](amWiki/images/git45.png)  \r\n接着我们可以使用`git commit`一次性提交到分支上，如下：  \r\n![git使用说明图](amWiki/images/git46.png)  \r\n<b>小结:</b>  \r\n* 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。  \r\n* 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。    \r\n## 2.3 Git管理修改操作  \r\nGit比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。  \r\n为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：  \r\nGit is a distributed version control system.  \r\nGit is free software distributed under the GPL.  \r\nGit has a mutable index called stage.   \r\nGit tracks changes.  \r\n查看readme.txt内容：  \r\n![git使用说明图](amWiki/images/git47.png)   \r\n然后，添加：  \r\n![git使用说明图](amWiki/images/git48.png)   \r\n然后，再修改readme.txt：  \r\n![git使用说明图](amWiki/images/git49.png)   \r\n提交后，然后查看状态：  \r\n![git使用说明图](amWiki/images/git50.png)   \r\n我们回顾一下操作过程：  \r\n第一次修改 -> git add -> 第二次修改 -> git commit  \r\n你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。  \r\n提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别：  \r\n![git使用说明图](amWiki/images/git51.png)   \r\n![git使用说明图](amWiki/images/git52.png)   \r\n可见，第二次修改确实没有被提交。  \r\n那怎么提交第二次修改呢？你可以继续`git add`再`git commit`，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：  \r\n第一次修改 -> `git add` -> 第二次修改 -> `git add` -> `git commit`  \r\n好，现在，把第二次修改提交了。  \r\n<b>小结:</b>  \r\n现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。  \r\n## 2.4 Git撤销修改和删除文件操作  \r\n### 3.4.1 撤销修改  \r\n比如我现在在readme.txt文件里面增加一行 内容为My stupid boss still prefers SVN.我们先通过命令查看如下：\r\n![git使用说明图](amWiki/images/git53.png)   \r\n在准备提交前，发现My stupid boss still prefers SVN这句话有错误，想恢复上一个版本的状态，有如下几种方法可以做修改：  \r\n1. 如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。  \r\n2. 我可以按以前的方法直接恢复到上一个版本。使用`git reset  –hard HEAD^`  \r\n但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status查看下当前的状态。如下所示：  \r\n![git使用说明图](amWiki/images/git54.png)   \r\n可以发现，Git会告诉你，`git checkout — file` 可以丢弃工作区的修改，如下命令：  \r\n`git checkout  —  readme.txt`,如下所示：  \r\n![git使用说明图](amWiki/images/git55.png)   \r\n命令 `git checkout –readme.txt `意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：  \r\n1. readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。  \r\n2. 另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。  \r\n假如你不但写错了，还git add到暂存区了。    \r\n对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为My stupid boss still prefers SVN.    我git add 增加到暂存区后，接着添加内容good jop see you，我想通过撤销命令让其回到暂存区后的状态。如下所示：  \r\n![git使用说明图](amWiki/images/git56.png)     \r\n<b>注意：</b> 命令`git checkout -- readme.txt` 中的-- 很重要，如果没有--的话，那么命令变成创建分支了。  \r\n在commit之前。用git status查看一下，修改只是添加到了暂存区，还没有提交 ,并且Git还告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：  \r\n![git使用说明图](amWiki/images/git57.png)     \r\n`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。  \r\n再用`git status`查看一下，现在暂存区是干净的，工作区有修改：  \r\n![git使用说明图](amWiki/images/git58.png)      \r\n下面，我们再丢弃工作区的修改：  \r\n![git使用说明图](amWiki/images/git59.png)      \r\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……    \r\n<b>小结：</b>   \r\n1. 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。  \r\n2. 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。  \r\n3. 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。  \r\n### 2.4.2 删除文件  \r\n假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：  \r\n![git使用说明图](amWiki/images/git60.png)      \r\n如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的:  \r\n![git使用说明图](amWiki/images/git61.png)      \r\n可以使用如下命令` git checkout — b.txt`，如下所示  ：\r\n只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？  \r\n![git使用说明图](amWiki/images/git62.png)     \r\n再来看看我们testgit目录，添加了1个文件了。如下所示：  \r\n![git使用说明图](amWiki/images/git63.png)     \r\n# 3. 远程仓库\r\n在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：  \r\n>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：  \r\nssh-keygen  -t rsa –C \"youremail@example.com\", 你需要把邮件地址换成你自己的邮件地址,并且必须要用双引号，不能用单引号。然后一路回车，使用默认值即可。由于我本地此前运行过一次，所以本地有，如下所示：  \r\n![git使用说明图](amWiki/images/git64.png)     \r\nid_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。  \r\n第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。点击 Add Key，你就应该可以看到已经添加的key。  \r\n![git使用说明图](amWiki/images/git65.png)      \r\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。    \r\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。   \r\n    \r\n","timestamp":1585877701769},{"name":"05-git常用命令总结.md","path":"001-前端/07-HTML & CSS/006-附录/01-Git与Github使用指南/05-git常用命令总结.md","content":"## 配置\r\n\r\n### 首先是配置帐号信息\r\n\r\n>ssh -T git@github.com#登陆github  \r\n修改项目中的个人信息  \r\n$ git config --global user.name \"wirelessqa\"  \r\n$ git config --global user.email wirelessqa.me@gmail.com  \r\n\r\n### config\r\n\r\n>git config --global user.name JSLite#设置提交用户名  \r\ngit config --global user.email JSLite@yeah.net#设置提交邮箱  \r\ngit config --list#查看配置的信息  \r\ngit remote remove origin#删除该远程路径  \r\ngit remote add origin git@jslite.github.com:JSLite/JSLite.git#添加远程路径  \r\n\r\n### help  \r\n\r\n>git help config#获取帮助信息    \r\n\r\n### 配置自动换行（自动转换坑太大）   \r\n\r\n>git config --global core.autocrlf input#提交到git是自动将换行符转换为lf  \r\n\r\n### 配置密钥\r\n\r\n>ssh-keygen -t rsa -C JSLite@yeah.net#生成密钥  \r\nssh -T git@github.com#测试是否成功  \r\n\r\n### 多账号ssh配置  \r\n\r\n#### 1.生成指定名字的密钥  \r\n\r\n>ssh-keygen -t rsa -C \"邮箱地址\" -f ~/.ssh/github_jslite\r\n会生成github_jslite和github_jslite.pub这两个文件  \r\n\r\n#### 2.密钥复制到托管平台上  \r\n>vim ~/.ssh/github_jslite.pub  \r\n打开公钥文件github_jslite.pub，并把内容复制至代码托管平台上  \r\n\r\n#### 3.修改config文件  \r\n\r\n>vim ~/.ssh/config#修改config文件，如果没有创建config  \r\nHost jslite.github.com  \r\nHostName github.com   \r\nUser git  \r\nIdentityFile ~/.ssh/github_jslite  \r\nHost abc.github.com   \r\nHostName github.com  \r\nUser git  \r\nIdentityFile ~/.ssh/github_abc  \r\n\r\n#### 4.测试  \r\n>ssh -T git@jslite.github.com#@后面跟上定义的Host  \r\n\r\n### Git推向3个库\r\n\r\n#### 增加3个远程库地址\r\n\r\n>git remote add origin https://github.com/JSLite/JSLite.git  \r\ngit remote set-url --add origin https://gitlab.com/wang/JSLite.js.git  \r\ngit remote set-url --add origin https://oschina.net/wang/JSLite.js.git  \r\n\r\n#### 删除其中一个 set-url 地址\r\n\r\n>usage: git remote set-url [--push][] or: git remote set-url --addor: git remote set-url --delete  \r\ngit remote set-url --delete origin https://oschina.net/wang/JSLite.js.git  \r\n\r\n#### push\r\n\r\n>git push origin master  \r\ngit push -f origin master#强制推送   \r\n\r\n缩写 -f  \r\n全写--force    \r\n注：强制推送文件没有了哦  \r\n\r\n#### pull  \r\n\r\n>只能拉取origin里的一个url地址，这个fetch-url  \r\n默认为你添加的到origin的第一个地址  \r\ngit pull origin master  \r\ngit pull --all#获取远程所有内容包括tag  \r\ngit pull origin next:master#取回origin主机的next分支，与本地的master分支合并  \r\ngit pull origin next#远程分支是与当前分支合并  \r\n\r\n上面一条命令等同于下面两条命令   \r\n\r\n>git fetch origin  \r\ngit merge origin/next  \r\n\r\n如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。    \r\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。  \r\n\r\n>$ git pull -p  \r\n\r\n#### 等同于下面的命令\r\n\r\n>$ git fetch --prune origin  \r\n$ git fetch -p  \r\n\r\n更改pull  \r\n\r\n只需要更改config文件里，那三个url的顺序即可，fetch-url会直接对应排行第一的那个utl连接。  \r\n\r\n### 新建仓库    \r\n\r\n#### init  \r\n\r\n>git init#初始化  \r\n\r\n#### status  \r\n\r\n>git status#获取状态  \r\n\r\n#### add  \r\n\r\n>git add file#.或*代表全部添加  \r\ngit rm --cached 在commit之前撤销git add操作  \r\ngit reset head好像比上面git rm --cached更方便  \r\n\r\n#### commit  \r\n\r\n>git commit -m \"message\"#此处注意乱码  \r\n\r\n#### remote\r\n\r\n>git remote add origin git@github.com:JSLite/test.git#添加源  \r\n\r\n#### push  \r\n\r\n>git push -u origin master#push同事设置默认跟踪分支  \r\ngit push origin master\r\n\r\n#### 从现有仓库克隆  \r\n\r\n>git clone git://github.com/JSLite/JSLite.js.git  \r\ngit clone git://github.com/JSLite/JSLite.js.git mypro#克隆到自定义文件夹  \r\ngit clone [user@]example.com:path/to/repo.git/#SSH协议还有另一种写法。  \r\ngit clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。$ git clone <版本库的网址> <本地目录名>  \r\n$ git clone http[s]://example.com/path/to/repo.git/  \r\n$ git clone ssh://example.com/path/to/repo.git/  \r\n$ git clone git://example.com/path/to/repo.git/  \r\n$ git clone /opt/git/project.git    \r\n$ git clone file:///opt/git/project.git   \r\n$ git clone ftp[s]://example.com/path/to/repo.git/   \r\n$ git clone rsync://example.com/path/to/repo.git/  \r\n\r\n#### submodule\r\n\r\n>git submodule add --force 仓库地址 路径  \r\n其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。  \r\n\r\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）  \r\n\r\n>git submodule init初始化submodule  \r\ngit submodule update更新submodule(必须在根目录执行命令)  \r\n\r\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：  \r\n\r\n>git submodule update --init --recursive下载的工程带有submodule  \r\ngit submodule foreach git pullsubmodule 里有其他的 submodule 一次更新  \r\ngit submodule foreach git pull origin mastersubmodule更新  \r\ngit submodule foreach --recursive git submodule init   \r\ngit submodule foreach --recursive git submodule update  \r\n\r\n#### 本地  \r\n\r\n>add  \r\ngit add * #跟踪新文件  \r\ngit add -u [path]#添加[指定路径下]已跟踪文件  \r\n\r\n##### rm    \r\n\r\n>rm &git rm #移除文件  \r\ngit rm -f *  #移除文件    \r\ngit rm --cached * #取消跟踪    \r\ngit mv file_from file_to#重命名跟踪文件  \r\ngit log#查看提交记录  \r\n\r\n#### commit  \r\n\r\n>git commit#提交更新\r\ngit commit -m \'message\'#提交说明  \r\ngit commit -a#跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交  \r\ngit commit --amend#修改最后一次提交  \r\ngit commit log#查看所有提交，包括没有push的commit  \r\ngit commit -m \"#133\"#关联issue 任意位置带上#符号加上issue号码  \r\ngit commit -m \"fix #133\"commit关闭issue  \r\ngit commit -m \'概要描述\'$\'\\n\\n\'\'1.详细描述\'$\'\\n\'\'2.详细描述\'#提交简要描述和详细描述  \r\n\r\n#### reset  \r\n\r\n>git reset HEAD*#取消已经暂存的文件  \r\ngit reset --mixed HEAD*#同上   \r\ngit reset --soft HEAD*#重置到指定状态，不会修改索引区和工作树  \r\ngit reset --hard HEAD*#重置到指定状态，会修改索引区和工作树  \r\ngit reset -- files*#重置index区文件  \r\n\r\n那么如何跟随着commit关闭一个issue呢? 在confirm merge的时候可以使用一下命令来关闭相关issue:\r\n\r\n>fixes #xxx  \r\nfixed #xxx  \r\nfix #xxx   \r\ncloses #xxx  \r\nclose #xxx  \r\nclosed #xxx  \r\n\r\n#### revert   \r\n\r\n>git revert HEAD#撤销前一次操作  \r\ngit revert HEAD~#撤销前前一次操作  \r\ngit revert commit##撤销指定操作  \r\n\r\n#### checkout  \r\n\r\n>git checkout -- file#取消对文件的修改（从暂存区------覆盖worktree file）  \r\ngit checkout branch|tag|commit -- file_name#从仓库取出file覆盖当前分支  \r\ngit checkout HEAD~1 [文件]#将会更新 working directory 去匹配某次 commit  \r\ngit checkout -- .#从暂存区取出文件覆盖工作区    \r\ngit checkout -b gh-pages 0c304c9这个表示 从当前分支 commit 哈希值为 0c304c9 的节点，分一个新的分支gh-pages出来，并切换到 gh-pages  \r\n\r\n#### diff\r\n\r\n>git diff file#查看指定文件的差异  \r\ngit diff --stat#查看简单的diff结果  \r\ngit diff#比较Worktree和Index之间的差异  \r\ngit diff --cached#比较Index和HEAD之间的差异  \r\ngit diff HEAD#比较Worktree和HEAD之间的差异  \r\ngit diff branch#比较Worktree和branch之间的差异  \r\ngit diff branch1 branch2#比较两次分支之间的差异  \r\ngit diff commit commit#比较两次提交之间的差异    \r\n$ git diff master..test#上面这条命令只显示两个分支间的差异  \r\ngit diff master...test#你想找出\'master\',\'test\'的共有 父分支和\'test\'分支之间的差异，你用3个\'.\'来取代前面的两个\'.\'  \r\n\r\n#### stash  \r\n\r\n>git stash#将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。  \r\ngit stash list#查看保存的工作现场  \r\ngit stash apply#恢复工作现场  \r\ngit stash drop#删除stash内容   \r\ngit stash pop#恢复的同时直接删除stash内容  \r\ngit stash apply stash@{0}#恢复指定的工作现场，当你保存了不只一份工作现场时。  \r\n\r\n#### merge\r\n\r\n>git merge --squash test##合并压缩，将test上的commit压缩为一条  \r\n\r\n#### cherry-pick\r\n\r\n>git cherry-pick commit#拣选合并，将commit合并到当前分支    \r\ngit cherry-pick -n commit#拣选多个提交，合并完后可以继续拣选下一个提交  \r\n\r\n#### rebase\r\n\r\n>git rebase master#将master分之上超前的提交，变基到当前分支  \r\ngit rebase --onto master 169a6#限制回滚范围，rebase当前分支从169a6以后的提交  \r\ngit rebase --interactive#交互模式，修改commit  \r\ngit rebase --continue#处理完冲突继续合并  \r\ngit rebase --skip#跳过    \r\ngit rebase --abort#取消合并  \r\n\r\n### 分支branch\r\n\r\n#### 删除  \r\n\r\n>git push origin :branchName#删除远程分支  \r\ngit push origin --delete new#删除远程分支new  \r\ngit branch -d branchName#删除本地分支，强制删除用-D  \r\ngit branch -d test#删除本地test分支  \r\ngit branch -D test#强制删除本地test分支  \r\n\r\n#### 提交  \r\n\r\n>git push -u origin branchName#提交分支到远程origin主机中  \r\n\r\n#### 拉取  \r\n\r\n>git fetch -p#拉取远程分支时，自动清理 远程分支已删除，本地还存在的对应同名分支。  \r\n\r\n#### 分支合并  \r\n\r\n>git merge branchName#合并分支 - 将分支branchName和当前所在分支合并  \r\ngit merge origin/master#在本地分支上合并远程分支。  \r\ngit rebase origin/master#在本地分支上合并远程分支。  \r\ngit merge test#将test分支合并到当前分支  \r\n\r\n#### 重命名    \r\n\r\n>git branch -m old new#重命名分支  \r\n\r\n####  查看    \r\n\r\n>git branch#列出本地分支  \r\ngit branch -r#列出远端分支  \r\ngit branch -a#列出所有分支  \r\ngit branch -v#查看各个分支最后一个提交对象的信息  \r\ngit branch --merge#查看已经合并到当前分支的分支  \r\ngit branch --no-merge#查看为合并到当前分支的分支  \r\n\r\n#### 新建  \r\n\r\n>git branch test#新建test分支  \r\ngit checkout -b newBrach origin/master#取回远程主机的更新以后，在它的基础上创建一个新的分支  \r\n\r\n#### 连接  \r\n\r\n>git branch --set-upstream dev origin/dev#将本地dev分支与远程dev分支之间建立链接  \r\ngit branch --set-upstream master origin/next#手动建立追踪关系   \r\n\r\n####分支切换  \r\n\r\n>git checkout test#切换到test分支  \r\ngit checkout -b test#新建+切换到test分支  \r\ngit checkout -b test dev#基于dev新建test分支，并切换  \r\n\r\n#### 远端  \r\n\r\n>git fetch <远程主机名> <分支名>#fetch取回所有分支（branch）的更新  \r\ngit fetch origin remotebranch[:localbranch]# 从远端拉去分支[到本地指定分支]  \r\ngit merge origin/branch#合并远端上指定分支  \r\ngit pull origin remotebranch:localbranch# 拉去远端分支到本地分支  \r\ngit push origin branch#将当前分支，推送到远端上指定分支  \r\ngit push origin localbranch:remotebranch#推送本地指定分支，到远端上指定分支  \r\ngit push origin :remotebranch#删除远端指定分支  \r\ngit checkout -b [--track] test origin/dev基于远端dev分支，新建本地test分支[同时设置跟踪]   \r\n\r\n#### 撤销远程记录\r\n\r\n>git reset --hard HEAD~1#撤销一条记录  \r\ngit push -f origin HEAD:master#同步到远程仓库  \r\n\r\n#### 忽略文件  \r\n\r\n>echo node_modules/ >> .gitignore  \r\n\r\n#### 删除文件  \r\n\r\n>git rm -rf node_modules/  \r\n\r\n#### 源remote  \r\n\r\ngit是一个分布式代码管理工具，所以可以支持多个仓库，在git里，服务器上的仓库在本地称之为remote。  \r\n个人开发时，多源用的可能不多，但多源其实非常有用。  \r\n\r\n>git remote add origin1 git@github.com:yanhaijing/data.js.git  \r\ngit remote#显示全部源  \r\ngit remote -v#显示全部源+详细信息  \r\ngit remote rename origin1 origin2#重命名  \r\ngit remote rm origin#删除    \r\ngit remote show origin#查看指定源的全部信息  \r\n\r\n### 同步一个fork\r\n\r\n#### 设置\r\n\r\n在同步之前，需要创建一个远程点指向上游仓库(repo).如果你已经派生了一个原始仓库，可以按照如下方法做。\r\n\r\n>$ git remote -v#List the current remotes （列出当前远程仓库）#origin https://github.com/user/repo.git   (fetch)#origin https://github.com/user/repo.git (push)$ git remote add upstream   https://github.com/otheruser/repo.git#Set a new remote (设置一个新的远程仓库)$ git remote -v#Verify new remote (验证新的原唱仓库)#origin https://github.com/user/repo.git (fetch)#origin https://github.com/user/repo.git   (push)#upstream https://github.com/otheruser/repo.git (fetch)#upstream https://github.com/otheruser/repo.git (push)  \r\n\r\n##### 同步  \r\n\r\n同步上游仓库到你的仓库需要执行两步：首先你需要从远程拉去，之后你需要合并你希望的分支到你的本地副本分支。  \r\n\r\n从上游的存储库中提取分支以及各自的提交内容。master将被存储在本地分支机构upstream/master  \r\n\r\n>git fetch upstream#remote: Counting objects: 75, done.#remote: Compressing objects: 100% (53/53), done.#remote: Total 62 (delta 27), reused 44 (delta 9)#Unpacking objects: 100% (62/62), done.#From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY#* [new branch] master -> upstream/master\r\n\r\n检查你的 fork\'s 本地master分支  \r\n\r\n>git checkout master#Switched to branch \'master\'  \r\n\r\n合并来自upstream/master的更改到本地 master 分支上。 这使你的前 fork\'smaster分支与上游资源库同步，而不会丢失你本地修改。  \r\n\r\n>git merge upstream/master#Updating a422352..5fdff0f#Fast-forward#README | 9 -------#README.md | 7 ++++++#2 files changed, 7 insertions(+), 9 deletions(-)#delete mode 100644 README#create mode 100644 README.md    \r\n\r\n#### 标签tag\r\n\r\n当开发到一定阶段时，给程序打标签是非常棒的功能。  \r\n\r\n>git tag#列出现有标签  \r\ngit tag v0gi.1#新建标签  \r\ngit tag -a v0.1 -m \'my version 1.4\'#新建带注释标签  \r\ngit checkout tagname#切换到标签  \r\ngit push origin v1.5#推送分支到源上  \r\ngit push origin --tags#一次性推送所有分支  \r\ngit tag -d v0.1#删除标签  \r\ngit push origin :refs/tags/v0.1#删除远程标签  \r\ngit pull --all#获取远程所有内容包括tag  \r\ngit --git-dir=\'<绝对地址>/.git\' describe --tags HEAD#查看本地版本信息    \r\n\r\n##### 日志log\r\n\r\n>git config format.pretty oneline#显示历史记录时，每个提交的信息只显示一行  \r\ngit config color.ui true#彩色的 git 输出  \r\ngit log#查看最近的提交日志  \r\ngit log --pretty=oneline#单行显示提交日志  \r\ngit log --graph --pretty=oneline --abbrev-commit  \r\ngit log -num#显示第几条log（倒数）  \r\ngit reflog#查看所有分支的所有操作记录  \r\ngit log --since=1.day#一天内的提交；你可以给出各种时间格式，比如说具体的某一天（\"2008-01-15\"），或者是多久以前（\"2 years 1 day 3 minutes ago\"）。  \r\ngit log --pretty=\"%h - %s\" --author=自己的名字#查看自己的日志  \r\ngit log -p -2#展开两次更新显示每次提交的内容差异  \r\ngit log --stat#要快速浏览其他协作者提交的更新都作了哪些改动  \r\ngit log --pretty=format:\"%h - %an, %ar : %s\"#定制要显示的记录格式  \r\ngit log --pretty=format:\'%h : %s\' --date-order --graph#拓扑顺序展示  \r\ngit log --pretty=format:\'%h : %s - %ad\' --date=short#日期YYYY-MM-DD显示  \r\ngit log HEAD --pretty=format:%s只显示commit    \r\n\r\n#### 选项说明  \r\n\r\n>%H提交对象（commit）的完整哈希字串  \r\n%h提交对象的简短哈希字串   \r\n%T树对象（tree）的完整哈希字串  \r\n%t树对象的简短哈希字串  \r\n%P父对象（parent）的完整哈希字串  \r\n%p父对象的简短哈希字串  \r\n%an作者（author）的名字  \r\n%ae作者的电子邮件地址  \r\n%ad作者修订日期（可以用 -date= 选项定制格式）\r\n%ar作者修订日期，按多久以前的方式显示  \r\n%cn提交者(committer)的名字  \r\n%ce提交者的电子邮件地址  \r\n%cd提交日期  \r\n%cr提交日期，按多久以前的方式显示  \r\n%s提交说明    \r\n\r\n#### 重写历史  \r\n\r\n>git commit --amend#改变最近一次提交  \r\ngit rebase -i HEAD~3#修改最近三次的提交说明，或者其中任意一次  \r\ngit commit --amend#保存好了，这些指示很明确地告诉了你该干什么  \r\ngit rebase --continue修改提交说明，退出编辑器。    \r\n\r\npick f7f3f6d changed my name a bit  \r\npick 310154e updated README formatting and added blame  \r\npick a5f4a0d added cat-file  \r\n\r\n改成\r\n\r\npick 310154e updated README formatting and added blame  \r\npick f7f3f6d changed my name a bit  \r\n\r\n#### 查看某个文件历史  \r\n\r\n>git log --pretty=oneline 文件名#列出文件的所有改动历史  \r\ngit show c178bf49#某次的改动的修改记录  \r\ngit log -p c178bf49#某次的改动的修改记录  \r\ngit blame 文件名#显示文件的每一行是在那个版本最后修改。  \r\ngit whatchanged 文件名#显示某个文件的每个版本提交信息：提交日期，提交人员，版本号，提交备注（没有修改细节）  \r\n\r\n#### 打造自己的git命令    \r\n>git config --global alias.st status  \r\ngit config --global alias.br branch  \r\ngit config --global alias.co checkout  \r\ngit config --global alias.ci commit  \r\n\r\n#### 配置好后再输入git命令的时候就不用再输入一大段了，例如我们要查看状态，只需：\r\n\r\n>git st  \r\n\r\n### 总结\r\n\r\n>git help * #获取命令的帮助信息  \r\ngit status#获取当前的状态，非常有用，因为git会提示接下来的能做的操作  \r\n\r\n### 报错  \r\ngit fatal: protocol error: bad line length character: No s解决办法：更换remote地址为http/https的  \r\nThe requested URL returned error: 403 Forbidden while accessing解决github push错误的办法  \r\n\r\n### 解决方案：  \r\nvim 编辑器打开 当前项目中的config文件vim .git/config  \r\n修改  \r\n[remote\"origin\"]        \r\nurl = https://github.com/jaywcjlove/example.git  \r\n为下面代码  \r\n[remote\"origin\"]       \r\n url = https://jaywcjlove@github.com/jaywcjlove/example.git  \r\n","timestamp":1585877701769},{"name":"001-介绍.md","path":"001-前端/07-HTML & CSS/006-附录/02-Coding使用指南/001-介绍.md","content":"## Coding\r\n[Coding](https://coding.net/)与Github类似，是一个代码托管平台，简单来说这东西就是一个在线存放代码的地方，使用git或svn进行版本控制，相对于github访问速度更快、中文界面使其使用更加方便。\r\n\r\nCoding 是一个面向开发者的云端开发平台，目前提供代码托管，运行空间，质量控制，项目管理等功能。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。支持多平台协作，随时随地开发、协作与部署，甚至还有已经成形的图形操作软件。\r\n\r\n\r\n## 使用方法\r\n### 1. 注册登录\r\n> 注册时需要绑定邮箱\r\n\r\n### 2. 创建项目\r\n点击主界面右上角 \"+\" 可创建项目\r\n\r\n1. 项目名称：项目名只允许字母、数字或者下划线(_)、中划线(-)、点(.)\r\n2. 选择使用 GIT仓库 进行代码管理\r\n3. \"README.md\" 文件用于初始化项目，书写项目中的说明文档\r\n4. 项目成员通过搜索 邮箱、用户名 添加，可用于协同开发\r\n\r\n\r\n### 3. 项目发布\r\n通过项目左侧选项 “代码 -> Pages服务” 可进行静态页面项目发布，项目发布后可通过规定域名访问该静态项目。\r\n> 项目发布后默认访问根目录 `index.html` 页面，如需访问其他页面，须在给定路径后加上目标页面路径\r\n\r\n","timestamp":1585877701769},{"name":"01-amWiki简介.md","path":"001-前端/07-HTML & CSS/006-附录/03-amWiki轻文库使用指南/01-amWiki简介.md","content":"# amWiki简介\r\n\r\n> amWiki是一款基于javascript脚本语、依赖于Atom编辑器、使用 Markdown 标记语法的轻量级开源wiki文库系统。使用amWiki致力于让大家可以更加简单快速的搭建个人或者是团队的文档系统。\r\n\r\n## amWiki 的优势\r\n\r\n* 文档系统采用 Markdown 语法\r\n* 无需服务端开发，只需支持 http 访问的静态网页空间\r\n* 不使用数据库，使用 .md 扩展名存储文档为本地文件\r\n* 一键创建新文库，自动生成一套 Html 页面\r\n* 自动更新文库导航目录\r\n* 支持截图直接粘帖为本地 png 并插入当前 Markdown 文档\r\n* Web 端页面自适应显示，适合各种 Web 平台与屏幕尺寸\r\n* 支持接口文档自动抓取内容生成简单的 Ajax 测试\r\n","timestamp":1585877701769},{"name":"02-配置环境.md","path":"001-前端/07-HTML & CSS/006-附录/03-amWiki轻文库使用指南/02-配置环境.md","content":"# 配置环境\r\n\r\n* 下载编辑器 Atom，并安装\r\n* 安装amWiki插件(3种)\r\n  * 方式1：File -> Settings -> Install -> 搜索amWiki\r\n   ![安装](amWiki/images/lx1.png)\r\n  * 方式2： 通过命令行\r\n    `amp install amWiki `\r\n  * 方式3：下载插件压缩文件\r\n    从Github的 [amWiki版本发布 下载zip](https://github.com/TevinLi/amWiki/releases)，(windows)解压到 C:\\Users\\Administrator\\.atom\\packages，并将文件夹名 amWiki-x.x.x 改为 amWiki即可\r\n* 重启(必须)\r\n  重启之后你会看到在 Atom的菜单栏多了一个 amWiki 轻文库栏目<br>\r\n  ![amWiki](amWiki/images/lx2.png)\r\n","timestamp":1585877701769},{"name":"03-创建amWiki轻文库.md","path":"001-前端/07-HTML & CSS/006-附录/03-amWiki轻文库使用指南/03-创建amWiki轻文库.md","content":"# 创建第一个 amWiki 轻文库\r\n环境搭建好之后，我们来创建属于我们自己的第一个 amWiki 轻文库\r\n\r\n## 创建 amWiki 轻文库\r\n* 在本地创建一个文件夹\r\n* 将刚才创建的文件夹，添加至 Atom 的项目文件 `Add Project Folder`\r\n\r\n  ![添加项目文件](amWiki/images/lx3.png)\r\n* 在刚刚创建的文件夹下创建 `config.json`\r\n\r\n  * name，你的文库名称，设置但为空或不设置将显示默认名\r\n  * ver，文本版本号或维护者名号，设置但为空将不显示，注意诺不设置此属性将显示 amWiki 作者\r\n  * logo，logo 的 url，设置但为空或不设置将显示默认 logo\r\n  * colour，自定义颜色，默认为蓝色\r\n  * testing，是否启用接口测试模块，默认值 false\r\n\r\n  ```\r\n  {\r\n    \"name\": \"amWiki 轻文库使用指南\",\r\n    \"ver\": \"starlee\",\r\n    \"logo\": \"amWiki/images/logo.png\",\r\n    \"colour\": \"#0085d0\",\r\n    \"testing\": false\r\n   }\r\n  ```\r\n* 通过 `config.json` 配置文件创建轻文库\r\n\r\n  > 通过 amWiki轻文库 -> 通过config.json创建轻文库\r\n\r\n  ![文件目录](amWiki/images/lx4.png)\r\n\r\n  在该项目中，amWiki文件夹放置一些静态文件例如js、css、images。library文件夹放置我们所要书写的文档。\r\n  > 在静态文件中我们一般将所需图片放置到 `images` 文件夹，其他的不做过多操作。当然你也可以通过 **粘贴** ** 复制 ctrl+shift+v**自动创建 assetes 保存图片文件夹\r\n\r\n* 预览文件\r\n  * 方法1：使用 `F12` 启动本地服务器，访问项目首页\r\n  * 方法2：使用 amWiki 轻文库 -> 启动本地静态 web 服务器 -> 在浏览器中打开当前文档\r\n\r\n  ![启动预览文档](amWiki/images/lx5.png)\r\n\r\n> 在此如果不能正常打开文档进行预览。请操作 amWiki轻文库-> 手动更新当前文库当行文件  或者  将电脑相关杀毒软件关闭。\r\n\r\n## 文档目录结构\r\n\r\n```\r\n  index.html                 // http 访问入口页面\r\n  amWiki/                    // amWiki Web 端程序文件夹\r\n  library/                   // 您的 Markdown 文库目录，所有文件必须使用 .md 格式\r\n     ├ $navigation.md        // amWiki 文库目录导航文件，可自动/手动更新\r\n     ├ 首页.md                // Web 端打开页面时页面页面默认显示的内容\r\n     ├ 001-SublimeText3使用指南     // Markdown 文件夹001\r\n     │   ├ 01-SublimeText3介绍     // 一些 Markdown 文档，支持二级目录  \r\n     │   └ 02-SublimeText3使用\r\n     ├ 002- amWiki轻文库使用指南    // Markdown 文件夹002\r\n     │   ├ 01-amWiki介绍           // 一些 Markdown 文档，支持二级目录\r\n     │   └ 02-amWiki配置环境\r\n     └ 003-...               // 更多 Markdown 文件夹\r\n   (assetes/)                // 如果您粘帖截图，图片文件将自动创建在此处\r\n```\r\n\r\n## 如何使用\r\n\r\n### 文档界面\r\n![文档界面](amWiki/images/lx6.png)\r\n\r\n* 预览。通过上述 创建 amWiki轻文库 -> 预览文件中两种方法打开预览文件。\r\n* 左侧通过文档栏目可以任意切换，你要查看的文档。\r\n* 关键字搜索栏，你可以根据关键字搜索指定的栏目。你也可以点击旁边的搜索按钮，在弹出的搜索页面中根据内容收缩相关文档。\r\n* 如果存在页内目录，可以通过右下角的目录，实现在页面进行快速跳转。\r\n","timestamp":1585877701769},{"name":"04-编辑文档.md","path":"001-前端/07-HTML & CSS/006-附录/03-amWiki轻文库使用指南/04-编辑文档.md","content":"# 编辑文档\r\n\r\n创建好文档仓库之后就可在编辑自己的文档了\r\n\r\n## 基本编辑\r\n\r\n* 添加文件或者文件夹，编辑自己的文档\r\n* 每个文件夹或者是文件命名规则。 id-名字.md\r\n  * id 仅允许 整数 或 浮点数 类型，且 不可重复\r\n  * 必须使用连 接符 或 下划线 将 id 与后续具体名称相连\r\n  * 文件只能使用 .md 扩展名\r\n\r\n如果不满足上述条件，可能会报以下错误。\r\n\r\n![命名不规范](amWiki/images/lx7.png)\r\n![命名不规范](amWiki/images/lx8.png)\r\n![命名不规范](amWiki/images/lx9.png)\r\n\r\n正确命名格式可参考 **WebTools**\r\n\r\n## 扩展编辑\r\n\r\n* library 文件夹下 首页.md 文档为默认打开时的显示内容\r\n\r\n  你可以适当修改此文档内容以符合您的项目需求\r\n\r\n* $navigation.md 导航文件无需人工维护，创建新文件夹或文件时将自动更新，也可以在菜单栏手动刷新：\r\n\r\n  菜单栏 -> amWiki文库 -> 手动更新当前文库导航文件\r\n*  如果需要在 Markdown 文档中插入图片，请先截图，然后在文档对应位置使用快捷键：Ctrl + Shift + V\r\n  此时，光标位置将多出一段 Markdown 图片代码，例如：\r\n  `  ![](assets/009/04-d149eb36.png)`\r\n\r\n  ![程鹏](assets/009/04-d149eb36.png)\r\n\r\n* 对于较长文章，可以使用页内目录，使用快捷键 Ctrl + D，或者`菜单栏 -> amWiki文库 -> 提取h2、h3标题为页内目录`,即可在光标处插入页内目录。\r\n","timestamp":1585877701769},{"name":"001-Webstrom介绍.md","path":"001-前端/07-HTML & CSS/006-附录/04-Webstrom使用指南/001-Webstrom介绍.md","content":"# WebStorm介绍\r\nWebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为\"Web前端开发神器\"、\"最强大的HTML5编辑器\"、\"最智能的JavaScript IDE\"等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。\r\n\r\n<br/>\r\n\r\n\r\n\r\n| 中文名称 | 外文名称 | 开发公司 | 类型 | 名誉\r\n|-----|-----|-----\r\n| 网络风暴 | WebStorm |jetbrains公司 | Web前端开发神器 | JavaScript 开发工具\r\n\r\n\r\n#### 官网地址：[http://www.jetbrains.com/webstorm/features/index.html](http://www.jetbrains.com/webstorm/features/index.html \"链接title文本\")\r\n## 整体界面\r\n![整体界面](amWiki/images/webstrom01.png)\r\n\r\n## WebStorm合其他的IDE有什么特别之处\r\n1) __自动保存__ ，不需要你一次又一次地ctrl+s啦，所有的操作都直接存储，当然，万一键盘误操作也会被立即存储，不过我们可以通过本地版本控制解决这个问题。\r\n\r\n   2) 任何一个编辑器只要文件关闭了就没有 __历史记录__ 了，但是 __webstorm有__ 。就是说，只要webstorm不关闭，你的文件随时可以返回到之前的操作，webstorm关闭重启后这些历史记录就没有了。这样的坏处也是显然的，由此带来的内存消耗也必然比较大。\r\n\r\n   3) 任何一个编辑器，除了服务器svn之外，没有本地版本，但是webstorm提供一个 __本地文件修改历史记录__。\r\n\r\n   4) __与时俱进的眼光__。zencoding于2009年出现于it界，在这之后，鲜有工具直接集成到里边。webstorm 2.0之后就集成了。node.js,html5,git,cvs等 就不一一列举了。\r\n\r\n   5)__提供的插件也是比较齐全__，安装非常方便。\r\n\r\n   6) 可以 __导出当前设置__：File -> Export setting。\r\n   \r\n","timestamp":1585877701769},{"name":"002-Webstro安装.md","path":"001-前端/07-HTML & CSS/006-附录/04-Webstrom使用指南/002-Webstro安装.md","content":"# WebStorm安装\r\n\r\n\r\n#### 官网地址：[http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/ \"链接title文本\")\r\n去官网下载最新版本进行安装.\r\n\r\n![安装界面](amWiki/images/wbs27.png)\r\n\r\n###  下载之后进行安装\r\n\r\n![安装界面](amWiki/images/wbs28.png)\r\n\r\n![安装界面](amWiki/images/wbs29.png)\r\n\r\n![安装界面](amWiki/images/wbs30.png)\r\n\r\n![安装界面](amWiki/images/wbs31.png)\r\n\r\n![安装界面](amWiki/images/wbs32.png)\r\n\r\n![安装界面](amWiki/images/wbs33.png)\r\n\r\n\r\n### 启动软件\r\n\r\n\r\n\r\n下面会要求你激活，如果不激活的只有免费使用30天\r\n\r\n\r\n\r\n### 去官网下载最新版本进行安装.\r\n 激活码可参考：[http://blog.csdn.net/xx1710/article/details/51725012](http://blog.csdn.net/xx1710/article/details/51725012 \"链接title文本\")\r\n\r\n这个能用：[http://idea.qinxi1992.cn/](http://idea.qinxi1992.cn/ \"链接title文本\")\r\n","timestamp":1585877701769},{"name":"003-Webstrom配置.md","path":"001-前端/07-HTML & CSS/006-附录/04-Webstrom使用指南/003-Webstrom配置.md","content":"# webstrom配置\r\n### 一、主题配色\r\n主题设置\r\n方法：File -> Settings -> Appearance & Behavior -> Appearance ->Theme.\r\n\r\n\r\n![安装界面](amWiki/images/wb3.jpg)\r\n\r\n配色设置\r\n方法：File -> Settings -> Editor -> Colors & Fonts->Scheme.（注：如果你是从从Sublime text3转过来的朋友，比较偏好monokia配色的，可以参见此文 webstorm入门1-主题和配色）\r\n\r\n![安装界面](amWiki/images/wb4.jpg)\r\n### 二、打开多个项目\r\nWebStorm默认情况下一次只能打开一个项目，这点很不爽，其实是可以设置的。（注：如果你一开始就建了项目再来配置，记得要把左边显示的根路径移除，不然可能点击Add Content Root配置后也不一定能生效）\r\n方法：File -> Settings -> Directories -> Add Content Root 中添加你当前的工程目录。\r\n\r\n\r\n![安装界面](amWiki/images/wb2.jpg)\r\n### 三、配置webserver选项（端口）\r\n方便其他ip设备访问(如手机等测试效果）\r\n方法：File -> Settings -> Build,Execution,Development -> Debugger ->port\r\n\r\n\r\n![安装界面](amWiki/images/wb8.jpg)\r\n### 四、设置文件的默认编码\r\n方法：File -> Settings -> Editor -> File Encodings -> IDE Encoding,Project Encoding.\r\n(注：配置前和配置后都可以打开页面，在页面的右下角显示有编码，下面截图右下角就有)\r\n\r\n\r\n![安装界面](amWiki/images/wb6.jpg)\r\n### 五、快捷键配置\r\n你可以使用默认快捷键配置，也可以根据自己的风格选择配置。习惯eclipse和myeclipse开发的可以配置成eclipse快捷键。\r\n方法：File -> Settings -> Keymap-> Keymaps\r\n\r\n\r\n![安装界面](amWiki/images/wb5.jpg)\r\n### 六、emmet配置，语法等等\r\n上面提到了快捷键，webstorm自带emmet插件。用过zen coding的人应该都知道，emmet就是zen coding的升级版。当然，webstorm也不是支持所有的emmet语法，不过够用了。可以参考此文Enabling Emmet Support看看具体情况。\r\n\r\n如下图，可以看到css自动加浏览器厂商前缀。\r\n\r\n![安装界面](amWiki/images/wb7.png)\r\n### 七、行号，换行，参考线\r\n打开页面后，右击页面左边边界，弹窗选项，根据自己需要勾选就是，如下图：\r\n\r\n\r\n![安装界面](amWiki/images/wb1.png)\r\n###  八、导入导出配置\r\n当你需要在其他电脑的webstorm上也想用自己编码风格时，将配置文件导入重启webstorm即可生效。\r\n\r\n导出方法：File -> Export Settings... ->自己选择选项和路径。用默认也可以。\r\n\r\n导入方法：File -> Import Settings... ->选择.jar文件路径。\r\n\r\n### 九、插件配置\r\nwebstorm自带很多插件，你可以根据自己需要配置。我暂时未使用，如果你用到了，可以参考下面的一些文章。\r\n\r\nSVN、Git插件配置，CSS预处理语言的预编译、JS 实时压缩等等可以参考此文webstorm入门2-配置\r\n\r\n使用css预编译器（sass,less）的朋友,可以省掉gulp、grunt类前端辅助工具,参考此文webstorm入门5-sass、scss、less监听编译\r\n\r\n### 十、添加VIM插件\r\n\r\nFile -> Settings -> Plugins -> Browse repositories -> 搜索vim，对它单击右键Download and install，然后重启IDE就可以了。\r\n\r\n### 十一、phper的开发工具\r\n除了webstorm之外，此公司还提供另外一个针对phper的开发工具,phpStorm，主页上说明，phpstorm包括所有webstorm的功能。但是习惯于大括号去方法名在同一行显示，所以还得配置：File -> Settings -> code style -> PHP -> Wrapping and Braces -> Braces placement ->In method declaration : End of line.\r\n\r\n\r\n### 十二、提示配置\r\n5.在开发js时发现，需要ctrl + return 才能选提示候选项，又需要配置：File -> Setting -> Editor -> Code Completion -> Preselect the first suggestion:’Smart’ 改为 Always\r\n\r\n### 十二、注意\r\nWebstorm的调试不支持中文路径中文文件名。\r\n","timestamp":1585877701769},{"name":"004-Webstro创建工程及展示.md","path":"001-前端/07-HTML & CSS/006-附录/04-Webstrom使用指南/004-Webstro创建工程及展示.md","content":"# WebStorm工程创建及展示\r\n\r\n\r\n### 1.新建工程\r\n\r\n点击顶部菜单栏“File”-> “New Project”。\r\n\r\n弹出如下界面：\r\n\r\n![整体界面](amWiki/images/wbs09.png)\r\n\r\n“Location”指向想要创建的工程目录（如果该目录已经存在文件，会出现exist提示，没关系，直接下一步即可）。\r\n\r\n“Project Type”为工程类型，应该理解为工程模版更合适，默认为空项目，Webstorm支持html5、bootstrap、NodeJs、express工程模版。\r\n\r\n这里我们选择流行的“Bootstrap”，点击下一步后，Webstorm会自动从服务器拉取Bootstrap的代码（源代码）到工程目录内。\r\n\r\n![整体界面](amWiki/images/wbs10.png)\r\n\r\nWebstorm的工程缺陷在于没办法在一个界面中存在多个工程，再新建个工程，会打开个新的窗口，来回切换非常麻烦。\r\n\r\n### 2.收藏夹功能\r\n\r\n当工程目录很庞大时，有些子目录很经常打开，但层级又很深，这时候可以把目录添加到收藏夹里面，比如：\r\n\r\n![整体界面](amWiki/images/wbs11.png)\r\n\r\n（需命名下收藏列表名称）\r\n\r\n添加成功后，左侧有个“Favorites”菜单：\r\n\r\n![整体界面](amWiki/images/wbs12.png)\r\n\r\n### 3.工程其他操作\r\n\r\n![整体界面](amWiki/images/wbs13.png)\r\n\r\n包括关闭工程、打开最近工程、重命名工程、打开工程等，比较简单，明河不再累述。\r\n\r\n### Webstorm的主要界面\r\n#### 1.顶部菜单\r\n\r\n![整体界面](amWiki/images/wbs14.png)\r\n\r\n包含所有IDE功能，后面的文章会讲解到常用的功能项。\r\n\r\n建议看下功能菜单上的快捷键。\r\n\r\n#### 2.目录面包屑\r\n\r\n![整体界面](amWiki/images/wbs15.png)\r\n\r\n这个功能非常实用，可以通过点击目录来寻找需要的文件，比打开工程界面来得节约空间，够低碳。\r\n\r\n#### 3.工程界面\r\n\r\n![整体界面](amWiki/images/wbs16.png)\r\n\r\n在Webstorm中用于查找文件的功能有很多，在工程界面界面中查找是最原始的，效率也是最差的，打开后还占用代码窗口面积。\r\n\r\n建议使用“alt+1”来快速拆合工程界面。\r\n\r\n#### 4.构造器界面\r\n\r\n![整体界面](amWiki/images/wbs17.png)\r\n\r\n在这个界面中，可以快速查找js类的函数和对象，留意准确度跟你的注释量息息相关（注释需要符合jsdoc格式，这个后面会讲道）。\r\n\r\n#### 5.todo界面\r\n\r\n![整体界面](amWiki/images/wbs18.png)\r\n\r\n给代码加todo注释，是个非常好的习惯，比如提醒后面的维护者要注意些什么，比如提醒日后的自己要优化这处的代码等。\r\n\r\n菜单项前面的6,，表示你可以使用”alt+6″来快速拆合此界面。\r\n\r\n给代码加todo很简单：// TODO why??类似这样既可。\r\n\r\n#### 6.底部信息\r\n\r\n![整体界面](amWiki/images/wbs19.png)\r\n\r\n数字区域表示的是光标位置，有个实用的技巧：点击这个区域，可以跳转到指定行的代码：\r\n\r\n![整体界面](amWiki/images/wbs20.png)\r\n\r\n底部还可以设置文件的编码。\r\n\r\n#### 7.显示代码行数\r\n\r\n右击代码界面左侧边框任意位置：\r\n\r\n![整体界面](amWiki/images/wbs21.png)\r\n\r\n左侧边框还会有代码版本变更标记，非常实用。\r\n\r\n#### 8.工程环境配置\r\n\r\n![整体界面](amWiki/images/wbs22.png)\r\n\r\n后面会详细讲解这部分内容。\r\n\r\n#### 9.隐藏边栏菜单\r\n\r\n![整体界面](amWiki/images/wbs23.png)\r\n\r\n点击左底下的关闭按钮。\r\n\r\n#### 10.快速拆合界面\r\n\r\n可以使用“alt+数字键”来快速拆合界面。\r\n\r\n如何查看界面的数字键呢？\r\n\r\n![整体界面](amWiki/images/wbs24.png)\r\n\r\n#### 11.隐藏菜单和工具栏\r\n\r\n点击“View”\r\n\r\n![整体界面](amWiki/images/wbs25.png)\r\n\r\n#### 12.双栏代码界面\r\n\r\n右击代码选项卡上的文件\r\n\r\n![整体界面](amWiki/images/wbs26.png)\r\n","timestamp":1585877701769},{"name":"005-Webstrom快捷键使用方式.md","path":"001-前端/07-HTML & CSS/006-附录/04-Webstrom使用指南/005-Webstrom快捷键使用方式.md","content":"# WebStorm快捷键使用\r\n### Editing编辑相关快捷键\r\n\r\n* __Ctrl + Space：__\r\nBasic code completion (the name of any class, method or variable) 基本代码完成（任何类、函数或者变量名称），改为Alt+S\r\n\r\n+ __Ctrl + Shift + Enter：__\r\nComplete statement 补全当前语句\r\n\r\n+ __Ctrl + P：__\r\nParameter info (within method call arguments) 参数信息 包括方法调用参数\r\n\r\n+ __Ctrl + mouse over code:__\r\nBrief Info 简单信息\r\n\r\n+ __Ctrl + F1:__\r\nShow description of error or warning at caret 显示光标所在位置的错误信息或者警告信息\r\n\r\n+ __Alt + Insert:__\r\nGenerate code…（Getters, Setters, Constructors）新建一个文件或者生成代码，…构造函数，可以创建类里面任何字段的getter与setter方法\r\n\r\n+ __Ctrl + O:__\r\nOverride methods 重载方法\r\n\r\n+ __Ctrl + I:__\r\nImplement methods 实现方法\r\n\r\n+ __Ctrl + Alt + T:__\r\nSurround with…（if, else, try, catch, for, etc）用 * 来围绕选中的代码行，（ * 包括 if 、 while 、 try catch 等）\r\n\r\n+ __Ctrl + /:__\r\nComment/uncomment with line comment 行注释/取消行注释\r\n\r\n+ __Ctrl + Shift + /:__\r\nComment/uncomment with block comment 块注释/取消块注释\r\n\r\n+ __Ctrl + W:__\r\nSelect successively increasing code blocks 选择代码块，一般是增量选择\r\n\r\n+ __Ctrl + Shift + W:__\r\nDecrease current selection to previous state 上个快捷键的回退，减量选择代码\r\n\r\n+ __Alt + Q:__\r\nContext info 上下文信息\r\n\r\n+ __Alt + Enter:__\r\nShow intention actions and quick-fixes 意图行动，快速见效\r\n\r\n+ __Ctrl + Alt + L:__\r\nReformat code 根据模板格式对代码格式化\r\n\r\n+ __Tab/ Shift + Tab:__\r\nIndent/unindent selected lines 对所选行进行缩排处理/撤销缩排处理\r\n\r\n+ __Ctrl + X or Shift + Delete:__\r\nCut current line or selected block to clipboard 剪切当前行或所选代码块到剪切板\r\n\r\n+ __Ctrl + C or Ctrl + Insert:__\r\nCopy current line or selected block to chipboard 拷贝当前行或者所选代码块到剪切板\r\n\r\n+ __Ctrl + V or Shift + Insert:__\r\nPaste from clipboard 粘贴剪切板上的内容\r\n\r\n+ __Ctrl + Shift + V:__\r\nPaste from recent buffers 粘贴缓冲器中最新的内容\r\n\r\n+ __Ctrl + D:__\r\nDuplicate current line or selected block 复制当前行或者所选代码块\r\n\r\n+ __Ctrl + Y:__\r\nDelete line at caret 删除光标所在位置行\r\n\r\n+ __Ctrl + Shift + J:__\r\nSmart line join（HTML and JavaScript only）加入智能行 （HTML 和JavaScript）\r\n\r\n+ __Ctrl + Enter:__\r\nSmart line split（HTML and JavaScript only）分离智能行 （HTML 和JavaScript）\r\n\r\n+ __Shift + Enter:__\r\nStart new line 另起一行\r\n\r\n+ __Ctrl + Shift + U:__\r\nToggle case for word at caret or selected block 光标所在位置大小写转换\r\n\r\n+ __Ctrl + Shift + ]/[:__\r\nSelect till code block end/start 选择直到代码块结束/开始\r\n\r\n+ __Ctrl + Delete:__\r\nDelete to word end 删除文字结束\r\n\r\n+ __Ctrl + Backspace:__\r\nDelete to word start 删除文字开始\r\n\r\n+ __Ctrl + NumPad+/-:__\r\nExpand/collapse code block 扩展/缩减代码块\r\n\r\n+ __Ctrl + Shift+ NumPad+:__\r\nExpand all 扩张所有\r\n\r\n+ __Ctrl + Shift+ NumPad-:__\r\nCollapse 缩减所有\r\n\r\n+ __Ctrl + F4:__\r\nClose active editor tab 关闭活跃编辑标签\r\n\r\n### Search/replace搜索/替代相关快捷键\r\n\r\n+ __Ctrl + F:__\r\nFind 当前文件内快速查找代码\r\n\r\n+ __Ctrl + Shift + F:__\r\nFind in path 指定文件内寻找路径\r\n\r\n+ __F3:__\r\nFind next 查找下一个\r\n\r\n+ __Shift + F3:__\r\nFind previous 查找上一个\r\n\r\n+ __Ctrl + R:__\r\nReplace 当前文件内代码替代\r\n\r\n+ __Ctrl + Shift + R:__\r\nReplace in path 指定文件内代码批量替代\r\n\r\n### Usage Search搜索相关快捷键\r\n\r\n+ __Alt + F7/Ctrl + F7:__\r\nFind usages/Find usages in file 找到使用/在文件找到使用\r\n\r\n+ __Ctrl + Shift + F7:__\r\nHighlight usages in file文件中精彩使用\r\n\r\n+ __Ctrl + Alt + F7:__\r\nShow usages 显示使用\r\n\r\n### Running运行\r\n\r\n+ __Alt + Shift + F10:__\r\nSelect configuration and run 选择构架，运行\r\n\r\n+ __Alt + Shift + F9:__\r\nSelect configuration and debug 选择构架，修补漏洞\r\n\r\n+ __Shift + F10:__\r\nRun 运行\r\n\r\n+ __Shift + F9:__\r\nDebug 修补漏洞\r\n\r\n+ __Ctrl + Shift + F10:__\r\nRun context configuration from editor 从编辑运行内容构架\r\n\r\n+ __Ctrl + Shift + X:__\r\nRun command line 运行命令行\r\n\r\n### Debugging Debugging相关快捷键\r\n\r\n+ __F8:__\r\nStep over 不进入函数\r\n\r\n+ __F7:__\r\nStep into 单步执行\r\n\r\n\r\n+ __Shift + F7:__\r\nSmart step into 智能单步执行\r\n\r\n+ __Shift + F8:__\r\nStep out 跳出\r\n\r\n+ __Alt + F9:__\r\nRun to cursor 运行到光标处\r\n\r\n+ __Alt+ F8:__\r\nEvaluate expression 评估表达\r\n\r\n+ __F9:__\r\nResume program 重新开始程序\r\n\r\n+ __Ctrl + F8:__\r\nToggle breakpoint 切换断点\r\n\r\n+ __Ctrl + Shift + F8:__\r\nView breakpoints 查看断点\r\n\r\n### Navigation 定位相关快捷键\r\n\r\n+ __Ctrl + N:__\r\nGo to class跳转到指定类\r\n\r\n+ __Ctrl + Shift + N:__\r\nGo to file 通过文件名快速查找工程内的文件\r\n\r\n+ __Ctrl + Alt +Shift + N:__\r\ngo to symbol 通过一个字符查找函数位置\r\n\r\n+ __Alt + Right/ left:__\r\nGo to next/ previous editor tab 进入下一个/ 上一个编辑器选项\r\n\r\n+ __F12:__\r\nGo back to previous tool window 进入上一个工具窗口\r\n\r\n+ __Esc:__\r\nGo to editor（from tool window） 从工具窗口进入编辑器\r\n\r\n+ __Shift + Esc:__\r\nHide active or last active window 隐藏活动窗口\r\n\r\n+ __Ctrl + Shift + F4:__\r\nClose active run/message/find/…tab 关闭活动….标签\r\n\r\n+ __Ctrl + G:__\r\nGo to line 跳转到第几行\r\n\r\n+ __Ctrl + E:__\r\nRecent files popup 弹出最近打开的文件\r\n\r\n+ __Ctrl + Alt + Left/Right:__\r\nNavigate back/forward 导航前进/后退\r\n\r\n+ __Ctrl + Shift + Backspace:__\r\nNavigate to last edit location 向最近编辑定位导航\r\n\r\n+ __Alt + F1:__\r\nSelect current file or symbol in any view 查找当前选中的代码或文件在其他界面模块的位置\r\n\r\n+ __Ctrl + B or Ctrl + Click:__\r\nGo to declaration跳转到定义处\r\n\r\n+ __Ctrl + Alt + B:__\r\nGo to implementation(s) 跳转方法实现处\r\n\r\n+ __Ctrl + Shift + B:__\r\nGo to type declaration 跳转方法定义处\r\n\r\n+ __Ctrl + Shift + I:__\r\nOpen quick definition lookup 打开定义快速查找\r\n\r\n+ __Ctrl + U:__\r\nGo to super-method/super-class 跳转方法/超阶级\r\n\r\n+ __Alt + Up/Down:__\r\nGo to previous/next method 在方法间快速移动定位\r\n\r\n+ __Ctrl + ]/[:__\r\nMove to code block end/start 跳转到编码块结束/开始\r\n\r\n+ __Ctrl + F12:__\r\nFile structure popup 文件结构弹出\r\n\r\n+ __Ctrl + H:__\r\nType hierarchy 类型层次\r\n\r\n+ __Ctrl + Alt + H:__\r\nCall hierarchy 调用层次结构\r\n\r\n+ __F2/ Shift + F2:__\r\nNext/previous highlighted error 跳转到后一个/前一个错误，高亮错误或警告快速定位，使用这个快捷键可以快捷在出错的语句之间进行跳转。\r\n\r\n+ __F4/Ctrl + Enter:__\r\nEdit source/ View source 编辑源代码/查看源代码\r\n\r\n+ __Alt + Home:__\r\nShow navigation bar 显示导航栏\r\n\r\n+ __F11:__\r\nToggle bookmark 切换标记\r\n\r\n+ __Ctrl + F11:__\r\nToggle bookmark with mnemonic 采用记忆切换标记\r\n\r\n+ __Ctrl + #[0-9]:__\r\nGo to numbered bookmark 跳转到带编号的标记\r\n\r\n+ __Shift + F11:__\r\nShow bookmark 显示标记\r\n\r\n### Refactoring 重构相关快捷键\r\n\r\n+ __F5:__\r\nCopy 拷贝\r\n\r\n+ __F6:__\r\nMove 移动\r\n\r\n+ __Alt + Delete:__\r\nSafe Delete 安全删除\r\n\r\n+ __Shift + F6:__\r\nRename 重新命名\r\n\r\n+ __Ctrl + Alt + N:__\r\nInline Variable 嵌入变量\r\n\r\n+ __Ctrl + Alt + M:__\r\nExtract Method( Javascript only) 提取函数\r\n\r\n+ __Ctrl + Alt + V:__\r\nIntroduce Variable 引入变量\r\n\r\n+ __Ctrl + Alt + F:__\r\nIntroduce Field 引入域\r\n\r\n+ __Ctrl + Alt + C:__\r\nIntroduce Constant 引入常量\r\n\r\n### VCS/Local History 版本控制系统/ 本地历史相关快捷键\r\n\r\n+ __Alt +　BackQuote( ):__\r\n‘VCS’quick popup 快速弹出 VCS\r\n\r\n+ __Ctrl + K:__\r\nCommit project to VCS 提交项目至VCS\r\n\r\n+ __Ctrl + T:__\r\nUpdate project from VCS 从VCS 更新项目\r\n\r\n+ __Alt + Shift + C:__\r\nView recent changes 查看最新改变\r\n\r\n### General 常用的相关快捷键\r\n\r\n+ __Ctrl + Shift +A:__\r\nFind action 查找并调用编辑器的功能\r\n\r\n+ __Alt + #[0-9]:__\r\nOpen corresponding tool window 快速切换打开界面模块\r\n\r\n+ __Ctrl + Alt + F11:__\r\nToggle full screen mode 切换全屏模式\r\n\r\n+ __Ctrl + Shift + F12:__\r\nToggle maximizing editor 切换最大化编辑器\r\n\r\n+ __Alt + Shift + F:__\r\nAdd to Favorites 将当前文件添至收藏夹\r\n\r\n+ __Alt + Shift + I：__\r\nInspect current file with current profile 使用当前属性检查当前文件\r\n\r\n+ __Ctrl + BackQuote( )：__\r\nQuick switch current scheme 快速转换现有组合\r\n\r\n+ __Ctrl + Alt + S：__\r\nOpen setting dialog 打开设置对话框\r\n\r\n+ __Ctrl + Tab：__\r\nSwitch between tabs and tool window 标签和工具窗的转换（与windows快捷键冲突）\r\n","timestamp":1585877701769},{"name":"01-svn简介.md","path":"001-前端/07-HTML & CSS/006-附录/05-SVN使用指南/01-svn简介.md","content":"## svn 简介  \r\n\r\n1. SVN全称：Subversion;\r\n2.  它是开放源代码的版本控制器；\r\n3.  它采用了分支管理系统，目标是取代CVS，是cvs的重写版和改进版；\r\n4.  通俗地讲，它用于多个人共同开发同一项目，共用资源的目的；\r\n5.  svn服务器有2种运行方式：独立服务器和借助apache运行。两种方式各有利弊，用户可以自行选择\r\n6.  svn存储版本数据也有2种方式：BDB(一种事务安全型表类型)和FSFS(一种不需要数据库的存储系统)。因为BDB方式在服务器中断时，有可能锁住数据，所以还是FSFS方式更安全一点。\r\n7.  集中式管理的工作流程如下图：\r\n集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。下面举例说明：\r\n开始新一天的工作：  \r\n ![svn原理](amWiki/images/svn.png)  \r\n 1）从服务器下载项目组最新代码。  \r\n 2）进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。  \r\n 3）下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。  \r\n这就是经典的svn工作流程，从流程上看，有不少缺点，但也有优点。  　 \r\n","timestamp":1585877701769},{"name":"02-svn的安装与使用.md","path":"001-前端/07-HTML & CSS/006-附录/05-SVN使用指南/02-svn的安装与使用.md","content":"## SVN使用环境  \r\n\r\n使用SVN管理源代码，必须有2套环境  \r\n\r\n1. 服务器  \r\n用来存储客户端上传的源码  \r\n一般都是在Windows环境下安装Visual SVN Server  \r\n大部分情况下，不是由开发人员搭建SVN服务器  \r\n2. 客户端  \r\n用来提交、回退、修改、下载等操作  \r\n\r\n### 在Windows安装Visual SVN Server  \r\n\r\n下载Visual SVN Server安装包  \r\n打开安装包 --> next --> 同意协议 --> next --> 选择默认选项（安装SVN控制台）--> next --> 选择第一个按钮（标准版）--> next --> location：安装路径 Repositories：仓库路径 server Port：端口 旁边的https://选项不勾选（因为一般SVN都是在局域网，不会有安全问题）--> next -->Install --> 完成  \r\n![svn使用说明图](amWiki/images/svn1.gif)　　  \r\n\r\n### 创建SVN仓库\r\n\r\n* 打开Visual SVN Server  \r\n* 右击Repositories --> 新建 --> Repository --> 设置仓库名称 --> 下一步 --> 选择第一项Enpty repository（空的仓库）--> 下一步 --> 设置访问权限（Nobody has access<无人能访问>、All Subversion users have Read/Write access<所有人可以读写>、Customize permissions<自定义访问>）因为是初始化仓库，所以先设置为没人能访问 --> 下一步 --> 完成  \r\n![svn使用说明图](amWiki/images/svn2.gif)　\r\n　\r\n### SVN仓库配置\r\n\r\n在新建的仓库中新建2个文件夹（Code、Doc）：新建 --> Folder --> 文件夹名称 --> 完成  \r\n* 创建用户：右击Users --> Create user --> User name：用户名 Password：密码 Confirm password：确认密码 --> 完成  \r\n* 创建用户组（iOS、Android）：右击Groups --> Create Group --> Group name：组名 --> Add：增加成员 --> 完成  \r\n* 配置仓库用户权限：右击仓库 --> Properties --> Add：添加成员或组 --> Permissions：设置权限（NO Access<无权限>、Read Only<只读>、Read/Write<可读可写>）--> 应用  \r\n* 配置完成  \r\n![svn使用说明图](amWiki/images/svn3.gif)　\r\n\r\n###测试SVN仓库链连接是否正常\r\n\r\n连接仓库分为测试连接和远程连接2种  \r\n* 测试连接：也叫本地连接，就是在搭建SVN的服务器上测试是否可以连接，步骤如下：  \r\n* 右键仓库 --> Copy URL to Clipboard --> 打开浏览器 --> 在地址栏粘贴（我这边的地址：http://yeshaoji-ef1f42/svn/test/）并回车 --> 输入用户名密码 --> 这样就连接上仓库了  \r\n![svn使用说明图](amWiki/images/svn4.gif)　\r\n\r\n* 远程连接：测试完毕后就可以将地址发放给成员使用了  \r\n * 服务器地址获取方式  \r\n   在服务器端打开命令行工具 --> $ ipconfig --> IP Address就是我们服务器地址  \r\n * 拼接链接地址  \r\n   格式：http://服务器地址/SVN仓库路径 （比如我的：http://172.16.153.128/svn/test/）\r\n使用者打开浏览器 --> 在地址栏粘贴并回车 --> 输入用户名密码 --> 这样就连接上仓库了  \r\n![svn使用说明图](amWiki/images/svn5.gif)　\r\n\r\n### 管理者初始化项目\r\n\r\n* 将远程仓库下载到本地  \r\n进入我们需要放置的文件件下  \r\n`$ cd /Users/yeshaojian/Desktop/SVN/mgr`  \r\n* 连接并下载  \r\n`$ svn checkout 仓库路径 --username=用户名 --password=密码`  \r\n下载成功后，在我们的文件夹下会出现下载下来的仓库，仓库里面有.svn的隐藏文件（显示和隐藏mac上文件的方法）  \r\n\r\n* 进入本地仓库  \r\n- $ cd 本地仓库目录（就是有.svn隐藏文件的目录）  \r\n- 创建文件 main.m    \r\n- `$ touch main.m`  \r\n* 查看文件状态    \r\n- `$ svn status`  \r\n\r\n说明：    \r\n1. ?表示该文件不受SVN管理  \r\n2. A表示该文件受SVN管理   \r\n3. M表示该文件被修改   \r\n将文件添加到svn管理中    \r\n`$ svn add main.m （也可使用 $ svn add * <表示提交所有文件>）`  \r\n将main.m文件提交到远程仓库  \r\n`$ svn commit main.m -m \"注释\"`  \r\n![svn使用说明图](amWiki/images/svn6.gif)　  \r\n\r\n新成员使用SVN和多人开发\r\n\r\n### 新成员篇：\r\n\r\n第一次加入项目需要进行下面操作   \r\n获取到SVN账号与密码与远程仓库路径  \r\n连接远程仓库并将仓库下载到本地  \r\n\r\n* 进入我们需要放置的文件件下  \r\n`$ cd /Users/yeshaojian/Desktop/SVN/newTest`  \r\n* 连接并下载  \r\n`$ svn checkout 仓库路径 --username=用户名 --password=密码`  \r\n* 添加文件  \r\n`$ touch test1.m test2.m test3.m  `\r\n* 查看文件状态  \r\n`$ svn status  `\r\n* 将不受SVN管理的文件添加到管理中  \r\n`$ svn add test1.m test2.m test3.m`\r\n* 将文件提交到远程仓库  \r\n`$ svn commit test1.m test2.m test3.m -m \"注释\" 或者 $ svn commit -m \"注释\"（不写表示全部提交）`  \r\n![svn使用说明图](amWiki/images/svn7.gif)　\r\n\r\n在后面的开发中（多人开发）就只根据需要提交代码就可以了：    \r\n### 管理者篇：  \r\n管理者加入开发步骤：    \r\n- 进入我们需要放置的文件件下  \r\n`$ cd /Users/yeshaojian/Desktop/SVN/mgr`  \r\n- 更新代码  \r\n`$ svn update`  \r\n- 在test1.m文件中修改文件内容，上传服务器  \r\n`$ svn commit -m \"注释\"`  \r\n![svn使用说明图](amWiki/images/svn8.gif)　\r\n\r\n### 新成员篇：  \r\n\r\n* 进入我们需要放置的文件件下      \r\n`$ cd /Users/yeshaojian/Desktop/SVN/newTest`  \r\n* 新成员更新服务器上的代码到本地    \r\n`$ svn update`    \r\n* 提交代码到远程仓库    \r\n`$ svn commit -m \"注释\"`  \r\n注意：每次要修改前先更新一下代码再进行修改。  \r\n![svn使用说明图](amWiki/images/svn9.gif)　\r\n\r\n### SVN命令行方式删除文件\r\n\r\nSVN不能使用普通的右键删除方式删除文件  \r\n* 使用命令行删除  \r\n`$ svn remove test3.m`\r\n* 为确认文件被删除，查看下状态   \r\n`$ svn status`  \r\n\r\n说明：   \r\n1. ?表示该文件不受SVN管理    \r\n2. A表示该文件受SVN管理  \r\n3. M表示该文件被修改  \r\n4. D表示该文件已被删除  \r\n* 提交更改  \r\n`$ svn commit -m \"删除了test3.m文件\"`  \r\n* 别的成员修改前需要更新代码，才能继续操作  \r\n`$ svn update`  \r\n![svn使用说明图](amWiki/images/svn10.gif)　  \r\n\r\n### SVN一些命令行简写  \r\n\r\n最常用的简写  \r\n- checkout --> co  \r\n- status --> st  \r\n- commit --> ci  \r\n- update --> up  \r\n![svn使用说明图](amWiki/images/svn11.gif)　  \r\n\r\n### SVN版本查看和回退  \r\n\r\n* SVN查看版本信息很简单，使用下面指令就可以      \r\n - `$ svn log`    \r\nSVN中有2中恢复或回退的情况，下面会介绍：    \r\n* 情况一：我们本地修改了文件，但还没有提交到服务器    \r\n - 解决方法：$ svn revert 需要恢复的文件    \r\n ![svn使用说明图](amWiki/images/svn12.gif)　   \r\n\r\n * 情况二：回退到以前的版本\r\n  - 首先要先更新本地版本到最新版\r\n `$ svn update 版本`\r\n  - 解决方法：\r\n  1. 查看历史版本\r\n `$ svn log`\r\n  2. 合并版本\r\n  `$ svn merge -r版本:版本 .（比如现在最新版本为9 --> $ svn merge -r9:r5 .）`  \r\n 说明：这边会提示“U”标识，表示该文件为合并状态    \r\n 注意：这边最后面的 \".\" 要敲，表示当前目录    \r\n 提交到远程服务器    \r\n `$ svn commit -m \"注释\"`   \r\n ![svn使用说明图](amWiki/images/svn13.gif)　     \r\n\r\n### 多人开发常见冲突解决  \r\n\r\n场景描述：多个人同时修改了同一个文件的同一个地方，且有人已经提交到远程仓库，后面的人还在继续开发，且后面开发的人不是最新版本了，所以无法提交（SVN中如果远程服务器版本大于要提交的版本，就无法提交），这样的情况下就需要通过下面的步骤解决：  \r\n\r\n* 先获取最新版本（这时会提示冲突，并给出了解决方案，因为我们修改了同一文件的同一个地方）  \r\n`$ svn update`  \r\n提示：在提示解决方案中，经常用到的是以下几项  \r\n- (p) postpone：延迟处理 (最常用，先不解决)  \r\n- (mc) mine-conflict：以我的为准，覆盖掉仓库  \r\n- (tc) theirs-conflict：以原创仓库为准，覆盖掉本地版本  \r\n- (s) show all options：显示所有选项   \r\n\r\n* 方式一：这边选择mc（以我的为准）--> 回车  \r\n说明：如果看到显示了大写的 \"G\" 就说明冲突已经解决   \r\n - 提交     \r\n svn commit -m \"覆盖了远程仓库代码，解决冲突\"  \r\n* 方式二：这边选择tc (以远程版本为准，覆盖掉本地版本) --> 回车  \r\n - 提交   \r\n`svn commit -m` \"添加了某某属性，但不成功，稍后添加\"  \r\n注：因为此次提交不会有提示，因为本地版本和远程版本一样  \r\n* 方式三：这边选择p（延迟处理）--> 回车  \r\n这时我们的本地仓库内会多生成3个文件，这是我们需要手动解决相应的问题  \r\n打开冲突文件，根据冲突提示进行相应修改  \r\n修改完成后，告诉远程仓库，我们已经解决冲突  \r\n`$ svn resoved` 冲突文件名    \r\n - 提交  \r\n`$ svn commit -m `\"手动解决了冲突\"  \r\n\r\n### SVN图形化管理软件（Cornerstone）使用  \r\n\r\nCornerstone界面介绍  \r\n![svn使用说明图](amWiki/images/svn14.png)　  \r\n\r\n* 初始化项目管理  \r\n - 连接SVN服务器 --> 左下角（REPOSITORIES）栏的 “+” 号 --> 选择HTTP Server --> 填写相应信息后点击Add  \r\n ![svn使用说明图](amWiki/images/svn15.gif)　  \r\n\r\n  - 下载远程仓库内容到本地 --> 点击左上角的Check out --> 选择需要保存的位置 --> 打开下面的隐藏选项 --> 将Format选项调制最高（不然可能出现未知错误）--> check out --> 完成   \r\n  ![svn使用说明图](amWiki/images/svn16.gif)　  \r\n - 创建项目 --> 文件存放位置为SVN的工作区的Code中  \r\n ![svn使用说明图](amWiki/images/svn17.gif)　  \r\n - 忽略不需要管理的文件 --> Cornerstone --> 点击Commit --> 在弹出的对话框中选择ignore(忽略) --> 打开项目中的.xcodeproj --> project.xcworkspace --> 删除2个xcuserdate文件 --> 提交 --> 修改项目中的任意地方（比如打个断点或者声明变量等） --> 运行项目 --> 回到Cornerstone --> 会发现刚刚删除的2个文件又出现了 --> 分别右击选择Ignore --> 然后更新仓库版本 --> 提交  \r\n ![svn使用说明图](amWiki/images/svn18.gif)　   \r\n - 测试文件是否忽略成功 --> 随便修改任意文件 --> 点击Source Control --> Commit --> 发现只有我们修改的文件需要提交怎么已经成功忽略文件   \r\n ![svn使用说明图](amWiki/images/svn19.gif)　    \r\n - 这样项目的初始化就完成了，以后就只需要用XCode来进行版本控制操作就可以了，不需要再进行忽略文件操作\r\n","timestamp":1585877701769},{"name":"01-HBuilder介绍下载.md","path":"001-前端/07-HTML & CSS/006-附录/06-HBuilder打包工具使用指南/01-HBuilder介绍下载.md","content":"# HBuilder 简单介绍\r\n>HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。HBuilder的编写用到了Java、C、Web和Ruby。HBuilder本身主体是由Java编写。  \r\n我们使用这款软件不但可以进行app打包，还能够进行代码的编写，很多大公司不允许员工使用它来进行代码的编写，是因为‘5+Runtime’在打包app时需要将app的源码上传，所以它是不安全的，但是现在“5+Runtime”已经支持本地打包了。\r\n\r\n## 特点\r\n>快是HBuilder的最大优势，通过完整的语法提示和代码输入法、代码块等，大幅提升HTML、js、css的开发效率。\r\n\r\n## 下载和安装\r\n### 下载\r\n<a href=\"http://www.dcloud.io/runtime.html#toDownload\">点击下载</a><br/>\r\n![下载选择界面](amWiki/images/HBuilder下载.jpg)\r\n### 安装\r\n下载完成之后会下载一个压缩包在你的电脑上，将文件夹解压后，在文件夹中找到这个“Hbuilder.exe”的可执行文件，双击就可以打开这款软件了。  \r\n每次这样使用会比较麻烦，所以我们右击这个可执行文件，点击发送快捷方式到桌面，以后使用的时候直接可以在桌面上双击图标就行了。\r\n","timestamp":1585877701769},{"name":"02-HBuilder使用.md","path":"001-前端/07-HTML & CSS/006-附录/06-HBuilder打包工具使用指南/02-HBuilder使用.md","content":"## 使用\r\n>双击打开软件后我们需要去注册一个账号去使用，注册的流程这里就不赘述了。  \r\n\r\n### HBuilder界面    \r\n![HBuilder界面](amWiki/images/HBuilder界面.jpg)\r\n\r\n### 创建项目的流程\r\n![HBuilder创建项目流程](amWiki/images/HBuilder创建.jpg)\r\n\r\n### 完成项目\r\n![HBuilder项目结构](amWiki/images/HBuilder目录.jpg)\r\n* HBuilder可以编写代码，而且使用也很方便\r\n* 如果你的代码已经编写完成，则只需要把新创建的项目中的对应的文件都替换掉就可以了\r\n* 项目中所有文件以及目录都不能包含中文和特殊字符，否则会导致打包失败\r\n\r\n### 发布流程\r\n>做好上面的几步就可以发布项目了\r\n\r\n1. 配置项目的一些信息<br/>\r\n![HBuilder项目结构](amWiki/images/HBuilder打包1.jpg)<br/>\r\n这一步可以配置项目的基本信息、图标（如果不配置的话默认使用HBuilder的图标）、启动图片、权限配置、页面引用关系、SDK配置\r\n\r\n2. 右击项目，选择发行，你可以选择本地，或者云打包\r\n\r\n3. 选择发布的平台（安卓还是ios） 完成之后点击打包 <br/>\r\n![HBuilder选择平台](amWiki/images/HBuilder平台.jpg)\r\n\r\n4. 等待一段时间 <br/>\r\n![HBuilder项目结构](amWiki/images/HBuilder等.jpg)\r\n\r\n5. 打包好的安装包 <br/>\r\n![HBuilder打包好的安装包](amWiki/images/HBuilder完.jpg)\r\n","timestamp":1585877701769},{"name":"01-ECMAScript介绍.md","path":"001-前端/08-JavaScript/001-ECMA/01-ECMAScript介绍.md","content":"# ECMAScript介绍\r\n> JavaScript 是一种基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。\r\n\r\nhttp://www.cnblogs.com/niulina/p/5715430.html\r\n\r\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F(String_literals)\r\n\r\nJavaScript ( JS ) 是一种具有函数优先的轻量级解释型或即时编译型的编程语言。\r\n\r\n虽然它是作为开发Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 node.js。\r\n\r\n## JavaScript组成部分\r\n- ECMAScript ，是Javascript基础规范，定义了Javascript基础语法\r\n- BOM 浏览器对象模型\r\n- DOM 文档对象模型\r\n\r\n## ECMAScript版本\r\n从ECMAScript2016开始，ECMAScript将进入每年发布一次新标准的阶段。\r\n\r\n| ES1 | ES2 | ES3| ES4 | ES5 | ES5.1 | ES6=ES2015 | ES2016 | ES2017 | ES2018 | ...\r\n|-----|------|-----|----|-----|-----|-----|-----|-----|-----|-----|\r\n| 1997 |1998 |1999 |夭折 |2009 |2011 |2015 |2016 |2017 |2018 | .... |\r\n\r\n\r\n## JavaScript 在你的页面上做什么？\r\n让我们简单地回顾当你在浏览器中读取一个网页时发生什么（在文章 How CSS works 中第一次谈及到）。 当你在浏览器中读取一个网页，你在一个实行环境（浏览器标签）中运行你的代码（HTML, CSS 和 JavaScript）。这就像是一个工厂，获取原材料（代码）然后出产一个产品（网页）。\r\n\r\n![js做的事情](amWiki/images/execution.png)\r\n\r\n在 HTML 和 CSS 已经被集合和组装成一个网页后，浏览器的 JavaScript 引擎执行 JavaScript。这保证了当 JavaScript 开始运行时，网页的结构和样式已经在该出现的地方了。\r\n\r\n这是一个好事情，正如 JavaScript 的普遍用处是通过 DOM API（如之前提及的那样）动态地修改 HTML 和 CSS 来更新用户交界面。如果 JavaScript 在 HTML 和 CSS 加载完成之前加载运行，那么会发生错误。\r\n## 浏览器安全\r\n每个浏览器标签本身就是一个用来运行代码的分离的容器（这些容器用专业术语称为“运行环境”）——这意味着在大多数情况中，每个标签中的代码是完全分离地运行，而且在一个标签中的代码不能直接影响在另一个标签中的代码——或者在另一个网站中的。这是一个好的安全措施\r\n\r\n\r\n\r\n## JavaScript特点\r\n1. 弱类型\r\n  > JavaScript是弱类型语言。但所谓弱类型语言，只表明该语言在表达式运算中不强制效验运算元的数据类型。\r\n2. 解释型(解释型或即时编译型)\r\n3. 基于对象\r\n   > js种所有数据根源上都是对象\r\n4. 事件驱动\r\n5. 单线程/异步(callback)\r\n\r\n\r\n### 解释代码 vs 编译代码\r\n在编程环境中，你或许听说过这两个术语 解释 [interpreted] 和 编译 [compiled]。JavaScript 是一个解释语言——代码从上到下运行，而运行的结果会马上被返回。在浏览器运行代码前，你不必先把它转化为其他形式。\r\n\r\n另一方面来说，编译语言则需要在运行前转化为另一种形式。比如说 C/C++ 则要先被编译成汇编语言，然后再由电脑运行。\r\n\r\n解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译。省去编译过程，但是每执行一次就要翻译一次，效率比较低\r\n\r\n### 异步编程\r\nJavaScript 由于某种原因是被设计为单线程的，同时由于 JavaScript 在设计之初是用于浏览器的 GUI 编程，这也就需要线程不能进行阻塞。\r\n\r\n所以在后续的发展过程中基本都采用异步非阻塞的编程模式。\r\n\r\n简单来说，异步编程就是在执行一个指令之后不是马上得到结果，而是继续执行后面的指令，等到特定的事件触发后，才得到结果。\r\n\r\n也正是因为这样，我们常常会说: JavaScript 是由事件驱动的。\r\n\r\n\r\n## 怎样向你的页面添加 JavaScript？\r\nJavaScript 以一种近似于 CSS 的方式应用到你的 HTML 页面中。尽管 CSS 使用 `<link>` 元素去应用外部的样式表 [stylesheet] 和 `<style>` 元素去应用内部的样式表到 HTML，JavaScript 只需要在 HTML 世界里的一个元素—— `<script>` 元素。\r\n\r\n### 内部的 JavaScript\r\n```html\r\n<script>\r\n\r\n  // JavaScript goes here\r\n\r\n</script>\r\n```\r\n### 外部的 JavaScript\r\n外部的 JavaScript命名为 script.js ——保证它以 .js 为文件扩展名，因为这是它被认作是 JavaScript 的方式。\r\n```html\r\n<script src=\"script.js\"></script>\r\n```\r\n\r\n## 注释\r\n一个单行注释书写在一个双正斜杠后 (`//`)，比如：\r\n```js\r\n// I am a comment\r\n```\r\n一个多行注释书写在字符串` /* `和 `*/` 之间， 比如：\r\n```js\r\n/*\r\n  I am also\r\n  a comment\r\n*/\r\n```\r\n\r\n\r\n## 名词解释\r\n### 标识符\r\n标识符可以分为两类：\r\n- 用于命名语法(以及类型)，被称为\"语法关键字\"\r\n- 用于命名值(的存储位置)，被称为\"变量\"和\"常量\"\r\n\r\n由此引入了一个概念：绑定。\r\n从标识符的角度来说，就分为：\r\n- 语法关键字与语法(语义)逻辑的绑定，语法关键字与语法(语义)逻辑绑定的结果是作用域的限定；\r\n- 变量与它所存储值得位置的绑定，变量对位置的绑定的结果，则是变量生存周期的限定；\r\n\r\n### 声明\r\n程序语言中\"声明\"的意义：所谓声明，即是约定变量的生存周期和逻辑的作用域。\r\n- 纯粹陈述\"值\"的过程，被称为变量和类型声明；\r\n- 纯粹陈述\"逻辑\"的过程，被称为语句(含流程控制子句)；\r\n- 陈述\"值与(算法的)逻辑\"的关系的过程，被称为表达式；\r\n\r\n### 错误\r\n错误分为语法错误和运行错误。\r\n\r\n一般来说，JavaScript引擎会在代码装入时先进行语法分析，如果语法分析通不过，整个脚本代码块都不会执行；(如一个人在演讲时，先检查演讲稿语句是否通顺，不通顺则不讲)\r\n\r\n当语法分析通过时，才会执行这段脚本代码。若在执行过程中出错，那么在同一代码上下文中、出错点之后的代码将不再执行。（详见`错误与异常`一节）\r\n\r\n\r\n### 语句结尾分号\r\njs语句的一个分号代表了一段代码的结束，但问题是javascript允许不写分号，这样就出现了一个问题，代码的结束与否不是你来决定的而是由程序来决定的，而程序也不是万能的，往往它只是走的某个规则，而如果你写的这段代码和它的规则不符，最终的结果就有些不如人意了。\r\n```js\r\nvar n1 = 10, n2 = 100\r\n(n1 + n2) * 10    // 报错： 100 is not a function\r\n```\r\n\r\n会导致上下行解析出问题的符号有 5 个：`()`，`[]`，`\\`，`+`，`-`。\r\n\r\n总结：**一行开头是`括号`或者`方括号`的时候上一行必须分号结束，其他时候都可以不需要。**\r\n\r\n \r\n## 输入输出工具\r\n1. `document.write()`  输出内容到body页面\r\n  ```js\r\n  documetn.write(\"hello, world\")\r\n  ```\r\n2. `prompt()` 输入框\r\n  ```js\r\n  prompt(\"请输入信息\")\r\n  ```\r\n3. `alert()` 弹出框\r\n  ```js\r\n  alert(\"用户名错误\")\r\n  ```\r\n4. `console.log()`  输出内容到浏览器控制台\r\n  ```js\r\n  console.log(\"js是一门编程语言\")\r\n  ```\r\n","timestamp":1585877701769},{"name":"02-变量与数据类型.md","path":"001-前端/08-JavaScript/001-ECMA/02-变量与数据类型.md","content":"# 变量与数据类型\r\n> 变量，就是一个用于存放数值的容器。\r\n\r\n## 变量\r\n### 变量是什么?\r\n变量，就是一个用于存放数值的容器。\r\n\r\n```\r\nvar name = \"张三\";\r\nalert(\"hello \"+name); // hello 张三\r\n\r\nvar num = 100;\r\nalert(num*10);        // 1000\r\n```\r\n变量是用来存储数值的。变量不是数值本身，它们仅仅是一个用于存储数值的容器。\r\n你可以把变量想象成一个个用来装东西的纸箱子。\r\n\r\n<img src=\"amWiki/images/boxes.png\" width=\"50%\" alt=\"存储数据\"/>\r\n\r\n- 变量的独特之处在于它存放的数值是可以改变的。\r\n- 变量它们能够存储任何的东西 -- 不只是字符串和数字。变量可以存储更复杂的数据，甚至是函数。\r\n\r\n### 声明变量\r\nJavaScript有三种声明方式。\r\n\r\n| 关键词 | 描述    |\r\n| :------------- | :------------- |\r\n| var       | 声明一个变量，可赋一个初始化值。    |\r\n| let       | 声明一个块作用域的局部变量，可赋一个初始化值。    |\r\n| const       | 声明一个块作用域的只读的命名常量。   |\r\n\r\n\r\n#### 基本语法\r\n声明一个变量的语法是在var关键字之后加上这个变量的名字：\r\n```\r\nvar myName;\r\nvar myAge;\r\n```\r\n变量声明后，即可使用，以下通过输出变量方式来使用：\r\n```\r\nconsole.log(myName);   //undefined\r\nconsole.log(myAge);    //undefined\r\n```\r\n以上这两个变量并没有数值，他们是空的容器(在Javascript中用undefined表示，未定义)。\r\n\r\n同时声明多个变量,通过`,`隔开：\r\n```\r\nvar myName,myAge,mySex;\r\n```\r\n\r\n\r\n> 提示: 千万不要把两个概念弄混淆了，“一个变量存在，但是没有数值”和“一个变量并不存在” — 他们完全是两回事.\r\n\r\n```\r\n//声明未赋值\r\nvar myName;\r\nconsole.log(myName);     //输出undefined\r\n\r\n//未声明\r\nconsole.log(firstName);  //报错 firstName is not defined\r\n```\r\n\r\n> 用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined。\r\n\r\n#### 初始化变量\r\n\r\n\r\n初始化变量有两种方式：\r\n1. 先声明再初始化\r\n2. 声明变量并初始化\r\n\r\n先声明再初始化，方法如下，在变量名之后跟上一个“=”，然后是值:\r\n```\r\nvar myName;\r\nvar myAge;\r\n\r\nmyName=\"Nico\";\r\nmyAge = 19;\r\n\r\nconsole.log(myName);  //输出 Nico\r\nconsole.log(myAge);   //输出 19\r\n```\r\n【重点】声明变量并初始化【重点】:\r\n```\r\nvar myName = \"Nico\";\r\nvar myAge = 19;\r\n\r\nconsole.log(myName);  //输出 Nico\r\nconsole.log(myAge);   //输出 19\r\n```\r\n#### 更新变量\r\n一旦变量赋值，您可以通过简单地给它一个不同的值来更新它。\r\n```\r\nvar myName = \'Nico\';\r\nconsole.log(myName); //输出 Nico\r\n\r\nmyName = \"Allcky\";\r\nconsole.log(myName); //输出 Allcky\r\n```\r\n\r\n### 标识符命名规范\r\n1. 严格区分大小写\r\n2. 命名必须以字母或_或$开头，余下的部分可以是任意的字母，数字，或者是_或者是$\r\n3. 不能用关键字或者是保留字命名。\r\n4. javascript自己的命名习惯\r\n    - 驼峰命名法：getElementById\r\n    - 首字母大写：Object\r\n5. 命名要有意义。\r\n\r\n\r\n|  关键字保留字  ||||||\r\n|:--------|:---------:|:-------:|:-----:|:-----:|:-----:|\r\n| abstract | arguments | boolean | break | byte | case |\r\n|catch|char|class|const|continue|debugger|\r\n|default|delete|do|double|else|enum|\r\n|eval|export|extends|false|final|finally|\r\n|float|for|function|goto|if|implements|\r\n|import|in|instanceof|int|interface|let|\r\n|long|native|new|null|package|private|\r\n|protected|public|return|short|static|super|\r\n|switch|synchronized|this|throws|transient|true|\r\n|try|typeof|var|void|volatile|while|\r\n|with|yield||||||\r\n\r\n> Javascript 的保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。\r\n\r\n```\r\nvar for = 123;\r\n//Uncaught SyntaxError: Unexpected token for\r\n```\r\n### 常量(Constants)\r\n你可以用关键字 const 创建一个只读的常量。\r\n```\r\nconst PI = 3.141592654 ;\r\nconsole.log(PI); //输出 3.141592654\r\n```\r\n- 常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。它必须被初始化为某个值。\r\n- 常量的作用域规则与 let 块级作用域变量相同。若省略const关键字，则该标识符将被视为变量。\r\n- 在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。\r\n\r\n例如：\r\n```\r\nfunction f() {};\r\nconst f = 5;\r\n//Uncaught SyntaxError: Identifier \'f\' has already been declared\r\n//语法错误： 标识符 \'f\' 已经被声明\r\n```\r\n> 常量标识符的命名规则和变量相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。\r\n\r\n注: 常量对象的属性是不受保护的,所以可以修改常量对象的属性：\r\n```\r\nconst MY_OBJECT = {\"key\": \"value\"};\r\nMY_OBJECT.key = \"otherValue\";\r\n```\r\n利用 ES6中对象的方法 `Object.freeze()`可将对象冻结，从而无法修改其属性 (详见`Object对象`一节)\r\n\r\n\r\n### 变量声明兼容性\r\n> `let` 与 `const`是ES6新增声明方式，其存在兼容问题：\r\n\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=let\" frameborder=\"0\"></iframe>\r\n\r\n\r\n## 数据类型\r\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在JavaScript中定义了以下几种数据类型：\r\n\r\n\r\nECMAScript 有 6 种初始类型（primitive type），即 `Undefined`、`Null`、`Boolean`、`Number`、`String`和ES6新增的`Symbol`。  \r\n1种引用类型，即`Object`\r\n<table>\r\n    <tr>\r\n        <th>分类</th>\r\n        <th>类型</th>\r\n        <th>值</th>\r\n    </tr>\r\n    <tr>\r\n        <td rowspan=\"6\">初始类型</td>\r\n        <td>undefined</td>\r\n        <td>undefined</td>\r\n    </tr>\r\n    <tr>\r\n        <td>null</td>\r\n        <td>一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。</td>\r\n    </tr>\r\n    <tr>\r\n        <td>string</td>\r\n        <td>单双引号引起来的数据</td>\r\n    </tr>\r\n    <tr>\r\n        <td>number</td>\r\n        <td>包括整型和浮点型。科学计数法。支持二进制、八进制、十进制、十六进制。</td>\r\n    </tr>\r\n    <tr>\r\n        <td>boolean</td>\r\n        <td>true false</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Symbol</td>\r\n        <td>[ES6]表示独一个一无二的值。</td>\r\n    </tr>\r\n    <tr>\r\n        <td>引用类型</td>\r\n        <td>Object</td>\r\n        <td>包含相关属性和方法的一个集合。包含Function、Array、Object</td>\r\n    </tr>\r\n</table>\r\n\r\n### string类型\r\n\r\n用单双引号来说明，他所包围的值都可以是字符串。\r\n\r\n> 引号包裹的字符串中间不允许换行\r\n\r\n单双引号的用法：\r\n- 效率是一样的\r\n- 只能成对出现，不能相互交叉使用\r\n- 可以相互嵌套。\r\n\r\n还包括一些特殊的字符:\r\n\r\n| 字符    | 描述    |\r\n| :------------- | :------------- |\r\n| \\0      | Null字节       |\r\n| \\b\t|退格符|\r\n| \\f\t|换页符|\r\n| \\n\t|换行符|\r\n| \\r\t|回车符|\r\n| \\t\t|Tab (制表符)|\r\n| \\v\t|垂直制表符|\r\n| \\\'\t|单引号|\r\n| \\\"\t|双引号|\r\n| \\\\\t|反斜杠字符（\\）|\r\n| \\XXX\t|由从0到377最多三位八进制数XXX表示的 Latin-1 字符。例如，\\251是版权符号的八进制序列。|\r\n| \\xXX\t|由从00和FF的两位十六进制数字XX表示的Latin-1字符。例如，\\ xA9是版权符号的十六进制序列。|\r\n| \\uXXXX\t|由四位十六进制数字XXXX表示的Unicode字符。例如，\\ u00A9是版权符号的Unicode序列。见Unicode escape sequences (Unicode 转义字符).|\r\n| \\u{XXXXX}|\tUnicode代码点 (code point) 转义字符。例如，\\u{2F804} 相当于Unicode转义字符 \\uD87E\\uDC04的简写。|\r\n\r\n### number类型\r\nnumber类型包括整型和浮点型。支持十进制（基数为10）、十六进制（基数为16）、八进制（基数为8）以及二进制（基数为2）表示。\r\n\r\n| 进制     | 表示     |\r\n| :------------- | :------------- |\r\n| 十进制       | 十进制整数字面量由一串数字序列组成，且没有前缀0。     |\r\n| 八进制       | 八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。     |\r\n| 十六进制       | 十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。     |\r\n| 二进制      | 二进制整数以0b（或0B）开头，只能包含数字0和1。   |\r\n\r\n```\r\nvar n1 = 100; //十进制\r\n\r\nvar n2 = 071;  //八进制\r\nvar n3 = 0o71; //八进制 ES6规定 0o开头\r\n\r\nvar n4 = 0xa9; //十六进制\r\n\r\nvar n5 = 0b11; //二进制\r\n```\r\n> 严格模式下，八进制整数字面量必须以0o或0O开头，而不能以0开头。\r\n\r\n\r\n用科学计数法来表示，还包括一些特殊的值：\r\n```\r\n# 最大值\r\nNumber.MAX_VALUE    //1.7976931348623157e+308\r\n\r\n# 最小值\r\nNumber.MIN_VALUE    //5e-324\r\n\r\nvar n1 = 3e2; //3*100 = 300\r\nvar n2 = 5e3; //5*1000 = 5000\r\nvar n3 = 5.3e3; //5.3*1000 = 5300\r\n\r\n# 无穷大\r\nInfinity    // 1/0 = Infinity\r\n```\r\n### boolean类型\r\n\r\nBoolean.  布尔值，true 和 false. 表示\"真\"和\"假\"\r\n\r\n### undefined\r\n指的就是变量创建后但是没有赋值，而变量的默认值就是undefined.\r\n\r\n如：\r\n```js\r\nvar a;\r\nconsole.log(a)    // undefined\r\n```\r\n### null\r\nnull. 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或其他变量完全不同。\r\n\r\n\r\n### Symbol\r\nSymbol ( 在 ECMAScript 6 中新添加的类型).。一种数据类型，它的实例是唯一且不可改变的。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\r\n\r\n### Object\r\n引用类型: 引用类型是一种数据结构，用于将数据和功能组织在一起，存储大量的数据\r\n\r\n> 三大引用类型: Object 、Array 、Function\r\n\r\n## 判断数据类型\r\n### 操作符 `typeof`\r\n#### 语法\r\n`typeof`运算符后跟操作数：\r\n```js\r\ntypeof operand\r\n// or\r\ntypeof (operand)\r\n```\r\n#### 返回值\r\n下表总结了`typeof`可能的返回值\r\n\r\n 类型 | 结果\r\n---|---\r\nUndefined | \"undefined\"\r\nNull | \"object\"\r\nBoolean | \"boolean\"\r\nNumber | \"number\"\r\nString | \"string\"\r\nSymbol  | \"symbol\"\r\n函数对象  | \"function\"\r\n任何其他对象  | \"object\"\r\n\r\n#### 示例\r\n```js\r\n// Number\r\ntypeof 37 === \'number\';\r\ntypeof NaN === \'number\';\r\ntypeof Math.PI === \'number\';\r\n\r\n// String\r\ntypeof \"\" === \'string\';\r\ntypeof \"bla\" === \'string\';\r\ntypeof (typeof 1) === \'string\'; // typeof总是返回一个字符串\r\n\r\n// Object\r\ntypeof {a:1} === \'object\';\r\ntypeof [1, 2, 4] === \'object\';\r\ntypeof null === \'object\';\r\n```\r\n\r\n##### typeof null === \'object\'\r\n>  特殊值null被认为是一个空的对象引用\r\n\r\n### 通用但很繁琐的方法： prototype\r\n#### 语法\r\n```js\r\nObject.prototype.toString.call(x)   //返回x的数据类型\r\n```\r\n\r\n#### 示例\r\n```js\r\nconsole.log(Object.prototype.toString.call(new Date()))     // [object Date]\r\nconsole.log(Object.prototype.toString.call(null)     // [object Null]\r\nconsole.log(Object.prototype.toString.call(new Array()))    // [object Array]\r\nconsole.log(Object.prototype.toString.call(\'dd\'))     // [object String]\r\nconsole.log(Object.prototype.toString.call(undefined))     // [object Undefined]\r\nconsole.log(Object.prototype.toString.call(Symbol(\'d\')))     // [object Symbol]\r\n```\r\n>这种方法比较麻烦，但是它能够很好的检测出各种类型。\r\n\r\n## 变量在内存划分\r\n> 变量类型分两种是由于其在内存中存储方式不同：基本类型的数据是存放在`栈`内存中的，而引用类型的数据是存放在`堆`内存中的\r\n\r\n![基本类型与引用类型的存储方式](assets/001/02-1542881380000.png)  \r\n\r\n### 堆栈的概念\r\n两者都是存放临时数据的地方。     \r\n栈是先进后出的，就像一个桶，后进去的先出来，它下面本来有的东西要等其他出来之后才能出来。      \r\n堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。          \r\n栈区（stack） 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。             \r\n堆区（heap） 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。              \r\n堆（数据结构）：堆可以被看成是一棵树，如：堆排序；            \r\n栈（数据结构）：一种先进后出的数据结构。           \r\n\r\n\r\n\r\n### 两种数据类型的存放\r\n基本类型由于数据简单，会存放到内存栈区，栈区包括了 变量的标识符和变量的值：   \r\n![栈区示意图](assets/001/02-1542881486000.png)\r\n\r\n>  栈区： 长度固定，读取速度快\r\n\r\n\r\n引用类型由于数据结构较大，会将数据存放到堆区，堆区的地址存放到栈区进行访问：         \r\n![堆区示意图](assets/001/02-1542881596000.png)\r\n\r\n> 堆区： 长度不固定，读取速度慢\r\n\r\n- https://segmentfault.com/a/1190000005863067\r\n","timestamp":1585877701769},{"name":"03-运算符.md","path":"001-前端/08-JavaScript/001-ECMA/03-运算符.md","content":"# 运算符\r\n>运算符用于执行程序代码运算，会针对一个或以上操作数项目来进行运算。\r\n\r\nJavaScript中的运算符主要分为算术运算符、关系(比较)运算符、赋值运算符、逻辑运算符、一元运算符、三元运算符、特殊运算符。\r\n\r\n## 算数运算符\r\njavascript中的算术运算符中有加(+)、减(-)、乘(`*`)、除(/)、取余(%)、自增(++)、自减(--)、求幂(**)\r\n\r\n### 加法(+)\r\njavascript中的+主要用于两个方面，一个是加法运算，另一个是用来进行字符串拼接，加法运算规则如下：\r\n\r\n1. 数字与除字符串以外类型相加： 将其他类型转化为数字后算术相加，无法转化则结果为NaN\r\n   * true 转化为1\r\n   * false、null转化为0\r\n   * undefined 无法转化\r\n2. NaN与除字符串以外类型相加结果都为NaN\r\n3. 字符串与任意类型相加： 拼接\r\n    ```js\r\n    1+false    //1\r\n    \'1\'+1      //\'11\'\r\n    NaN+\'1\'     //\'NaN1\'\r\n    [1,2,3]+1    //\"1,2,31\"\r\n    {a:2}+\'1\'    // 1\r\n    ```\r\n\r\n\r\njs中常常涉及到以字符串输出变量的值，这时需要将变量与字符串进行拼接，字符串拼接有两种方式：\r\n##### 1. + 拼接\r\n\r\n变量必须放到字符串引号外部，变量与字符串之间用`+`连接：\r\n```js\r\nvar name = \"张三\", age = 20, sex = \"男\";\r\nalert( name + \"的年龄是:\" +age+ \"，性别是:\" +sex )\r\n```\r\n\r\n##### 2. es6模板字符串 (ie不支持)\r\n> 传统`+`拼接字符串相当繁琐不方便，ES6 引入了模板字符串解决这个问题\r\n\r\n模板字符串用 反单引号(\\`) 标识，可以当作普通字符串使用，或者在字符串中嵌入变量:\r\n```js\r\nvar name = \"张三\", age = 20, sex = \"男\";\r\nalert( `${name}的年龄是:${age}，性别是:${sex}` )\r\n```\r\n\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=template-literals\" frameborder=\"0\"></iframe>\r\n\r\n模板字符串特点：\r\n\r\n    1. 模板字符串中嵌入变量，需要将变量名写在`${}`之中，变量与字符串不需要 `+`连接\r\n    2. `${}` 中可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性： `${num + 1}`\r\n    3. 模板字符串中可以换行\r\n    4. 模板字符串中可以随意使用单双引号\r\n\r\n\r\n### 减法(-)\r\n1. 数字和字符串相减 :\r\n    * 字符串全部由数字组成，将字符串转化为数字，再相减\r\n    * 字符串不能转化为数字，结束是 NaN\r\n    * null转化为0  undefined转化为NaN  true为1 false为0\r\n2. 字符串和字符串相减 :  和数字和字符串相减规则相同\r\n```js\r\n\'11a\'-1    //NaN\r\n\'11\'-1     //10\r\n```\r\n\r\n#### 加减法做数字与字符串的转换\r\n* 数字转化为字符串: `num + \"\"`        \r\n* 字符串转化为数字: `num - 0`\r\n\r\n### 乘法运算\r\n1. 数字与字符串运算：\r\n    * 将字符串尝试着转化为数字，进行运算\r\n    * 字符串不能转化为数字，结果是 NaN\r\n2. null转化为0  true为1 false为0    空字符串转为0\r\n3. Undefined乘所有数据类型的都为NaN\r\n4. 字符串和字符串运算 :  和数字和字符串运算规则相同\r\n\r\n```js\r\ntrue*null      //0\r\n\'11\'*\'11\'    // 121\r\n\'1a\'*22    //NaN\r\n```\r\n\r\n### 除法运算\r\n1. 字符串类型 数字类型与 null 相除 结果为 Infinity\r\n2. 字符串类型、数字类型 null与 Undefined 相除 结果为 NaN\r\n3. 字符串类型 数字类型 null与 字符串类型、数字类型 null相除进行相应转换做除法运算\r\n     * 字符串不能转为数字则结果为NaN\r\n     * 空字符串转为0\r\n\r\n```JS\r\n11/null              //Infinity\r\n\'11\'/\'11\'            // 1\r\n\'11a\'/\'11\'            // NaN\r\n```\r\n\r\n### 取余(%)\r\n取余，即取余数，如 `10 % 3` 则指 10除以3的余数\r\n\r\n> 用于取一段范围的值 <br> 一般不用于小数，因为结果不确定（不精确）。\r\n\r\n1. Undefined 与所有数据类型的 取余 都为NaN\r\n2. 其余数据类型先进行转换，能转为数字则进行取余运算，否则为NaN\r\n```JS\r\n\'\'%1        // 0\r\n11%0        // NaN\r\n11%null     // NaN\r\n```\r\n判断数字num是否是偶数：\r\n```js\r\nif(num%2==0){\r\n    alert(num + \"是偶数\")\r\n}\r\n```\r\n\r\n### ++ 自加 -- 自减\r\n> 规则： i++  相当于变量i自身值变大1，类似i+=1； i--同理\r\n> `++`可写在变量前或后： `i++`是先访问i然后再自增，而`++i`则是先自增然后再访问i的值\r\n\r\n```js\r\nvar i = 10;\r\nconsole.log(i++);  // 10   先输出，后自增。 console.log(i);  i++;\r\nconsole.log(++i);  // 11   先自增，后输出。 i++;  console.log(i);\r\n```\r\n### 求幂运算符\r\n> `x**y` 取x的y次方，同`Math.pow(x, y)`\r\n\r\n```js\r\n3 ** 2  //9\r\n效果同\r\nMath.pow(3, 2) //9\r\n```\r\n\r\n\r\n## 关系(比较)运算符\r\n>比较运算符得到的结果 都是 boolean\r\n>主要有以下几种比较运算符               \r\n `>`  <  ==   >=   <=  != (不相等)  ===\r\n\r\n\r\n### 比较规则\r\n1. 将比较的对象尝试转化为数字,能转化则按照数字比较,不能转化则为false\r\n2. `NaN`与任意数据比较结果均为 false\r\n3. 字符串和字符串比较, 比较第一个字符的unicode编码值，第一个字符要是相同，就比较第二个，依次往下(ASCII码表在最末尾)\r\n```js\r\n  \'10000\' < \'2\'   //1的unicode值比2的unicode值小  true       \r\n  \'10000\' > 2    //转成数字比较  true\r\n```\r\n\r\n\r\n3. ==和全等（===）的区别\r\n    * `==`是只比较两变得值(如果两边类型不相同，则先尝试着转化，然后再比较，所以耗时比`===`多)\r\n        * 0==undefined (false)\r\n        * 0==null (false)\r\n        * NaN == NaN (false)\r\n        * undefined==null (true)\r\n    * `===`比较两边的值和类型，都相等才返回true；\r\n4. === 和object.js()的区别\r\n```js\r\nObject.is(+0,-0);               //false\r\n+0===-0                         //true\r\nObject.is(NaN,NaN);             //true\r\nNaN===NaN                       //false\r\n```\r\n\r\n## 赋值运算符\r\n> `=、+=、-=、*=、/=、%=、**=`   运算符右边的值赋给左边的变量\r\n\r\n| 运算符 | 实例 | 等价于 |\r\n| ---- | ---- | ---- |\r\n| `=` | a=25 | a=25 |\r\n| `+=` | a+=25 | a=a+25 |\r\n| `-=` | a-=25 | a=a-25 |\r\n| `*=` | a*=25 | a=a*25 |\r\n| `/=` | a/=25 | a=a/25 |\r\n| `%=`| a%=25 | a=a%25 |\r\n| `**=` | a**=3 | a=a^3 |\r\n\r\n\r\n## 逻辑运算符\r\n> 在js逻辑运算中，0、\"\"、null、false、undefined、NaN都会判为false，其他都为true\r\n\r\n1. 与 `&&`\r\n    * 只要有一个是假，结果就是假\r\n    * &&左侧是真，结果取右侧； 左侧假，结果取左侧值\r\n2. 或 `||`\r\n    * 只要有一个是真，结果就是真\r\n    * ||左侧是真，结果取左侧； 左侧假，结果取右侧值\r\n3. 非 `!`\r\n    * 取反\r\n    * 结果是`boolean`值\r\n\r\n总结： 与或运算，哪一侧能决定表达式真假性，则结果取哪一侧。\r\n\r\n例:\r\n```js\r\n0 && 1    // 0     \r\n0 || 1    // 1\r\n\r\n1 && 2     // 2\r\n1 || 2     // 1\r\n\r\n!1     // false\r\n!0     // true\r\n```\r\n\r\n#### 逻辑运算符的应用：短路原则  \r\n> 与或运算左侧结果已经确定整个表达式真假性，则右侧不再计算\r\n\r\n* &&与运算：左侧是假，右侧不进行计算\r\n* ||或运算：左侧是真，右侧不进行计算\r\n\r\n## 一元运算符\r\n只能操作一个值的操作符就叫做一元操作符\r\n\r\n* new (创建对象) delete (删除对象上的内容)\r\n* typeof -(负号) +(正号)\r\n* instanceof (判断对象是否由一个构造函数实例化)\r\n\r\n\r\n## 三元运算符\r\n> 基于某些条件对变量进行赋值的条件运算符，\r\n\r\n```js\r\nvar iablename=(condition)?value1:value2   \r\n```\r\ncondition为true则variablename取:前的值，也就是value1，否则取:后的值，也就是value2\r\n\r\n### 三元运算符使用技巧\r\n1. 可以简化条件判断\r\n```js\r\nvar fee;\r\nif(isMember){\r\n    fee=\"￥2.00\";\r\n}else{\r\n    fee=\"￥10.00\";\r\n}\r\nfee=isMember ? \"￥2.00\" : \"￥10.00\";\r\n```\r\n2. 三元运算符用来执行多个操作,用小括号包裹，再用逗号隔开语句。\r\n\r\n\r\n## 特殊运算符\r\n* , 逗号 —— 分隔数据\r\n    ```js\r\n    var num1 = 1, num = 2, num3 = 3;\r\n    ```\r\n* () 小括号运算符 —— 提升算术优先级\r\n    ```js\r\n    var i = 1 + 3 * 5;\r\n    console.log(i);   // 16\r\n    var l = (1 + 3) * 5;\r\n    console.log(l);   // 20\r\n    ```\r\n\r\n\r\n\r\n## 运算符的优先级\r\n>下表中的运算符按从最高到最低的优先级列出。具有相同优先级的运算符按从左至右的顺序求值。\r\n\r\n| 运算符 |  运算符类型 |\r\n| ---- | ---- |\r\n| (…) | 圆括号 |\r\n| ….… …[…] new…(…) …(…) | 成员访问 需计算的成员访问 new(带参数列表) 函数调用 |\r\n| new … | new(无参数列表) |\r\n| …++ …-- | 后置递增(运算符在后) 后置递减(运算符在后) |\r\n| !… ~… +… -… ++… --… typeof… void… delete… await… | 逻辑非 按位非 一元加法 一元减法 前置递增 前置递减 typeof void delete await |\r\n| \t…**… | 幂 |\r\n| …*… …/… …%… | 乘法 除法 取余 |\r\n| + - | 加法  减法 |\r\n| < <= > >= in instanceof | 小于 小于等于 大于 大于等于 in 判断是否为这个构造函数实例化 |\r\n| == != === !== | 等号 非等 全等 非全等 |\r\n| && | 逻辑与 |\r\n| &#166;&#166; | 逻辑或 |\r\n| … ? … : … | 三元运算符 |\r\n| = += -=  *= /= %= **= | 赋值 |\r\n| , | \t逗号 |\r\n\r\n![ASCII码表](amWiki/images/ASCII.jpg)\r\n","timestamp":1585877701769},{"name":"04-流程控制.md","path":"001-前端/08-JavaScript/001-ECMA/04-流程控制.md","content":"# 流程控制\r\n> **流程** 指的是代码的执行顺序  \r\n> **流程控制** 指通过规定的语句让程序代码有条件的按照一定的方式执行\r\n\r\n1. 顺序结构 —— 按照书写顺序从上到下的执行代码\r\n2. 选择(分支、条件)结构 —— 根据给定的条件有选择的执行相应的语句\r\n3. 循环结构 —— 在给定的条件满足的情况下，反复的执行同一段代码\r\n\r\n## 选择结构(条件判断)\r\n### if分支\r\n1. 单路分支\r\n```js\r\nif(判断条件){    \r\n    条件为真，执行该处代码\r\n}\r\n```\r\n\r\n2. 双路分支(两条分支二选一)\r\n```js\r\nif(判断条件){    \r\n    条件为真，执行该处代码\r\n}else{\r\n    条件为假，执行该处代码\r\n}\r\n```\r\n\r\n3. 多路分支\r\n```js\r\nif(条件1){\r\n    条件1 成立,执行代码\r\n}else if(条件2){\r\n    条件1不成,条件2成立,  执行代码\r\n}else if(条件3){\r\n    条件1 条件2都不成立,条件3成立,  执行代码\r\n}else{\r\n    所有条件都不成立,  执行代码\r\n}\r\n```\r\n\r\n4. 嵌套分支\r\n```js\r\nif (条件1){\r\n    条件1 成立,执行代码\r\n    if(条件2){\r\n        条件1 条件2 都成立,执行代码\r\n        if(条件3){\r\n            条件1 条件2 条件3 都成立,执行代码\r\n        }else{\r\n            条件1 条件2成立，条件3不成立，执行代码\r\n        }\r\n    }else if(条件4){\r\n        条件1成立 条件2不成立,执行代码\r\n    }\r\n}\r\n```\r\n\r\n### switch 分支(多选一的条件判断)\r\n```js\r\nswitch (需要判断的值) {\r\n    case 值1:\r\n        当需要判断的值==值1 ,执行代码\r\n        break;\r\n    case 值2:\r\n        当需要判断的值==值2 ,执行代码\r\n        break;\r\n    case 值3:\r\n        当需要判断的值==值3 ,执行代码\r\n        break;\r\n}\r\n```\r\n\r\n**if分支与switch分支的区别与选择:** </br>\r\n  * 当判断某种范围时用if，当判断单个值时用switch\r\n  * 各个条件满足的情况不可重复，放置造成不可预期后果\r\n\r\n\r\n\r\n## 循环结构\r\n### for循环\r\n```js\r\nfor(var i = 0; i < 100; i++){\r\n    循环体\r\n    每次循环执行一次该处代码\r\n}\r\n```\r\n#### for循环的执行顺序\r\n> for循环四个要素： 起始值、终止值、步进值、循环体\r\n\r\n```js\r\nfor(起始值;终止值;步进值){\r\n    循环体;\r\n}\r\n```\r\n第一次循环的时候顺序为：起始值 => 终止值，判断终止值是否满足条件，不满足条件则结束循环，满足则继续循环 => 循环体  => 步进值;    \r\n后续的循环则不再执行起始值，其余顺序不变，直到终止值不满足条件，循环结束。\r\n\r\n\r\n#### `break`和`continue`\r\n* `break`:  语句可以立即退出循环，阻止再次反复执行任何代码。\r\n* `continue`:  语句退出当前循环，根据控制表达式还允许继续进行下一次循环。\r\n\r\n```js\r\nfor(var i=1;i<=10;i++) {\r\n    if(i==5) {\r\n        break;\r\n    }\r\n    console.log(i);     // 输出结果：1 2 3 4\r\n}\r\n\r\nfor(var i=1;i<=10;i++) {\r\n    if(i==5) {\r\n        continue;\r\n    }\r\n    console.log(i);    // 输出结果：1 2 3 4 6 7 8 9 10\r\n}\r\n```\r\n\r\n### `while`语句\r\n>在条件表达式为真的前提下，循环执行指定的一段代码，直到那个表达式不为真时结束循环。\r\n\r\n```js\r\n// 控制台顺序输出 1-5:\r\nvar i = 0;\r\nwhile (i < 5){\r\n\ti += 1;\r\n\tconsole.log(i);\r\n}\r\n```\r\n\r\n#### `for`循环和`while`循环的使用选择\r\n1. `for`循环必须知道循环次数，而`while`循环次数可以不确定\r\n2. 所以在已知循环次数情况下使用`for`循环\r\n3. 使用时优先考虑`for`循环，当无法写出循环条件的起始结束步进值时考虑用`while`循环\r\n\r\n\r\n### do-while语句\r\n> 先执行一次循环,再进行判断,所以循环至少迭代一次。\r\n\r\n```js\r\n// 控制台输出1-5 :\r\nvar i = 0;\r\ndo {\r\n   i += 1;\r\n\t console.log(i);\r\n} while (i < 5);\r\n```\r\n\r\n\r\n#### `while`循环和`do while`循环的使用选择\r\n1. `do while`循环先执行循环体后判断条件是否成立；\r\n2. `while`循环先判断条件是否成立，后执行循环体\r\n3. 所以`do while`循环的循环体至少执行一次\r\n4. 总结： 当循环的判断条件所需的值来自于循环体时，可以使用`do while`循环    \r\n\r\ndo while循环：获取小于0.5的随机数(不知道循环次数，判断条件来自于循环体)\r\n```js\r\nvar number;\r\ndo{\r\n    number = Math.random()\r\n}while(number>=0.5)\r\n```\r\n","timestamp":1585877701769},{"name":"001-函数定义与调用.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/001-函数定义与调用.md","content":"# 函数定义与调用\r\n\r\n## 什么是函数\r\n**函数** ：将完成某一特定功能的代码集合起来，并且可以重复调用的代码块。\r\n\r\n###  函数优点\r\n1. 使程序更加简洁\r\n- 逻辑性更调理\r\n- 调用更方便\r\n- 维护更加容易\r\n\r\n## 函数的声明方式\r\n### function关键字\r\n```\r\nfunction 函数名([参数1],[参数2],...[参数n]){\r\n    函数体\r\n    [retrun]  //返回值\r\n}\r\n```\r\n\r\n### 字面量定义的形式(匿名函数)\r\n```\r\nvar 变量=function ([参数1],[参数2]....){\r\n    函数体\r\n    [retrun]  //返回值\r\n}\r\n```\r\n\r\n### 实例化构造函数\r\n```\r\nvar 变量=new Function([参数1],[参数2]...,\"函数体\");\r\n```\r\n\r\n## 函数的调用方式\r\n### 通过括号调用 (用于具名函数的调用)\r\n- 函数名()\r\n- 变量名()\r\n\r\n```js\r\nfunction fun1(){}\r\nfun1()\r\n\r\nvar fun2 = function (){}\r\nfun2()\r\n```\r\n\r\n### 自调用 (用于匿名函数的调用，匿名函数还可以通引用变量来调用)\r\n```js\r\n//第一种\r\n(function (){})()\r\n\r\n//第二种\r\n!function(){\r\n\r\n}()\r\n\r\n//第三种\r\n(function(){\r\n\r\n}())\r\n```\r\n> 注意： 在进行函数自调用时，上一条语句必须结尾有`;`\r\n\r\n\r\n### 通过事件调用\r\n\r\n```html\r\n<script>\r\n    function fun(){}\r\n</script>\r\n<div onclick=\"fun()\"></div>\r\n```\r\n\r\n\r\n## 创建\\调用函数注意问题\r\n如果两个函数的命名相同，后面的将会覆盖前面的函数。\r\n\r\n```javascript\r\nfunction bb(){\r\n    alert(\"这是第一个声明\");\r\n}\r\nfunction bb(){\r\n    alert(\"这是第二个声明\");\r\n}\r\nbb(); //结果为  “这是第二个声明\r\n```\r\n\r\n以基本语法声明的函数，会在页面载入的时候提前解析到内存中，以便调用。所以可以在函数的前面调用。但是以字面量形式命名的函数，会在执行到他的时候，才进行赋值。所以只能在函数的后面调用。  \r\n\r\n```javascript\r\naa();      // 结果为 弹出 1\r\nfunction aa(){\r\n    alert(1)\r\n}\r\naa();      // 结果为 弹出 1\r\n```\r\n```javascript\r\naa();      // 报错 aa is not a function\r\nvar aa = function(){\r\n    alert(1)\r\n}\r\naa();\r\n```\r\n\r\n在不同的`<script></script>`块中，因为浏览器解析的时候是分块解析的，所以前面的块不能调用后面块的函数，所以在不同的块之间调用函数的时候，应该先定义后调用。    \r\n```html\r\n<script>\r\n    aa();      //报错\r\n</script>\r\n<script>\r\n    function aa(){\r\n        alert(1)\r\n    }\r\n</script>\r\n<script>\r\n    aa()       //结果为 弹出 1\r\n</script>\r\n```\r\n","timestamp":1585877701769},{"name":"002-函数参数、返回值.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/002-函数参数、返回值.md","content":"# 函数的参数\r\n\r\n## 什么是函数的参数\r\n> 当我们封装一个功能，例如十行十列表格，但是每次使用该功能时想动态改变实现效果，例如想输出为五行五列、两行两列的表格，这时就需要修改函数体代码。 而更好的方法就是，在调用时有使用者传入一些值来控制函数体中的相关功能，即可实现不同效果，这个使用者在调用函数时传入的值就是函数的参数。\r\n\r\n* 作用：可以动态的改变函数的变量的类型与值，使同一函数实现不同的效果\r\n* 形参：函数在定义时，括号里所定义的变量。 (形式上存在，只有在被调用时才有值)\r\n* 实参：函数在调用时，括号里所传入的值。  (进行函数调用时,它们都必须具有确定的值, 以便把这些值传送给形参)\r\n  ```javascript\r\n  // num 是形参\r\n  function ta(num){\r\n  \tfor(var i = 1;i <= num;i++){\r\n  \t    for(var j = 1;j <= num-i;j++){\r\n  \t\t    document.write(\"&nbsp;\");\r\n  \t    }\r\n  \t    for(var k = 1;k <= i*2-1;k++){\r\n  \t\t    document.write(\"*\");\r\n  \t    }\r\n  \t    document.write(\"<br>\");\r\n      }\r\n  }\r\n  ta(6);    // 6 是实参\r\n  ```\r\n\r\n在实参为形参传递过程中，实参和形参位于内存中两个不同地址中，实参先自己复制一次拷贝，再把拷贝复制给形参。所以，在函数体中，形参的变化不会对实参有任何的影响。例如：\r\n```js\r\nvar number = 10\r\nfunction fun(number){\r\n    number = 100\r\n}\r\n\r\nfun(number);\r\nalert(number);   // 10\r\n```\r\n\r\n\r\n\r\n## 参数详解\r\n\r\n### 参数类型\r\n参数可以是任何的数据类型\r\n  ```javascript\r\n  function TYPEOF(type){\r\n    alert(typeof type);\r\n  }\r\n  TYPEOF(1)\r\n  TYPEOF(\"a\")\r\n  TYPEOF(true)\r\n  TYPEOF(null)\r\n  TYPEOF()\r\n  //甚至可以传入函数：\r\n  TYPEOF(function(){alert(1)})\r\n  ```\r\n\r\n### 参数个数\r\n1. 实参与形参的个数相同时，一一对应。\r\n2. 实参小于形参时，形参自动赋值为undefined。\r\n\t```javascript\r\n\tfunction aa(a,b){\r\n\t    alert(a);\r\n\t    alert(b);\r\n\t}\r\n\taa(1);  //   1  undefined\r\n\t```\r\n3. 实参大于形参时，使用`arguments`对象来获取。\r\n\t```javascript\r\n\tfunction aa(a,b){\r\n\t    alert(a);\r\n\t    alert(b);\r\n\t    alert(arguments.length);\r\n\t    alert(arguments[2]);\r\n\t    alert(arguments.callee);\r\n\t}\r\n\taa(1,5,7);   //依次弹出 1  5  3   7  函数本身\r\n\t```\r\n4. arguments对象\r\n\t在创建函数时，隐式的创建了arguments对象，它是用来记录函数的参数的信息的，只能在函数内部使用<br/>\r\n    它的属性：<br/>\r\n        * length: 函数的参数的长度<br/>\r\n        * callee: 对函数本身的调用<br/>\r\n        * 可以通过下标来访问具体参数的值。\r\n    > 注：`arguments`对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用`Array.prototype.slice.call`先将其转为数组。\r\n5. ES6 rest参数\r\n    > ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。`rest`参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\r\n\r\n    ```js\r\n    function fun(...a){\r\n        console.log(a);    // [1,2,3,4]\r\n    }\r\n    fun(1,2,3,4)\r\n\r\n    function fun(a, ...b){\r\n        console.log(a,b);    //1   [2,3,4]\r\n    }\r\n    fun(1,2,3,4)\r\n\r\n    // rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\r\n    function f(a, ...b, c) {\r\n        // 报错\r\n    }\r\n    ```\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=rest-parameters\" frameborder=\"0\"></iframe>\r\n\r\n\r\n### 参数尾逗号\r\n在ES7种，函数实参和形参末尾可以以逗号结束：\r\n```js\r\nfunction fun(a,b,){ }\r\n\r\nfun(10,20,)\r\n```\r\n**功能**：重新排列元素项，改变最后一个元素位置时不需要增删逗号\r\n\r\n\r\n## 函数的重载\r\n> 一个函数通过传入的参数的个数或者类型的不同，可以对应函数的多个实现，而且每一种实现对应一个函数体。<br/>\r\n  重载函数常用来实现功能类似而所处理的数据类型不同的问题。\r\n\r\n**模拟函数的重载：**\r\n```javascript\r\nfunction fun(a,b){\r\n    if(arguments.length == 1){\r\n            alert(\"只有一个参数\"+a);\r\n    }\r\n    if(arguments.length == 2){\r\n            alert(\" 有两个参数\"+a+\"和\"+b);\r\n    }\r\n    if(arguments.length >= 3){\r\n            alert(\"参数太多了\");\r\n    }\r\n}\r\nfun(1,3.4,4);\r\n```\r\n\r\n## 函数参数默认值\r\n```js\r\n// 该函数计算两数之和，但如果调用只传入一个参数则结果是NaN，所以必须为参数设置默认值0\r\nfunction add(a,b){\r\n    return a+b\r\n}\r\n```\r\n\r\n1. 短路原则为变量设置默认值\r\n   ```js\r\n   // 利用短路原则为函数参数设置默认值，参数存在则取参数，参数未传则取0\r\n   function add(a,b){\r\n       a = a||0;\r\n       b = b||0;\r\n       return a+b\r\n   }\r\n   ```\r\n   ```js\r\n   // 为变量设置默认值1\r\n   var num = num || 1\r\n   ```\r\n2. ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。\r\n  ```javascript\r\n  function add(x, y = 0) {\r\n    console.log(x, y);\r\n  }\r\n  log(10) // 10 0\r\n  log(10, 100) // 10  100\r\n  log(10, \'\') // 10\r\n  ```\r\n\r\n\r\n* 函数的length属性，将返回没有指定默认值的参数个数。\r\n  ```javascript\r\n  function aa(a){}\r\n  function bb(a=5){}\r\n  function cc(a,b,c=5){}\r\n\r\n  console.log(aa.length) // 1\r\n  console.log(bb.length) // 0\r\n  console.log(cc.length) // 2\r\n  ```\r\n\r\n\r\n\r\n\r\n## 参数的返回值\r\n> 函数体中的计算结果可以输出查看，但是如果想对函数的结果进行处理则需要用到函数的返回值。\r\n\r\n函数体中的关键字 `return` 可以将函数体中运行的结果返回给函数外部：\r\n\r\n```js\r\nfunction fun(a,b){\r\n    var num = a+b;\r\n    return num;\r\n}\r\nvar end = fun(1,2);    // 函数运行结果保存到变量end中\r\n```\r\n\r\n### return 的功能\r\n1. 将函数运行结果返回\r\n2. 停止并跳出当前函数 （不会执行return后面的语句）\r\n   > return 意味着函数有了运行结果，意味着函数停止\r\n\r\n  ```javascript\r\n  function aa(){\r\n      return;\r\n      alert(\"hello world\");\r\n  }\r\n  aa();   // 没有弹出 hello world\r\n  ```\r\n\r\n  * 一个函数可以有多个return语句，但只有一个return执行（常用于判断）\r\n    ```javascript\r\n    function aa(a){\r\n        if(a>0){\r\n            alert(a);\r\n            return;\r\n        }\r\n        if(a<=0){\r\n            alert(a);\r\n            return;\r\n        }\r\n    }\r\n    aa(3);  //  3\r\n    ```\r\n\r\n### 函数返回值使用事项：\r\n  1. 返回值可以是任何数据类型\r\n  2. 每个函数都默认有返回值，如果一个函数没有写`return`，会默认返回`undefined`。\r\n\t```javascript\r\n\tfunction aa(a){\r\n    \tif(a>0){\r\n    \t\talert(a);\r\n    \t\treturn;\r\n    \t}\r\n    \tif(a<=0){\r\n    \t\talert(a);\r\n    \t\treturn 1;\r\n    \t}\r\n    }\r\n    alert(aa(3));   //  3  undefined\r\n    alert(aa(0));   //  0  1\r\n\t```\r\n\r\n  3. 一个函数只能有一个返回值。\r\n\t```javascript\r\n\tfunction bb(a,b,c){\r\n\t\treturn a,b,c;\r\n\t}\r\n\talert(bb(3,5,7)); //  7\r\n\t```\r\n\t原因：用逗号做返回值时，是按从左到右赋值的，最终赋值为最后一个值，前面的值被覆盖了。\r\n    > 如果想返回多个值，则可以将多个值打包为数组或对象\r\n","timestamp":1585877701769},{"name":"003-预解析、作用域.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/003-预解析、作用域.md","content":"## 环境与变量作用域\r\n> **运行环境**是JavaScript中重要的一个概念，指JavaScript代码运行的地方\r\n\r\n* 运行环境\r\n    * 宿主环境: 指支持JavaScript运行的平台或软件，一般指**浏览器**\r\n    * 执行环境: 定义了变量或函数有权访问的其他数据，决定了它们各自的行为\r\n        * 全局环境：整个页面\r\n        * 函数环境：一个函数内部就是一个环境\r\n        * eval()\r\n\r\n正因为有了这些环境，在不同环境中声明的变量或函数就有了它的生效范围，这就是作用域：\r\n\r\n### 作用域\r\n**作用域**：作用域即一段代码的作用范围。\r\n\r\n* **全局变量**<br/>\r\n\t在全局环境(即函数外部)声明的变量，或者没有使用var关键字声明的变量，在任何地方都可以访问得到，拥有全局的作用域。\r\n* **局部变量**<br/>\r\n\t在函数环境(即函数内部)声明的变量，参数也是局部变量。只能在函数内部访问得到。\r\n\t```javascript\r\n    var a=100;\r\n    function aa(){\r\n        alert(a);\r\n        var b = 200;\r\n        alert(b);\r\n        c = 1;\r\n    }\r\n    aa();   // 100 200\r\n    alert(a);  //100\r\n    alert(b);  //报错\r\n    alert(c);\r\n\t```\r\n\t优点：可以提高程序的逻辑性、安全性，可以减少名字的冲突。\r\n\r\n### 作用域链\r\n当访问一个变量或函数时，JavaScript会创建变量的一个**作用域链**，规定了该变量在执行环境中的访问次序：从当前环境开始，依次到包含(外部)环境、下一个包含环境，直到全局环境。\r\n\r\n* 直观表现就是：变量函数的值会从当前作用域寻找，然后逐级地向上级回溯，直至找到变量为止（如果找不到变量，通常会导致错误发生）。\r\n  ```javascript\r\n  var num = 1;\r\n  function aa(){\r\n      var num = 2;\r\n      function bb(){\r\n        var num = 3;\r\n        function cc(){\r\n          num = 4;\r\n          alert(num);\t// 4\r\n        }\r\n        cc();\r\n        alert(num);\t\t// 4\r\n      }\r\n      bb();\r\n      alert(num);\t\t\t// 2\r\n  }\r\n  aa();\r\n  alert(num);\t\t\t\t// 1\r\n  ```\r\n> 注意：</br>\r\n> 不用var声明直接为变量赋值，得到的不是真正的全局变量，它实际是对属性赋值操作。首先，它会尝试在当前作用域链中解析 改变量； 如果在任何当前作用域链中找到改变量，则会执行对改变量属性赋值； 如果没有找到改变量，它才会在全局对象（即当前作用域链的最顶层对象，如window对象）中创造改变量属性并赋值。\r\n\r\n## 预解析\r\n> javascript解析器在运行javascript代码的时候会将`变量`、`函数`提前到当前作用域顶部，再顺序执行\r\n\r\n* 预解析顺序：\r\n    * 按`<script> </script>`块来解析的\r\n    * 按环境来解析\r\n    * 遇到关键字var 和function时，提前解析到内存中。\r\n    * 如果还有`<script> </script>`块，再按上述顺序来解析。\r\n```javascript\r\nalert(a);   //  undefined\r\nvar a = 12;\r\nalert(a);   //  12\r\nalert(b);   //  b is not defined\r\n```\r\n预解析案例：\r\n```javascript\r\nvar num = 10;\r\nfunction fun() {\r\n    var num\r\n    console.log(num)     // undefined\r\n    num = 100\r\n}\r\nfun()\r\n```\r\n```javascript\r\nconsole.log(fun);   // 函数fun\r\nvar fun = 123;\r\nfunction fun() {\r\n    console.log(\'Hello javascript\');\r\n}\r\nconsole.log(fun);     // 123\r\n```\r\n","timestamp":1585877701769},{"name":"004-函数高级.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/004-函数高级.md","content":"## 回调函数\r\n* **概念**\r\n\t把一个函数的指针作为另一个函数的参数，当调用这个参数时，这个函数就叫回调函数。\r\n  > js代码会至上而下一条线执行下去，但是有时候我们需要等到一个操作结束之后再进行下一个用户操作，这时候就需要用到回调函数来控制下一个操作的功能。\r\n\r\n  例如：控制两个数字的计算，具体的运算规则由回调函数传入：\r\n\r\n  * 通过函数指针来调用（直接写函数名）\r\n  ```javascript\r\n\tfunction math(num1,num2,fu){\r\n\t\treturn fu(num1,num2);\r\n\t}\r\n\tfunction jia(num1,num2){\r\n\t\treturn num1 + num2;\r\n\t}\r\n\tfunction jian(num1,num2){\r\n\t\treturn num1 - num2;\r\n\t}\r\n\tmath(1,2,jia);\r\n  ```\r\n  * 把函数整体作为参数传进去\r\n  ```javascript\r\n\talert(math(2,2,function (num1,num2){\r\n      return num1 * num2;\r\n\t}))\r\n  ```\r\n\r\n## 递归函数\r\n* **概念**\r\n  * 在函数内部直接或间接引用自身。\r\n  * 每个递归函数里必定会有终止条件。\r\n\r\n  求阶乘：\r\n  ```javascript\r\n  function factorial(c){\r\n      if(c == 1){\r\n          return c;\r\n      }else{\r\n          return c * factorial(c-1);\r\n      }\r\n  }\r\n  alert(factorial(5));\r\n  ```\r\n  多维数组遍历：\r\n  ```javascript\r\n  var new_array=[];\r\n  function _getChilds(data){\r\n  \tif(typeof data != \"object\" || data == null){\r\n  \t\tnew_array.push(data);\r\n  \t}else{\r\n  \t\tgetChilds(data);\r\n  \t}\r\n  }\r\n  function getChilds(data){\r\n  \tfor(var i in data){\r\n  \t\t_getChilds(data[i]);\r\n  \t}\r\n  }\r\n\tvar json = {\r\n\t\t\"aa\" : {\"l\" : 1,\"m\" : 3},\r\n\t\t\"bb\" : 1,\r\n\t\t\"cc\" : \"abc\",\r\n\t\t\"dd\" : true,\r\n\t\t\"ee\" : null\r\n\t}\r\n\tgetChilds(json)\r\n\tconsole.log(new_array)\r\n  ```\r\n\r\n\r\n## 闭包\r\n* **概念**： 闭包是指函数外部有权访问另一个函数作用域中的变量的函数<br/>\r\n* **原理**： 作用域链<br/>\r\n\r\n创建闭包的常见方式，就是在一个函数内部创建另一个函数并返回：\r\n  ```javascript\r\n\tfunction fun(num){\r\n\t\treturn function (){\r\n\t\t\treturn num;\r\n\t\t}\r\n\t}\r\n\tvar end = fun(100);\r\n  end();  //  100  \r\n  ```\r\n  上述案例中，num 是函数内部的变量，本来只能函数内部使用，但是返回的函数也有权限访问num。所以在函数外部通过调用返回的函数即可得到函数内部的变量\r\n\r\n### 闭包小案例\r\n```js\r\nvar name = \"The Window\";\r\nvar object = {\r\n　　name : \"My Object\",\r\n　　getNameFunc : function(){\r\n　　　　return function(){\r\n　　　　　　return this.name;\r\n　　　　};\r\n　　}\r\n};\r\nalert(object.getNameFunc()());//The Window\r\n```\r\n\r\n```js\r\nvar name = \"The Window\";\r\nvar object = {\r\n　　name : \"My Object\",\r\n　　getNameFunc : function(){\r\n　　　　var that = this;\r\n　　　　return function(){\r\n　　　　　　return that.name;\r\n　　　　};\r\n　　}\r\n};\r\nalert(object.getNameFunc()());//My Object\r\n```\r\n\r\n```js\r\nfunction fun(n,o) {\r\n  console.log(o)\r\n  return {\r\n    fun:function(m){\r\n      return fun(m,n);\r\n    }\r\n  };\r\n}\r\nvar a = fun(0); a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0\r\nvar b = fun(0).fun(1).fun(2).fun(3);              //undefined,0,1,2\r\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1\r\n```\r\n\r\n### 闭包使用场景\r\n1. 函数只需要执行一次，其内部变量无需维护。\r\n2. 封装相关的功能集\r\n3. 读取函数内部的变量\r\n\r\n>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\r\n\r\n## 块级作用域\r\n\r\n### 什么是块级作用域\r\nJS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。\r\n\r\n块作用域由 `{ }` 包括，if语句和for语句里面的{ }都属于块作用域。\r\n\r\nES5没有块级作用域概念：\r\n```js\r\n{\r\n  var num = 10;\r\n}\r\nconsole.log(num)    // 10\r\n\r\n// for循环结束后，变量i依然会存在\r\nfor(var i = 10; i<5;i++){ }\r\nconsole.log(i);   // 5\r\n```\r\nES6的块级作用域：\r\n```js\r\n{\r\n  let num = 10;\r\n}\r\nconsole.log(num)    // 报错： num is not defined\r\n\r\n// 由于i是存在于块级作用域中，所以i只能在循环{}中使用\r\nfor(let i = 10; i<5;i++){ }\r\nconsole.log(i);   // 报错： i is not defined\r\n```\r\n\r\n\r\n### 函数声明与块级作用域\r\n* ES5中，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明。\r\n* ES6中，在块级作用域内部声明的变量函数，其行为类似于let，即块级作用域外不可使用\r\n  ```javascript\r\n  function fun(){\r\n    console.log(\"I am outside function.\")\r\n  }\r\n  if (true) {\r\n    function fun() {\r\n      console.log(\"I am inside function.\");\r\n    }\r\n    fun();    // I am inside function.\r\n  }\r\n  fun();    // I am inside function.\r\n  ```\r\n  ```javascript\r\n  \'use strict\'      //es6 中的运行结果\r\n  function fun(){\r\n    console.log(\"I am outside function.\")\r\n  }\r\n  if (true) {\r\n    function fun() {\r\n      console.log(\"I am inside function.\");\r\n    }\r\n    fun();    // I am inside function.\r\n  }\r\n  fun();    // I am outside function.\r\n  ```\r\n\r\n## ES6 函数扩展\r\n\r\n### 函数参数的解构赋值\r\n> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\r\n\r\n只需要保证实参和形参数据类型同为数组或对象，即可进行函数参数的解构赋值：\r\n```js\r\nfunction add([x, y]){\r\n  return x + y;\r\n}\r\n\r\nadd([1, 2]); // 3\r\n```\r\n```js\r\nfunction fun({num1:x, num2:y}) {\r\n  return x + y;\r\n}\r\nfun({num1: 1, num2: 2})  // 3\r\n```\r\n\r\n### 箭头函数\r\n\r\n#### 基本用法\r\n\r\n* ES6允许使用“箭头”（=>）定义函数。\r\n\r\n  ```javascript\r\n  var f = v => v;\r\n  ```\r\n  上面的箭头函数等同于：\r\n  ```javascript\r\n  var f = function(v) {\r\n    return v;\r\n  };\r\n  ```\r\n\r\n* 如果箭头函数不需要参数，就使用一个`()`或`_`代表参数部分。\r\n* 如果箭头函数需要多个参数，就使用一个`()`代表参数部分。\r\n\r\n  ```javascript\r\n  var f = () => 5;\r\n  var f = _ => 5;\r\n  // 等同于\r\n  var f = function () { return 5 };\r\n\r\n  var sum = (num1, num2) => num1 + num2;\r\n  // 等同于\r\n  var sum = function(num1, num2) {\r\n    return num1 + num2;\r\n  };\r\n  ```\r\n\r\n* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来。\r\n\r\n  ```javascript\r\n  var sum = (num1, num2) => {\r\n\t\tconsole.log(num2);\r\n\t\tconsole.log(num1);\r\n    return num1 + num2;\r\n\t}\r\n\r\n\tconsole.log(sum(1,2));     // 2  1  3\r\n  ```\r\n\r\n* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个json，必须在对象外面加上括号。\r\n\r\n  ```javascript\r\n  var person = age => ({ name: \"Tom\", age: age});\r\n\tconsole.log(person(21));     //Object {name: \"Tom\", age: 21}\r\n  ```\r\n\r\n* 箭头函数可以与变量解构结合使用。\r\n\r\n  ```javascript\r\n  var full = ({ name, age}) => name + \'-\' + age;\r\n\tconsole.log(full({name:\"Tom\",age:21}));     // Tom-21\r\n  ```\r\n\r\n* 箭头函数使得表达更加简洁。\r\n\r\n  ```javascript\r\n  const isEven = n => n % 2 == 0;\r\n  const square = n => n * n;\r\n  ```\r\n\r\n* 箭头函数的其中一个用处是简化回调函数。\r\n\r\n  ```javascript\r\n  // 正常函数写法\r\n  var arr1 = [1,2,3].map(function (x) {\r\n    return x * x;\r\n  });\r\n  console.log(arr1);    //[1,4,9]\r\n\r\n  // 箭头函数写法\r\n  var arr2 = [1,2,3].map(x => x * x);\r\n  console.log(arr2);    //[1,4,9]\r\n  ```\r\n\r\n\r\n#### 使用注意点\r\n\r\n1.  this对象的指向是可变的，但是在箭头函数中，它是固定的。\r\n  ```javascript\r\n  function foo() {\r\n    setTimeout(() => {\r\n      console.log(\'id:\', this.id);\r\n    }, 100);\r\n    setTimeout(function () {\r\n      console.log(\"id:\",this.id);\r\n    },100)\r\n  }\r\n\r\n\tvar id = 21;\r\n\tfoo.call({ id: 42 });\r\n  //id: 42\r\n  //id: 21\r\n  ```\r\n2. 不能当做构造函数\r\n3. 箭头函数没有arguments对象\r\n\r\n#### 兼容性\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=arrow-functions\" frameborder=\"0\"></iframe>\r\n","timestamp":1585877701769},{"name":"005-内置顶层函数.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/005-内置顶层函数.md","content":"# JavaScript内置顶层函数\r\n\r\n### 内置\r\nECMAscript自带的函数，ECMAscript 自带的函数，ECMAscript将我们常用的一些功能封装起来，用户不需要知道其实现原理而直接使用。\r\n\r\n### 顶层\r\n指函数的作用范围，作用范围为全局\r\n\r\n### 内置顶层函数\r\n1. Number();  —— 任意类型数据转化为数字\r\n    * 如果是布尔值，true为1，false为0\r\n    * 如果是数值，转换为本身,会将无意义的后导零与前导零去掉\r\n    * 如果为null，转换为0\r\n    * 如果是undefined,转换为NaN  not a number\r\n    * 如果是字符串，\r\n        * 如果字符串中只有数字，则转换为数字（10进制）会忽略前导0和后导0\r\n        * 如果是规范的浮点数，则转换为浮点数 会忽略前导0和后导0\r\n        * 如果是空字符串，转换为0\r\n        * 如果是其它值，转换为NaN\r\n\r\n    案例：用户输入两个数字及运算符进行计算\r\n    ```js\r\n    // 由于prompt方法获取到的数据均为字符串，所以需要转化为数字\r\n    var num1 = Number(prompt(\"请输入第一个数字：\"))\r\n    var operator = prompt(\"请输入运算符\")\r\n    var num2 = Number(prompt(\"请输入第二个数字：\"))\r\n    switch (operator) {\r\n        case \'+\':\r\n            alert(\"运算结果为：\"+ (num1 + num2))\r\n            break;\r\n        case \'-\':\r\n            alert(\"运算结果为：\"+ (num1 - num2))\r\n            break;\r\n        // ...\r\n        default:\r\n            alert(\"请输入正确的运算符 + - * / %\")\r\n            break;\r\n      }\r\n    ```\r\n2. parseInt();  —— 任意类型数据转化为整数\r\n    * 如果一个字符串中只包含数字，转换为十进制数\r\n    * 如果有多个空格，会先找到第一个非空的值进行转换，直到非数值时结束\r\n    * 如果第一个值不是以`数字`、`-数字`、`空格`开头的，转换为NaN\r\n    * 有两个参数时，第一个参数表示要转换的值，第二个参数表示几进制，返回值是一个十进制的数字\r\n        * <b>注意：</b>第一个参数从最高位开始计算，只要有一位数可以识别为第二个参数传入的进制，则可以实现转化\r\n        * <b>注意：</b>第二个参数可以传入的值为 2-36\r\n\r\n3. parseFloat();  —— 任意类型数据转化为浮点数(小数)\r\n    * 只有一个小数点起作用，其它无效\r\n    * 如果字符串是一个有效的整数，他返回的是整数，不会返回浮点数。\r\n\r\n4. String();  —— 任意类型数据转化为字符串\r\n    * 如果是null,undefined,转换为字符串  \"null\"  \"undefined\"\r\n    * 如果是数值类型，转换为本身的字符串，123 转换为 \"123\"\r\n    * 如果是布尔类型，true为\"true\"  false为\"false\"\r\n\r\n5. Boolean();  —— 任意类型数据转化为布尔值\r\n    * 转换结果是假：\"\"(空串),null,undefined,0,false,NaN\r\n    * 其它都为真\r\n\r\n6. isNaN();  —— 判断一个数据能否转换为数值\r\n    * 如果能转换成数值返回false，不能返回为true\r\n    * 如果isNaN(x)返回false，那么x在任何算数表达式中都不会使表达式等于NaN；如果返回true，x会使所有算数表达式返回NaN\r\n    ```js\r\n    isNaN(NaN);         // true\r\n    isNaN(null);        // false   \r\n    isNaN(undefined);   // true\r\n    isNaN(\"\");        // false   \r\n    ```\r\n7. eval(); —— 将传入的字符串当做 JavaScript 代码进行执行\r\n    ```js\r\n    var str = \"(1+2)*3\";\r\n    eval(str);     // 9\r\n    ```\r\n    * 避免在不必要的情况下使用 eval\r\n        * 需要解析，速度慢\r\n        * 安全性差：所执行的字符串容易被操控修改从而收到攻击\r\n\r\n\r\n\r\n\r\n### Number扩展\r\n\r\n* Number.isFinite() 与 Number.isNaN()\r\n> Number.isFinite()用来检查一个值是否为有限的。<br/>\r\nNumber.isNaN()用来检查一个值是否是NaN。\r\n\r\n  ```javascript\r\n  console.log(isFinite(\'15\'));    // true\r\n  console.log(isFinite(true));    // true\r\n  console.log(Number.isFinite(\'15\')); // false\r\n  console.log(Number.isFinite(true)); // false\r\n\r\n  console.log(isNaN(\'true\'))        // true\r\n  console.log(Number.isNaN(\'true\')) // false\r\n  ```\r\n\r\n* Number.isInteger()  用来判断一个值是否为整数。\r\n> 需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\r\n\r\n  ```javascript\r\n  console.log(Number.isInteger(25))   // true\r\n  console.log(Number.isInteger(25.0)) // true\r\n  console.log(Number.isInteger(25.1)) // false\r\n  console.log(Number.isInteger(\"15\")) // false\r\n  console.log(Number.isInteger(true)) // false\r\n  ```\r\n","timestamp":1585877701769},{"name":"006-数据类型转换.md","path":"001-前端/08-JavaScript/001-ECMA/05-函数/006-数据类型转换.md","content":"# 类型转换\r\n\r\n## 强制类型转换\r\n> 详见上一节 \"内置顶层函数\"\r\n\r\n * Number()      转换成数值类型\r\n * String()      转换成字符串类型   \r\n * Boolean()     转换成布尔类型\r\n * parseInt()    将字符串转换为整型\r\n * parseFloat()  转换为浮点型\r\n\r\n## 隐式类型转换\r\n> 由于js是弱类型语言，在使用算术运算符时，运算符两边的数据类型可以是任意的。比如，一个字符串可以和数字相加。之所以不同的数据类型之间可以做运算，是因为JavaScript引擎在运算之前会悄悄的把他们进行了`隐式类型转换`\r\n\r\n* 算数运算符类\r\n  * \\- \\* / %\r\n    * 在进行算术运算，如果操作数不是数值，将会隐式的调用Number()函数，按照这个函数的转换规则进行转换\r\n    * 如果转换不成功，整个表达式返回NaN\r\n  * \\+\r\n    *  任何数据类型和`字符串`相加，返回他们拼接的结果。\r\n    *  如果操作数不包含字符串，则规则同 `- * / %`\r\n\r\n* 关系运算符类\r\n  * 两个操作数都是`字符串`，则比较两个字符串对应的字符编码\r\n  * 除此之外，参与比较的数据都会隐式调用`Number()`进行转换后再比较\r\n\r\n* 逻辑运算符类\r\n  * `&&  ||  !`运算，会调用 `Boolean()`函数判断参与逻辑运算的数据的真假性\r\n\r\n* 语句\r\n  > `if`、`while`、`do while`语句和`三元表达式`里面的判断条件表达式会隐式的调用`Boolean()`函数，按照这个函数的转换规则，转换为相应的布尔值\r\n  \r\n  ```js\r\n  // 判断一个字符串是否为空\r\n  var str = \"\";\r\n  if(str){\r\n    console.log(\"str is true\")\r\n  }\r\n  ```\r\n","timestamp":1585877701769},{"name":"01-数组.md","path":"001-前端/08-JavaScript/001-ECMA/06-数组/01-数组.md","content":"# 数组 （Array）\r\n> 一个变量只能保存一个数据，当有一连串数据需要保存时就需要用到数组：\r\n\r\n> **数组**：有序的元素序列，使用单独的变量名来存储一系列的值\r\n\r\n## 创建数组并赋值\r\n\r\n### 创建数组\r\n1. 实例化构造函数\r\n  ```js\r\n  var arr = new Array();\r\n  ```\r\n2. 隐式创建 (内部调用`new Array()`)\r\n  ```js\r\n  var arr = [];\r\n  ```\r\n\r\n### 数组赋值\r\n1. 创建数组的同时赋值\r\n  ```js\r\n  var arr = new Array(\"a\",\"b\",\"c\");   // [\'a\',\'b\',\'c\']\r\n\r\n  var arr = [\"a\",\"b\",\"c\"];\r\n  ```\r\n2. 创建数组后赋值\r\n\r\n  数组中存储的是有序的数据，所以可以个别那句数据所在位置的序号进行赋值，这个位置叫做**下标**\r\n\r\n  数组赋值时，通过 `数组名[下标]` 的形式进行赋值\r\n  ```js\r\n  var arr = [];\r\n  arr[0]=\"a\";\r\n  arr[1]=\"b\";\r\n  arr[2]=\"c\";\r\n  // 上面的操作等价于  var arr = [\"a\",\"b\",\"c\"];\r\n  ```\r\n#### 赋值特点\r\n* 数组的下标是从**零**开始计算，arr[0]就是arr数组的第一个值\r\n* 数组中可是 以存储任意数据类型的数据，在一个数组中可以包含对象元素、函数、数组\r\n\r\n\r\n## 数组的访问\r\n### 通过数组下标访问数据\r\n* 访问数据：直接通过下标获取数组对应位置得值\r\n* 修改数据：直接将数据赋值给对应数组对应位置\r\n\r\n```js\r\n// 访问arr数组的第一个值\r\nvar one = arr[0];\r\n// 修改arr数字的第一个值为\'x\';\r\narr[0] = \"x\"\r\n```\r\n### 数组的长度\r\n数组的长度即数组中存储数据的个数，数组上有一个`length`属性可用来访问数组的长度\r\n```js\r\nvar arr = [1,2,3,4,5];\r\narr.length   // 5\r\n```\r\n\r\n数组最后一个数据的下标： `length-1`  \r\n访问数组最后一个元素：`arr[length-1]`\r\n\r\n\r\n\r\n### 数组的遍历\r\n> 通过循环依次获取 `0 到 length-1` 的下标，即可实现遍历数组，访问所有数组数据\r\n\r\n1. for循环遍历\r\n\r\n```js\r\nvar arr=[1,2,3];\r\nfor(var i=0;i<arr.length;i++){\r\n  console.log(arr[i]);\r\n}\r\n\r\n// 控制台输出\r\n    // 1\r\n    // 2\r\n    // 3\r\n```\r\n\r\n2. for...in 循环  \r\n\r\n```js\r\nvar arr = [1,2,3];\r\nfor(var i in arr){\r\n  // i 是数组下标\r\n  // arr[i] 是数组数据\r\n}\r\n```\r\n> 但是最好不要用for in 循环来遍历数组，它是用来遍历对象的。如果在数组原型上添加方法，它也会遍历出来\r\n\r\n\r\n3. for...of 循环\r\n> `for...of`循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象），以及字符串。\r\n\r\n```js\r\nlet arr = [3, 5, 7];\r\narr.foo = \'hello\';\r\n\r\nfor (let i in arr) {\r\n  // i 值是键名\r\n  console.log(i); // \"0\", \"1\", \"2\", \"foo\"\r\n}\r\n\r\nfor (let i of arr) {\r\n  // i 值是键值，  并且只返回具有数字索引的属性\r\n  console.log(i);   //  \"3\", \"5\", \"7\"\r\n}\r\n```\r\n\r\n\r\n## 二维数组\r\n>数组中的每一个子元素都是数组\r\n\r\n```js\r\nvar arr = [[1,2,3],[4,5],[6]]\r\n```\r\n遍历二维数组\r\n```js\r\nfor(var i =0; i<arr.length;i++){\r\n  for(var j =0; j<arr.length;j++){\r\n    console.log(arr[i][j])\r\n  }\r\n}\r\n```\r\n\r\n\r\n## ES6 数组扩展\r\n### 数组的解构赋值\r\n> 从数组中提取值，对变量进行赋值，这被称为数组解构赋值。\r\n\r\n```js\r\nvar [one, two, three] = [1,2,3];\r\nconsole.log(one); // 1\r\nconsole.log(two); // 2\r\nconsole.log(three); // 3\r\n```\r\n\r\n* 为了防止从数组中取出一个值为`undefined`的对象，还可以为这个对象设置默认值。\r\n```js\r\nvar a, b;\r\n[a=5, b=7] = [1];\r\nconsole.log(a); // 1\r\nconsole.log(b); // 7\r\n```\r\n\r\n* 用途1： 不使用第三个变量交换两个变量的值。\r\n\r\n```js\r\nvar a = 1, b = 3;\r\n\r\n[a, b] = [b, a];\r\nconsole.log(a); // 3\r\nconsole.log(b); // 1\r\n```\r\n\r\n* 用途2： 函数形参接收数组参数\r\n当一个函数实参为数组时，可以利用解构可以将实参数据解析\r\n```js\r\nfunction f([x, y]) {\r\n  // x:1    y:2\r\n  return x + y;\r\n}\r\nvar add = f([1,2]);\r\nconsole.log(add); // 3\r\n```\r\n\r\n* 用途3： 解析一个从函数返回的数组\r\n当一个函数返回值为数组时，解构使得处理返回值为数组时更加方便\r\n```js\r\nfunction f() {\r\n  return [1, 2];\r\n}\r\nvar a, b;\r\n[a, b] = f();\r\nconsole.log(a); // 1\r\nconsole.log(b); // 2\r\n```\r\n\r\n\r\n\r\n### 扩展运算符 ...\r\n> 扩展运算符（spread）是三个点`...`。它好比 函数`rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\r\n\r\n```js\r\nconsole.log(...[1, 2, 3])        // 1 2 3\r\nconsole.log(1, ...[2, 3, 4], 5)  // 1 2 3 4 5\r\n```\r\n\r\n####  用途\r\n1. 函数调用传参\r\n  ```js\r\n   // 将数组参数items转化为数字，从而进行push\r\n  function push(array, ...items) {\r\n    array.push(...items);\r\n  }\r\n\r\n  // 将数组中数据相加\r\n  function add(x, y) {\r\n    return x + y;\r\n  }\r\n  let numbers = [4, 38];\r\n  add(...numbers) // 42\r\n\r\n  // 寻找数组最值\r\n  Math.max(...[numbers])    // 38\r\n  Math.min(...[numbers])    // 4\r\n  ```\r\n2. 数组拷贝\r\n  ```js\r\n  const a1 = [1, 2];\r\n  // 写法一\r\n  const a2 = [...a1];\r\n  // 写法二\r\n  const [...a2] = a1;\r\n  ```\r\n3. 数组合并\r\n  ```js\r\n  let arr1 = [1,2,3], arr2 = [4,5,6];\r\n  let newarr = [...arr1, ...arr2]\r\n  ```\r\n  > 不过，这种方法是浅拷贝，使用的时候需要注意。\r\n","timestamp":1585877701769},{"name":"02-Iterator.md","path":"001-前端/08-JavaScript/001-ECMA/06-数组/02-Iterator.md","content":"# Iterator\r\n> Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\r\n\r\n## 为什么需要Iterator\r\nJavaScript原有的表示\'集合\'的数据结构，主要是数组(Array)和对象(Object),ES6又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制来处理所有不同的数据结构。\r\n\r\n**遍历器(Iterator)** 就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)。\r\n\r\n## Iterator的作用\r\n\r\nIterator的作用有三个：\r\n- 为各种数据结构，提供一个统一的、简便的访问接口；\r\n- 使得数据结构成员能够按某种次序排列；\r\n- ES6创造了一种新的遍历命令 `for...of`循环，Iterator接口主要供`for...of`消费。\r\n\r\n## Iterator遍历过程\r\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上就是一个指针对象。\r\n2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。\r\n3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。\r\n4. 不断调用指针对象`next`方法，直到它指向数据结构的结束位置。\r\n\r\n\r\n每一次调用`next`方法，都会返回数据结构当前成员信息。\r\n```\r\n{value:\'\',done:ture}\r\n```\r\n`value` 属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。\r\n\r\n\r\n模拟next方法返回值的示例：\r\n```js\r\nvar t = makeIterator([1,2]);\r\nt.next(); //{value:1,done:false}\r\nt.next(); //{value:2,done:false}\r\nt.next(); //{value:undefined,done:true}\r\n\r\nfunction makeIterator(array){\r\n    var nextIndex = 0;\r\n    return {\r\n        next:function(){\r\n            return nextIndex < array.length ? {value:array[nextIndex++],done:false} : {value:undefined,done:true};\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n## 默认Iterator接口\r\nIterator接口的目的就是为所有的数据结构提供了一种统一的访问机制，即`for...of`循环。当使用`for...of`循环遍历某种数据结构时，该循环会自动寻找Iterator接口。\r\n\r\n一种数据结构只要部署了Iterator接口，我们就称这种数据结构时\"可遍历的\"(iterable)。\r\n\r\nES6规定，默认的Iterator接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是\"可遍历的\"(iterable)。`Symbol.iterator`属性本身是一个函数，就是当数据结构默认的遍历器生成函数。执行这个函数就会返回一个遍历器。至于属性名`Symbol.iterator`，它是一个表达式，返回`Symbol`对象的`iterator`属性，这是一个预定义好的类型为Symbol的特殊值，所以要放在方括号内。\r\n\r\n```js\r\nconst obj = {\r\n    [Symbol.iterator]:function(){\r\n        return {\r\n            next: function(){\r\n                return {\r\n                    value:1,\r\n                    done:false\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nES6的有些数据结构原生具备Iterator接口(比如数组)，即不用任何处理，就可以被`for...of`循环遍历。原因在于，这些数据结构原生部署了`Symbol.iterator`属性，另外一些数据结构没有(比如对象)。凡是部署了`Symbol.iterator`属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。\r\n\r\n原生具备Iterator接口的数据结构如下：\r\n- Array\r\n- Map\r\n- Set\r\n- String\r\n- TypedArray\r\n- 函数的Arguments对象\r\n- NodeList对象\r\n\r\n\r\n数组的`Symbol.iterator`属性:\r\n```js\r\nlet arr = [\'a\',\'b\',\'c\'];\r\nlet iter = arr[Symbol.iterator]();\r\n\r\niter.next(); //{value:\'a\',done:false}\r\niter.next(); //{value:\'b\',done:false}\r\niter.next(); //{value:\'c\',done:false}\r\niter.next(); //{value:undefined,done:true}\r\n```\r\n变量arr是一个数组，原生就具有遍历器接口，部署在arr的`Symbol.iterator`属性上面。所以，调用这个属性，就得到遍历器对象。\r\n\r\n\r\n## 调用 Iterator 接口的场合\r\n有一些场合会默认调用Iterator接口(即`Symbol.iterator`方法)，除了下文会介绍的`for...of`，还有几个别的场合。\r\n\r\n### 解构赋值\r\n对数组和Set结构进行解构赋值时，会默认调用`Symbol.iterator`方法。\r\n```js\r\nlet set = new Set().add(\'a\').add(\'b\').add(\'c\');\r\n\r\nlet [x,y] = set; //x=\'a\'; y=\'b\'\r\n\r\nlet [first,...rest] = set;  // first = \'a\'; rest = [\'b\',\'c\'];\r\n```\r\n### 扩展运算符\r\n扩展运算符(...) 也会调用默认的Iterator接口。\r\n```js\r\nvar str = \'hello\';\r\n[...str]  // [\'h\',\'e\',\'l\',\'l\',\'o\']\r\n\r\nlet arr = [\'b\',\'c\'];\r\n\r\n[\'a\',...arr,\'d\'] // [\'a\',\'b\',\'c\',\'d\']\r\n```\r\n上面代码的扩展运算符内部就调用Iterator接口。\r\n\r\n实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。\r\n```\r\nlet arr = [...iterator];\r\n```\r\n### yield*\r\n`yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。\r\n```js\r\nlet generator = function* (){\r\n    yield 1;\r\n    yield* [2,3,4];\r\n    yield 5;\r\n}\r\nvar iter = generator();\r\n\r\niter.next();  //{value:1,done:false}\r\niter.next();  //{value:2,done:false}\r\niter.next();  //{value:3,done:false}\r\niter.next();  //{value:4,done:false}\r\niter.next();  //{value:5,done:false}\r\niter.next();  //{value:undefined,done:true}\r\n```\r\n### 其他场合\r\n由于数组的遍历会调用遍历器接口，所以任何接收数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\r\n- for...of\r\n- Array.from()\r\n- Map(),Set(),WeakMap(),WeakSet() (比如`new Map([[\'a\',1],[\'b\',2]])`)\r\n- Promise.all()\r\n- Promise.reace()\r\n\r\n\r\n## 字符串的Iterator接口\r\n字符串是一个类似数组的对象，原生具有Iterator接口。\r\n```js\r\nvar str = \"hi\";\r\ntypeof str[Symbol.iterator]  //function\r\n\r\nvar iter = str[Symobal.iterator]();\r\niterator.next() //{value:\'h\',done:false}\r\niterator.next() //{value:\'i\',done:false}\r\niterator.next() //{value:undefined,done:true}\r\n```\r\n上面代码中，调用`Symbol.iterator`方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。\r\n\r\n\r\n## Iterator接口与Generator函数\r\n`Symbol.iterator`方法的最简单实现，还是使用下一章要介绍的Generator函数。\r\n```js\r\nlet myIterable = {\r\n    [Symbol.iterator] : function* (){\r\n        yield 1;\r\n        yield 2;\r\n        yield 3;\r\n    }\r\n}\r\n[...myIterable] // [1,2,3]\r\n\r\n//或者采用下面的简洁写法\r\nlet obj = {\r\n    * [Symbol.iterator](){\r\n        yield \'hello\';\r\n        yield \'world\';\r\n    }\r\n}\r\nfor(let x of obj){\r\n    console.log(x);\r\n}\r\n//\"hello\"\r\n//\"world\"\r\n```\r\n\r\n\r\n## for...of 循环\r\nES6借鉴  C++、Java、C# 和Python 语法，引入了`for...of`循环，作为遍历所有数据结构的统一方法。\r\n\r\n一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有Iterator接口，就可以用`for...of`循环遍历它的成员。也就是说，`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。\r\n\r\n`for...of`循环可以使用的范围包括\r\n- 数组\r\n- Set\r\n- Map\r\n- 类数组对象 arguments/DOM NodeList对象\r\n- Generator对象\r\n- String\r\n\r\n\r\n### 数组\r\n数组原生具备`iterator`接口(即默认部署了`Symbol.iterator`属性),`for...of`循环本质上就是调用这个接口产生遍历器，可以用下面的代码证明.\r\n```js\r\nconst arr = [\'red\',\'green\',\'blue\'];\r\nfor(let v of arr){\r\n    console.log(v); // red green blue\r\n}\r\n\r\nconst obj = {};\r\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\r\n\r\nfor(let v of obj){\r\n    console.log(v); // red green blue\r\n}\r\n```\r\n上面的代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的`for...of`循环，产生了与`arr`完全一样的结果。\r\n\r\nJavascript原有的`for...in`循环，只能获得对象的键名，不能直接获取键值。ES6提供`for...of`循环，允许遍历获得键值。\r\n```js\r\nvar arr = [\'a\',\'b\',\'c\',\'d\'];\r\nfor(let a in arr){\r\n    console.log(a); //0 1 2 3 4\r\n}\r\n\r\nfor(let a of arr){\r\n    console.log(a); //\'a\' \'b\' \'c\' \'d\'\r\n}\r\n```\r\n\r\n`for...of`循环调用遍历器接口，数组的遍历器接口只发挥具有数字索引的属性，这点跟`for...in`循环也不一样。\r\n```js\r\nlet arr = [3,5,7];\r\narr.foo = \'hello\';\r\n\r\nfor(let i in arr){\r\n    console.log(i); // \'0\' \'1\' \'2\' \'foo\'\r\n}\r\n\r\nfor(let i of arr){\r\n    console.log(i); // 3 5 7\r\n}\r\n```\r\n\r\n### Set和Map结构\r\nSet和Map结构 原生具有Itrator接口，可以直接使用`for...of`循环。\r\n```js\r\nvar engines = new Set([\'Gecko\',\'Trident\',\'Webkit\',\'Webkit\'])\r\nfor(var v of engines){\r\n    console.log(v);\r\n}\r\n//Gecko  Trident  Webkit\r\n\r\nvar mp = new Map();\r\nmp.set(\"edition\",6);\r\nmp.set(\"committee\",\"TC39\");\r\nmp.set(\"standard\",\"ECMA-262\");\r\n\r\nfor(var [name,value] of mp){\r\n    console.log(name + \":\" + vlaue);\r\n}\r\n//edition:6\r\n//committee:TC39\r\n//standard:ECMA-262\r\n```\r\n上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。\r\n\r\n```js\r\nlet map = new Map().set(\'a\',1).set(\'b\',2);\r\nfor(let v of map){\r\n    console.log(v)\r\n}\r\n//[\'a\',1]\r\n//[\'b\',2]\r\n\r\nfor(let [k,v] of map){\r\n    console.log(k + \':\'+v);\r\n}\r\n//a:1\r\n//b:2\r\n```\r\n### 计算生成的数据结构\r\n有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。\r\n- `entries()` 返回一个遍历器对象，用来遍历`[键名，键值]`组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的Iterator接口，默认就是调用`entries`方法.\r\n- `keys()` 返回一个遍历器对象，用来遍历所有的键名。\r\n- `values()` 返回一个遍历器对象，用来遍历所有的键值。\r\n\r\n这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。\r\n\r\n### 类似数组的对象\r\n类似数组的对象包括好几类。\r\n- 字符串\r\n- DOM NodeList对象\r\n- `arguments`对象\r\n\r\n```js\r\n//字符串\r\nlet str = \"hello\";\r\nfor(let s of str){\r\n    console.log(s); // h e l l o\r\n}\r\n\r\n// DOM NodeList\r\nlet ps = document.querySelectorAll(\'p\');\r\n\r\nfor (let p of ps){\r\n    p.classList.add(\"active\");\r\n}\r\n\r\n//Arguments对象\r\nfunction Test (){\r\n    for(var a of arguments){\r\n        console.log(a);\r\n    }\r\n}\r\nTest(\"a\",\"b\");\r\n// \"a\"   \"b\"\r\n```\r\n对字符串来说，`for...of`循环还有一个特点，就是会正确识别32位UTF-16字符串。\r\n```js\r\nfor (let x of \'a\\uD83D\\uDC0A\'){\r\n    console.log(x)\r\n}\r\n// \'a\'\r\n// \'\\uD83D\\uDC0A\'\r\n\r\n```\r\n\r\n并不是所有类数组的对象都具有Iterator接口，一个简便的解决办法，就是使用 `Array.from()`方法将其转为数组。\r\n```js\r\nvar likeArray = {0:\'a\',1:\'b\',length:2};\r\n\r\n//报错\r\nfor(let x of likeArray){\r\n    console.log(x)\r\n}\r\n\r\n//正确\r\nfor (let x of Array.from(likeArray)){\r\n    console.log(x)\r\n}\r\n```\r\n\r\n### 对象\r\n对于普通的对象，`for...of`循环不能直接使用，会报错，必须部署了Itrator接口后才能使用。但是，这样情况下，`for...in` 循环依然可以用来遍历键名。\r\n```js\r\nlet user = {name:\"zhangsan\",age:12,sex:\"男\"};\r\n\r\nfor(let k in user){\r\n    console.log(k)\r\n}\r\n// name\r\n// age\r\n// sex\r\n\r\nfor(let v of user){\r\n    console.log(k)\r\n}\r\n//Uncaught TypeError: user is not iterable\r\n```\r\n上面代码表示，对于普通的对象，`for...in`循环可以遍历键名，`for...of`循环会报错。\r\n\r\n### 与其他遍历语法的比较\r\n以数组为例，JavaScript提供多种遍历语法。最原始的写法就是`for`循环。\r\n```js\r\nfor(var i = 0; i < arr.length;i++){\r\n    console.log(arr[i]);\r\n}\r\n```\r\n这种写法比较麻烦，因此数组提供内置的`forEach`方法。\r\n```js\r\narr.forEach(v=>{\r\n    console.log(v);\r\n})\r\n```\r\n这种写法的问题在于，无法中途跳出`forEach`循环，`break`命令或`return`命令都不能。\r\n\r\n`for...in`循环可以遍历数组的键名。\r\n```js\r\nfor(var i in arr){\r\n    console.log(arr[i])\r\n}\r\n```\r\n\r\n`for...in`循环有几个缺点：\r\n- 数组的键名是数字，但是`for...in`循环是以字符串作为键名\'0\'、\'1\'、\'2\'等等。\r\n- `for...in`循环不仅遍历数字的键名，还会遍历手动添加的其他键，甚至包括原型链上的键。\r\n- 某些情况下，`for...in`循环会以任意顺序遍历键名。\r\n\r\n总之,`for...in`循环主要是为遍历对象而设计的，不适用于遍历数组。\r\n\r\n`for...of`循环相比上面几种做法，有一些显著的优点：\r\n```js\r\nfor(let v of arr){\r\n    console.log(v)\r\n}\r\n```\r\n- 有着同`for...in`一样的简洁语法，但是没有`for...in`那些缺点。\r\n- 不同于`forEach`方法，它可以与`break`、`continue`和`return`配合使用。\r\n- 提供了遍历所有数据结构的统一操作接口。\r\n\r\n使用break语句跳出`for...of`循环的例子：\r\n```js\r\nfor(let v of arr){\r\n    if(v>100){\r\n        break;\r\n    }\r\n    console.log(n);\r\n}\r\n```\r\n","timestamp":1585877701769},{"name":"01-对象详解.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/01-对象详解.md","content":"# 对象(万物皆对象)\r\n> 对象是JavaScript的一个引用数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即**属性的无序集合**。\r\n\r\n> 在javascript中，一个对象可以是一个单独的拥有属性和类型的实体。我们拿它和一个杯子做下类比。一个杯子是一个对象(物体)，拥有属性。杯子有颜色，图案，重量，由什么材质构成等等。同样，javascript对象也有属性来定义它的特征。\r\n\r\n## 对象的组成\r\n对象由`属性`和`方法`组成。一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法\r\n\r\n**属性：** 可以被解释成一个附加到对象上的变量,和普通的 javascript 变量基本没什么区别,，仅仅是属性属于某个对象  \r\n**方法：** 一个方法是一个值为某个函数的对象属性。定义方法就像定义普通的函数\r\n\r\n\r\n## 对象的创建\r\n1. 隐式创建(json格式创建)      \r\njson： javascript的原生格式\r\n```js\r\nvar obj = {}\r\n```\r\n1. 实例化Object\r\n```js\r\nvar obj=new Object();\r\n```\r\n3. 实例化自定义构造函数  \r\n```js\r\nfunction Obj(a){ }\r\nvar obj = new Obj();\r\n```\r\n4. 实例化类 (实例化Object的语法糖，详见 `Class` 一节)\r\n```js\r\nclass Animal{}  \r\nvar dog=new Animal();\r\n```\r\n\r\n### `new`操作符具体做了什么？ \r\n```js\r\nfunction Base(){\r\n  this.name = \"zhangsan\";\r\n  this.age = 20;\r\n}\r\nvar obj = new Base();\r\n\r\n// new操作符等价于\r\nvar obj = {};\r\nobj.__proto__ = Base.prototype;\r\nBase.call(obj);\r\n```\r\n1. 创建了一个空对象obj\r\n2. 将这个空对象的__proto__成员指向了Base函数对象prototype成员对象。相当于obj拥有了Base原型上的属性方法\r\n3. 将Base函数对象的this指针替换成obj，然后再调用Base函数，于是就给obj对象赋值了一个name和age成员变量。相当于obj拥有了Base构造函数上的属性方法\r\n\r\n\r\n#### instanceof关键字\r\n> 如果obj对象是构造函数Fun的一个实例，则 obj instanceof Fun 返回 true。\r\n\r\n判断一个数据是否是数组：\r\n```js\r\nvar arr1 = [], arr2 = {}\r\n\r\narr1 instanceof Array   // true\r\narr2 instanceof Array   // false\r\n```\r\n\r\n\r\n## 对象的增、删、改、查\r\n### 1. 增 (给对象增加一个新的属性或方法)\r\n  * 声明后赋值\r\n  ```js\r\n  var obj = {}\r\n  obj.user = \"张三\";    // 属性\r\n  obj.eat = function(){    // 方法\r\n    console.log(\'吃饭\');\r\n  }\r\n  ```\r\n  * 声明的同时赋值\r\n  ```js\r\n  //json形式创建赋值\r\n  var obj={\r\n    name:\'张三\',\r\n    age:18,\r\n    eat:function(){\r\n      console.log(\'吃饭\');\r\n    }\r\n  }\r\n\r\n  //实例化构造函数\r\n  function Animal(){\r\n    this.name=\'阿黄\',\r\n    this.age=\'2\',\r\n    this.sing=function(){\r\n      console.log(\'汪汪\');\r\n    }\r\n  }\r\n\r\n  //实例化Object\r\n  var obj=new Object({a:\'aa\',b:\'bb\'})\r\n  ```\r\n\r\n### 2. 查(访问属性、方法)\r\n  * 访问属性\r\n  ```js\r\n  对象.属性名;\r\n  对象[\"属性名\"];\r\n  ```\r\n  * 访问方法\r\n  ```js\r\n  对象.方法名();\r\n  对象[\"方法名\"]();\r\n  ```\r\n  > 注：当属性名或方法名保存到变量中时，访问该属性或方法需要使用`[]`\r\n  ```js\r\n  for(let i in obj){\r\n    obj[i]     // i是存储属性名的变量，所以访问该属性时必须通过[]\r\n  }\r\n  ```\r\n\r\n### 3. 改(修改属性和方法)\r\n> 直接为属性或方法赋新值即可\r\n\r\n  ```js\r\n  对象.属性名=新的属性值;\r\n  对象.方法名=新的方法;\r\n  ```\r\n### 4. 删(删除对象或者对象上的属性方法)\r\n  * 销毁对象\r\n  > javascript中的垃圾回收机制在对象没有引用的时候会进行销毁，释放内存\r\n\r\n  ```js\r\n  对象=null;    \r\n  ```\r\n  * 删除对象上的属性和方法，使用`delete`运算符\r\n  \r\n  ```js\r\n  var obj={\r\n    a:\'a\',\r\n    b:function(){console.log(\'这是一个方法\')}\r\n  }\r\n  delete obj.a;   //删除obj对象上的a属性    \r\n  delete obj.b;   //删除obj对象上的b方法\r\n  ```\r\n\r\n\r\n### 对象的遍历\r\n1. for in 循环\r\n> 循环遍历对象`自身`的和`继承`的可枚举属性(不含Symbol属性).\r\n```js\r\nvar obj={\r\n  name:\'小米\',\r\n  age:18,\r\n  say:function(){\r\n    console.log(\'你好\');\r\n  }\r\n}\r\nfor (var i in obj) {\r\n  console.log(obj[i]);\r\n}\r\n```\r\n> ES6其余遍历方式详见 `Object对象`一节\r\n\r\n### 对象的拷贝\r\n由于对象是引用类型，变量中存储的是数据的地址，所以对象直接通过`=`赋值只能将地址赋值而不是数据。\r\n\r\n对象的拷贝分为浅拷贝、深拷贝：\r\n\r\n```js\r\nvar obj = {\r\n  type: \"animal\",\r\n  cat:{\r\n    name:\"Tom\",\r\n    weight: 16,\r\n    food:[\"fish\",\"meat\"]\r\n  },\r\n}\r\n```\r\n* **浅拷贝：** 直接拷贝对象的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变\r\n* **深拷贝：** 新开辟一块内存，将对象中所有属性全部复制，如果原地址中对象被改变了，那么深拷贝出来的对象不变\r\n\r\n深拷贝实现方法：  \r\n1. 递归遍历，逐层拷贝。 因为基础类型可以直接拷贝，所以通过递归遍历对象的每一层，全部得到基础类型后再拷贝。\r\n2. 通过`JSON.stringify()`先将对象转化为字符串，字符串赋值后再通过`JSON.parse()`转化回对象。\r\n\r\n\r\n\r\n\r\n\r\n\r\n## this\r\n> this是一个很特别的关键字，被自动定义在所有函数的作用域中。  \r\n> this总是会指向一个对象。或者说，this就是属性或方法‘当前’所在的对象。\r\n\r\n### this的指向\r\n>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象\r\n\r\n1. 在普通函数中this指`window`全局对象\r\n2. 作为对象方法调用，this 指代调用该方法对象\r\n3. 在构造函数中this指向构造函数的`实例`\r\n4. 在事件中，this指向事件源\r\n5. 在call和apply中,this指的是方法中传入的对象，如果apply中没有传对象，this指向window\r\n\r\n```js\r\nfunction Fun(){\r\n  run(){\r\n    console.log(this)       // this指向实例化出的对象，因为是实例化出的对象调用了run方法\r\n\r\n    setInterval(_=>{\r\n      conosle.log(this)     // this指向 window，因为是window调用了setInterval方法\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n### 改变this的指向\r\ncall()   apply()    bind()     在对象的特性中会讲到\r\n\r\n## ES6对象扩展\r\n### 属性方法的简洁表示法\r\n* 当属性名为变量名, 属性值为变量的值时，可直接将变量作为对象的属性：\r\n```js\r\nlet username = \"张三\"\r\n\r\nlet obj = {\r\n  username,      // 属性名为变量名, 属性值为变量的值\r\n  age: 20\r\n}\r\n```\r\n* 对象方法的简写：\r\n```js\r\nlet obj = {\r\n  run:function(){\r\n    alert(1)\r\n  }\r\n}\r\n// 简写为：\r\nlet obj = {\r\n  run(){\r\n    alert(1)\r\n  }\r\n}\r\n```\r\n\r\n这种写法用于函数的返回值，将会非常方便。\r\n```js\r\nfunction getPoint() {\r\n  const x = 1;\r\n  const y = 10;\r\n  return {x, y};\r\n}\r\n\r\ngetPoint()\r\n```\r\n\r\n### 对象的解构赋值\r\n解构不仅可以用于数组，还可以用于对象。\r\n```js\r\nlet { foo: baz } = { foo: \'aaa\', bar: \'bbb\' };\r\nbaz // \"aaa\"\r\n\r\nlet { first: f, last: l } = { first: \'hello\', last: \'world\' };\r\nf // \'hello\'\r\nl // \'world\'\r\n```\r\n> 上面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。\r\n\r\n如果变量名与属性名一致，可以写成下面这样:\r\n```js\r\nlet { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\r\nfoo // \"aaa\"\r\nbar // \"bbb\"\r\n```\r\n\r\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\r\n\r\n* 用途1：接收函数的参数\r\n```js\r\n// 接收被除数x与除数y\r\nfunction calc({dividend: x, dividend: y}){\r\n  return x/y\r\n}\r\nlet divide = calc({dividend:9,dividend:3})\r\n```\r\n* 用途2：接收函数的返回值\r\n```js\r\nfunction calc(a,b){\r\n  return {\r\n    add: a+b,\r\n    subtract: a-b,\r\n    multiply: a*b,\r\n    divide: a/b\r\n  }\r\n}\r\n// 相对于返回数组来讲，不需要知道返回值参数的顺序\r\nlet {add, subtract, multiply, divide} = calc(1,2)\r\n```\r\n### 对象的Rest属性\r\nES6中数组的rest和扩展运算符，用于数组于普通参数之间的转化\r\n\r\n```js\r\nMath.max(...[1,2,3,4])\r\n \r\nfunction fun(a,b,...c){ }\r\n```\r\n\r\n现在在ES9中，当对象结构复制时也可以使用rest运算符：\r\n\r\n```js\r\nlet obj = {a: 1, b: 2, c: 3};\r\nlet {a,...x}\r\n//  a == 1\r\n//  x == {b: 2, c: 3} \r\n```\r\n\r\n或在函数参数中也可以使用：\r\n\r\n```js\r\nrestParam({\r\n  a: 1,\r\n  b: 2,\r\n  c: 3\r\n});\r\n\r\nfunction restParam({ a, ...x }) {\r\n  // a = 1\r\n  // x = { b: 2, c: 3 }\r\n}\r\n```","timestamp":1585877701769},{"name":"02-对象的特性.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/02-对象的特性.md","content":"# 对象的特性\r\n1. 封装\r\n2. 继承\r\n\r\n## 封装\r\n>  **封装：** 将对象的所有组成部分组合起来，尽可能的隐藏对象的部分细节，使其受到保护，只提供有限的接口与外部发生联系。\r\n\r\n例如同时生成多个相同的对象，可以将生成对象的过程打包直接调用，这个过程就是封装\r\n\r\n**优点：** </br>\r\n  1. 安全，使用时无法看到具体实现细节，只需要直接调用\r\n  2. 便于修改操作\r\n\r\n### 封装方法\r\n* **工厂函数**（不推荐使用）\r\n  > 将创建对象并赋值的过程封装成一个函数\r\n\r\n  ```javascript\r\n  function person(name,sex){\r\n      var person = {};\r\n      person.name = name;\r\n      person.sex = sex;\r\n      person.say = function(){\r\n          alert(\"说话\");\r\n      }\r\n      return person;\r\n  }\r\n  var zhangsan = person(\"张三\",\"man\");\r\n  alert(zhangsan.name);\r\n  ```\r\n\r\n* **构造函数**（每创建一个对象，会把相同的代码存储到内存中，会造成对内存的浪费）\r\n  ```javascript\r\n  function person(name,sex){\r\n      this.name = name;\r\n      this.sex = sex;\r\n      this.say = function(){\r\n          alert(\"说话\");\r\n      }\r\n  }\r\n  var lisi = new person(\"李四\",\"boy\");\r\n  alert(lisi.sex);\r\n  ```\r\n\r\n每次使用工厂函数或构造函数，内部的属性和方法都会在内存中重新开辟一个控件存储生成的对象，导致某些相同的方法或属性被重复保存，占用内存。\r\n\r\n* **prototype方法**（会把共享的方法或属性放到代码段中来存储,它不能共享对象）<br/>\r\n\t**实例一：**\r\n  ```javascript\r\n  person.prototype.eat=function(){\r\n      alert(\"吃饭\");\r\n  }\r\n  var lisi=new person(\"李四\",\"boy\");\r\n  lisi.eat();\r\n  ```\r\n\r\n\t**实例二：**\r\n  ```javascript\r\n  person.prototype.aaa = {name:\"王五\"};\r\n  var lisi = new person(\"李四\",\"boy\");\r\n  var zhaoliu = new person(\"赵六\",\"boy\");\r\n  alert(lisi.aaa.name = \"xiaosi\"); //xiaosi\r\n  alert(zhaoliu.aaa.name);  //xiaosi 将原型上的属性值一起改了\r\n  ```\r\n\r\n* **混合函数**\r\n\t最佳的一种方法，构造函数与prototype的结合，根据实际情况考虑\r\n\r\n  私有属性方法放到构造函数中，共有方法放到原型中\r\n  ```js\r\n  function person(user, sex){\r\n    this.user = user\r\n    this.sex = sex\r\n  }\r\n  person.prototype = {\r\n    coding: funciton(){\r\n      alert(\"写代码\")\r\n    }\r\n  }\r\n  ```\r\n\r\n  对象在内存中存储方式：  \r\n  ![对象的内存图示](assets/001/07/02-1544607318000.png)\r\n\r\n\r\n\r\n## 对象的继承\r\n> 继承：一个对象拥有另一个对象的属性与方法\r\n\r\n* 父类（基类）：被继承的对象，\r\n* 子类：继承的对象。\r\n\r\n**优点：** </br> \r\n提高代码的重用性，提高代码的逻辑性与可维护性。\r\n\r\n\r\n### 继承方式\r\n1. 原型继承(将父类的实例作为子类的原型)\r\n  > 原理：对象访问属性方法会遵循 \"构造函数 -> 原型\"的顺序，所以将父类的实例放到子类原型时， 子类实例化出的对象就可以访问到原型上父类的内容，从而实现了继承。\r\n  ```js\r\n  function Animal(){\r\n    eat: function(food){\r\n      alert(food)\r\n    }\r\n  }\r\n  function Cat(){ }\r\n  Cat.prototype = new Animal();    // 将父类(Animal)的实例作为子类(Cat)的原型\r\n  var tom = new Cat();\r\n\r\n  cat.eat(\'fish\')     // 弹出 \'fish\'\r\n\r\n  console.log(tom instanceof Animal);     //true\r\n  console.log(tom instanceof Cat);        //true\r\n  ```\r\n2. **call** <br/>\r\n\t格式：fun.call(obj2,参数1, 参数2...)<br/>\r\n\t本质上来说，call方法实际上就是要改变fun函数内的this指向。\r\n  ```javascript\r\n  function Animal () {\r\n    this.eat = function(food){\r\n      alert(food)\r\n    }\r\n  }\r\n  function Cat () {\r\n      this.name = \"tom\";\r\n  }\r\n  var animal = new Animal ();\r\n  var cat = new Cat ();\r\n  animal.eat.call(cat, \"鱼\")   // 继承单个方法(改变单个方法的this指向)\r\n\r\n  // 继承整个构造函数 (改变整个构造函数的this指向)\r\n  Animal.call(cat)\r\n  cat.say(\"鱼\")\r\n  ```\r\n\r\n3. **apply** <br/> 用法基本与call相同，函数的参数通过数组传递<br/>\r\n\t格式：fun.apply(obj2,[参数1, 参数2...])\r\n  ```javascript\r\n  function Animal () {\r\n    this.eat = function(food){\r\n      alert(food)\r\n    }\r\n  }\r\n  function Cat () {\r\n      this.name = \"tom\";\r\n  }\r\n  var animal = new Animal ();\r\n  var cat = new Cat ();\r\n  animal.eat.apply(cat, [\"鱼\"])\r\n\r\n  Animal.apply(cat)\r\n  cat.eat(\"鱼\")\r\n  ```\r\n4. bind继承\r\n  * `bing`用法与 `call`类似,也是可以改变函数体内 this 的指向\r\n  * call与apply是使用时立即执行函数，`bind`是返回对应函数，便于稍后调用\r\n  ```javascript\r\n  function Animal () {\r\n    this.eat = function(food){\r\n      alert(food)\r\n    }\r\n  }\r\n  function Cat () {\r\n      this.name = \"tom\";\r\n  }\r\n  var animal = new Animal ();\r\n  var cat = new Cat ();\r\n  animal.eat.bind(cat, \"鱼\")()   // bind只是改变了this指向，想要调用该函数还需()\r\n  ```\r\n\r\n5. ES6类继承\r\n  > 通过`extends`关键字实现类与类之间的继承，然后实例化子类，来实现继承。详见下一节\r\n\r\n\r\n#### 继承的顺序\r\n优先级：对象本身-->构造函数-->原型链\r\n\r\n**原型链:**  \r\n当访问对象的属性或方法时，该属性或方法会在对象本身调用，对象本身没有则去对象本身的构造函数调用，本身构造函数没有则去父类的构造函数调用、父类的原型...以此类推，直到寻找至Object、以及Object的原型、null。最后属性不存在时会得到`undefined`，方法不存在则会报错。\r\n\r\n```js\r\n  Object.prototype.say=function(){\r\n      alert(\"Object的方法\");\r\n  }\r\n  function person(){\r\n      this.say=function(){\r\n          alert(\"person的方法\");\r\n      }\r\n  }\r\n  person.prototype.say=function(){\r\n      alert(\"person原型的方法\");\r\n  }\r\n  function student(){\r\n      this.say=function(){\r\n          alert(\"student的方法\");\r\n      }\r\n  }\r\n  student.prototype=new person();\r\n  var xiaoming=new student();\r\n  xiaoming.say=function(){\r\n      alert(\"xiaoMing的方法\");\r\n  }\r\n  xiaoming.say();\r\n```\r\n\r\n\r\n","timestamp":1585877701769},{"name":"03-Class.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/03-Class.md","content":"# class（类）\r\n>ES6引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。类在大部分功能其实可以通过ES6之前的语法实现。\r\n\r\n\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=es6-class\" frameborder=\"0\"></iframe>\r\n\r\n\r\n## 类的定义       \r\nES6 的类，完全可以看作构造函数的另一种写法。\r\n```js\r\nclass People {\r\n  constructor(name,age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n  //属性放在constructor方法中\r\n  toString() {\r\n    return this.name+\'今年\'+this.age;\r\n  }\r\n}\r\ntypeof People   //function\r\n```\r\n\r\n* constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\r\n\r\n  ```javascript\r\n  class Foo {\r\n    constructor() {\r\n      return Object.create(null);\r\n    }\r\n  }\r\n\r\n  console.log(new Foo() instanceof Foo)  // false\r\n  ```\r\n\r\n* 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\r\n\r\n  ```javascript\r\n  class Foo {\r\n    constructor() {\r\n      return Object.create(null);\r\n    }\r\n  }\r\n\r\n  Foo()  //报错： Class constructor Foo cannot be invoked without \'new\'\r\n  ```\r\n\r\n* 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）\r\n\r\n  ```javascript\r\n  class Point {\r\n    constructor(x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n    toString() {\r\n      return \'(\' + this.x + \', \' + this.y + \')\';\r\n    }\r\n  }\r\n\r\n  var point = new Point(2, 3);\r\n  point.toString()                 // (2, 3)\r\n  point.hasOwnProperty(\'x\')        // true\r\n  point.hasOwnProperty(\'y\')        // true\r\n  point.hasOwnProperty(\'toString\') // false\r\n  point.__proto__.hasOwnProperty(\'toString\') // true\r\n  ```\r\n\r\n* 不存在变量提升：ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\r\n\r\n  ```javascript\r\n  new Foo(); // ReferenceError\r\n  class Foo {}\r\n  ```\r\n\r\n* Class表达式\r\n  * 与函数一样，类也可以使用表达式的形式定义。\r\n\r\n    ```javascript\r\n    const MyClass = class Me {\r\n      getClassName() {\r\n        return Me.name;\r\n      }\r\n    };\r\n    //这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类\r\n    ```\r\n\r\n  * 采用Class表达式，可以写出立即执行的Class。\r\n\r\n    ```javascript\r\n    let person = new class {\r\n      constructor(name) {\r\n        this.name = name;\r\n      }\r\n      sayName() {\r\n        console.log(this.name);\r\n      }\r\n    }(\'张三\');\r\n\r\n    console.log(person.sayName()); // \"张三\"  undefined\r\n    ```\r\n\r\n* 静态方法\r\n     * 静态方法只有类本身和他的子类可以调用，实例化的对象不可以调用\r\n```js\r\nclass P{\r\n\tstatic pF(){\r\n\t\tconsole.log(\'父类静态方法\');\r\n\t}\r\n}\r\nclass C extends P{\r\n}\r\nvar p1=new P();\r\nP.pF();              //父类静态方法\r\nC.pF();               //父类静态方法\r\np1.pF();             //p1.pF is not a function\r\n```\r\n静态方法可以直接通过类调用，不要要生成实例，它的主要作用方便我们使用(Math对象上的方法)\r\n\r\n* 私有方法     \r\n      * 私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。<br/>使用symbol设置\r\n```js\r\nconst bar = Symbol(\'bar\');\r\nconst snaf = Symbol(\'snaf\');\r\nexport default class myClass{\r\n  // 公有方法\r\n  foo(baz) {\r\n    this[bar](baz);\r\n  }\r\n  // 私有方法\r\n  [bar](baz) {\r\n    return this[snaf] = baz;\r\n  }\r\n // ...\r\n};\r\n```\r\n bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。<br/>\r\n\r\n\r\n\r\n\r\n\r\n## Class的继承\r\n\r\n### 基本用法\r\n\r\n* Class之间可以通过extends关键字实现继承\r\n\r\n  ```javascript\r\n  class ColorPoint extends Point {\r\n    constructor(x, y, color) {\r\n      super(x, y); // 调用父类的constructor(x, y)\r\n      this.color = color;\r\n    }\r\n    toString() {\r\n      return this.color + \' \' + super.toString(); // 调用父类的toString()\r\n    }\r\n  }\r\n  ```\r\n\r\n* 类的 prototype 属性和 \\__proto__ 属性\r\n>每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。<br/>\r\n * 子类的__proto__属性，表示构造函数的继承，总是指向父类。<br/>\r\n * 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。\r\n\r\n  ```javascript\r\n  class A {\r\n  }\r\n  class B extends A {\r\n  }\r\n  B.__proto__ === A // true\r\n  B.prototype.__proto__ === A.prototype // true\r\n  ```\r\n\r\n* Extends 的继承目标\r\n>extends关键字后面可以跟多种类型的值。\r\n\r\n  ```javascript\r\n  class B extends A {\r\n\r\n  }\r\n  ```\r\n  >上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。\r\n\r\n  下面我们叙述三种特殊情况：\r\n  * 第一种特殊情况，子类继承Object类。\r\n\r\n   ```javascript\r\n    class A extends Object {\r\n\r\n    }\r\n    A.__proto__ === Object // true\r\n    A.prototype.__proto__ === Object.prototype // true\r\n    ```\r\n    这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。\r\n\r\n  * 第二种特殊情况，不存在任何继承。\r\n\r\n    ```javascript\r\n    class A {\r\n\r\n    }\r\n    A.__proto__ === Function.prototype // true\r\n    A.prototype.__proto__ === Object.prototype // true\r\n    ```\r\n    这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.\\__proto__指向构造函数（Object）的prototype属性。\r\n\r\n  * 第三种特殊情况，子类继承null。\r\n\r\n    ```javascript\r\n    class A extends null {\r\n\r\n    }\r\n    A.\\__proto__ === Function.prototype // true\r\n    A.prototype.\\__proto__ === undefined // true\r\n    ```\r\n    这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。\r\n\r\n    ```javascript\r\n    class C extends null {\r\n        constructor() { return Object.create(null); }\r\n    }\r\n    ```\r\n","timestamp":1585877701769},{"name":"04-面向对象编程.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/04-面向对象编程.md","content":"# 面向对象编程\r\n>面向对象即OOP(Object Oriented Programming)，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例.\r\n> JS的面向对象，能很大程度上提高代码的重用率\r\n\r\n## 特性\r\n1. 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。\r\n2. 继承：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写\r\n3. 抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。\r\n4. 多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。\r\n\r\n\r\n## 面向对象\r\n1. 对象：对象是一个整体，对外提供一些操作。\r\n2. 面向对象：使用对象时，只关注对象提供的功能，不关注其内部细节。\r\n3. JS的对象组成：方法 和 属性\r\n\r\n## 从面向过程到面向对象\r\n面向过程编程首先想到的是需要实现什么功能——调用系统函数，或者自己自定义函数，然后按部就班的执行就行了           \r\n面向对象编程首先想到的是应该由什么样的主体去实现什么样的功能，再把该主体的属性和功能统一的进行封装，最后才去实现各个实体的功能。\r\n面向对象并不是一种技术，而是一种思想，是一种解决问题的最基本的思维方式\r\n\r\n### 二者的比较\r\n* 都可以实现代码重用和模块化编程，面向对象的模块化更深，数据也更封闭和安全\r\n* 面向对象的思维方式更加贴近现实生活，更容易解决大型的复杂的业务逻辑\r\n* 从前期开发的角度来看，面向对象比面向过程要更复杂，但是从维护和扩展的角度来看，面向对象要远比面向过程简单！\r\n* 面向过程的代码执行效率比面向对象高。\r\n\r\n## 面向对象编程的思想\r\n就是将一切的东西看作对象，将其中的行为封装为方法，特征封装为属性。        \r\njavascript以前使用构造函数来进行封装，我们使用它来模拟其他言语中的类(如果你了解过其他语言的话)，ES6之后有了类，我们可以使用class关键字来创建类，然后将某种事物的特征和行为抽象出来，我们可以在需要使用的时候，通过实例化类来创建我们的对象。          \r\n面向对象的核心思想是：不仅仅是简单的将功能进行封装（封装成函数），更是对调用该功能的主体进行封装，实现某个主体拥有多个功能，在使用的过程中，先得到对应的主体，再使用主体去实现相关的功能。\r\n\r\n## 面向对象分析实现过程\r\n1. 分析哪些动作是由哪些实体发出的\r\n2. 定义这些实体，为其增加相应的属性和功能\r\n3. 让实体去执行相应的功能|动作\r\n","timestamp":1585877701769},{"name":"05-Object对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/05-Object对象.md","content":"# JavaScript 对象的分类\r\n1. 内置对象：ECMAScript内置的对象，直接拿来用就可以，不需要实例化\r\n    * 内置顶层对象(global): Math;\r\n2. 本地对象:需要实例化才能用\r\n    * String;\r\n    * Boolean;\r\n    * Number;\r\n    * Function;\r\n    * Array;\r\n3. 宿主对象: BOM DOM\r\n    > 宿主：js的执行环境\r\n\r\n\r\n\r\n## Object对象\r\n### Object的属性\r\n1. constructor：是对构造函数的引用。\r\n2. prototype：是对函数对象的原型引用\r\n    * 是函数对象的默认属性。\r\n    * 可以将对象的共有属性存放到原型上，也可以实现继承。\r\n\r\n### Object的方法\r\n#### 1. Object.assign(obj1,obj2,obj3,......)\r\n> 可用于对象的拼接，将obj2，obj3......拼接到对象obj1上，并将obj1返回，obj1改变，其他对象不变。\r\n\r\n```js\r\nvar obj1={name:\'张三\'};\r\nvar obj2={age:18};\r\nvar obj3={say:function(){\r\n  console.log(\'说话\');\r\n}}\r\nconsole.log(Object.assign(obj1,obj2,obj3));    //{name: \"张三\", age: 18, say: ƒ}\r\nconsole.log(obj1,obj2);                   // {name: \"张三\", age: 18, say: ƒ}   {age: 18}\r\n```\r\n* 特殊用法： 对象拷贝：\r\n\r\n```js\r\n// 将对象obj拷贝到newObj\r\nvar obj = {name: \'张三\', age: 20};\r\n\r\nvar newObj = Object.assign({},obj);\r\n```\r\n\r\n#### 2. Object.is(a,b);\r\n>用于判断两个值是否相同,与===类似，但又不完全一样\r\n\r\n```js\r\nObject.is(+0,-0);               //false\r\nObject.is(NaN,NaN);               //true\r\n```\r\n\r\n#### 3. obj.prototype.isPrototypeOf(b);\r\n>确定一个对象是否存在于另一个对象的原型链中\r\n\r\n```js\r\nfunction a(){\r\n}\r\nvar b = new a();\r\nconsole.log(a.prototype.isPrototypeOf(b));      //true\r\n```\r\n\r\n#### 4. Object.defineProperty()\r\n>直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为`undefined`      \r\n\r\n语法: `Object.defineProperty(obj, prop, descriptor)`\r\n```js\r\nvar obj = new Object();\r\nObject.defineProperty(obj, \'name\', {\r\n    configurable: false,\r\n    writable: true,\r\n    enumerable: true,           //该属性是否可枚举\r\n    value: \'张三\'\r\n})\r\nconsole.log(obj.name)  //张三\r\n```\r\n\r\n#### 5. Object.defineProperties()\r\n>直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。       \r\n\r\n语法: `Object.defineProperties(obj, props)`  \r\nprops数据描述：  \r\n* value: 属性对应的值,可以使任意类型的值，默认为 **undefined**\r\n* configurable: 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为**false**。\r\n* writable: 属性的值是否可以被重写。设置为true可以被重写。默认为**false**。\r\n* enumerable: 属性是否可以被枚举(使用for...in或Object.keys())。设置为true可以被枚举。默认为**false**。\r\n\r\n```js\r\nvar obj = new Object();\r\nObject.defineProperties(obj, {\r\n    name: {\r\n        value: \'张三\',\r\n        configurable: false,\r\n        writable: true,\r\n        enumerable: true\r\n    },\r\n    age: {\r\n        value: 18,\r\n        configurable: true\r\n    }\r\n})\r\nconsole.log(obj.name, obj.age) // 张三, 18\r\n```\r\n\r\n#### 6. Object.freeze(obj)\r\n> 阻止修改现有属性的特性和值，并阻止添加新属性。 \r\n\r\n```js\r\nvar obj={name:\'张三\',age:18};\r\nObject.freeze(obj)\r\nobj.name=\'李四\';\r\nobj.sex=\'男\';\r\nconsole.log(obj)                //{name: \"张三\", age: 18}\r\n```\r\n\r\n用途：用`const`声明的对象属性方法任然可修改，可以利用这个方法将对象彻底冻结，使其符合const变量的含义\r\n```js\r\nvar obj = {\r\n    name:\"zhangsan\",\r\n    age: 20\r\nObject.freeze(obj)\r\nobj.name = \"lisi\"\r\nconsole.log(obj.name)     // \"zhangsan\"\r\n```\r\n\r\n### ES6对象的遍历\r\n#### 1. for in 循环\r\n> 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).\r\n\r\n```js\r\nvar obj={\r\n  name:\'小米\',\r\n  age:18,\r\n  say:function(){\r\n    console.log(\'你好\');\r\n  }\r\n}\r\nfor (var i in obj) {\r\n  console.log(obj[i]);\r\n}\r\n```\r\n\r\n#### 2. Object.keys(obj)\r\n> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的`键名`。\r\n\r\n```js\r\nvar obj = {\'a\':\'123\',\'b\':\'345\'};\r\nconsole.log(Object.keys(obj));  //[\'a\',\'b\']\r\n\r\n// 如果键名是数字，则按从小到大排列\r\nvar obj1 = { 100: \"a\", 2: \"b\", 7: \"c\"};\r\nconsole.log(Object.keys(obj1)); // console: [\"2\", \"7\", \"100\"]\r\n \r\nvar obj2 = Object.create({}, { getFoo : { value : function () { return this.foo } } });\r\nobj2.foo = 1;\r\nconsole.log(Object.keys(obj2)); // [\"foo\"]\r\n```\r\n\r\n> 由于 `for...in`会遍历出继承的属性，使问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用`for...in`循环，而用`Object.keys()`代替。\r\n\r\n\r\n#### 3. Object.getOwnPropertyNames(obj);\r\n> 返回一个数组,包含对象自身的所有属性(不含Symbol属性,但是包括不可枚举属性).\r\n\r\n#### 4. Object.getOwnPropertySymbols(obj);\r\n>返回一个数组，包含对象自身的所有Symbol属性。\r\n\r\n#### 5. Reflect.ownKeys(obj);\r\n>返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举.  \r\n\r\n#### 6. Object.values(obj)\r\n> 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用`for...in`循环的顺序相同( 区别在于 for-in 循环枚举原型链中的属性 )。\r\n\r\n```js\r\nvar obj = { name: \'zhangsan\', age: 20 };\r\nconsole.log(Object.values(obj)); // [\'zhangsan\', 20]\r\n```\r\n\r\n","timestamp":1585877701769},{"name":"06-Math对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/06-Math对象.md","content":"# Math对象\r\n>Math（算数）对象的作用是：执行常见的算数任务。\r\n>没有构造函数 Math()，在使用Math上的方法和属性时无需创建，把 Math当作对象使用就可以调用其所有属性和方法就就可以。\r\n\r\n\r\n## Math的常用方法\r\n| 方法 |  方法描述 |\r\n| ---- | ---- |\r\n| Math.abs(x)\t|返回x的绝对值。|\r\n| **Math.round(x)** |\t返回x四舍五入之后的整数值 |\r\n| **Math.ceil(x)** |\t返回x的近似值，向上取整  |\r\n| **Math.floor(x)**\t| 返回x的近似值，向下取整 |\r\n| **Math.max(x,y)** |\t返回x,y中的最大值 |\r\n| **Math.min(x,y)** |\t 返回x,y中的最小值 |\r\n| **Math.random()**\t| 返回一个0~1之间的数字|\r\n|Math.trunc(x)\t| 将x的小数部分去除，返回整数部分(ie不能使用) |\r\n|**Math.pow(x,y)**\t|  取x的y次幂|\r\n|Math.sqrt(x)\t|  返回x的平方根  |\r\n|Math.sin(x)|\t 返回x的正弦值 |\r\n|Math.cos(x)|\t返回x的余弦值 |\r\n|Math.tan(x)\t| 返回x的正切值 |\r\n|Math.asin(x)\t| 返回x的反正弦值|\r\n|Math.acos(x)\t| 返回x的反余弦值|\r\n|Math.atan(x)|\t返回x的反正切值|\r\n\r\n### 小技巧\r\n1. 取x的y次方根\r\n```js\r\nMath.pow(x,1/y)\r\n```\r\n2. 查找数组中最大和最小的数字\r\n```js\r\nvar arr=[23,4,651,461,1231,411];\r\nvar maxArr=Math.max(...arr);    //  arr数组中的最大值\r\nvar minArr=Math.min(...arr);   //  arr数组中的最小值\r\n```\r\n\r\n3. **取x-y的随机数、随机整数**\r\n```js\r\nMath.floor( Math.random() * (y - x) + x )      // 包含x不包含y\r\nMath.floor( Math.random() * (y - x + 1) + x  )      // 包含x包含y\r\n```\r\n    > 注：取随机整数必须使用`Math.floor`取整， `Math.ceil`和`Math.round`会导致两端的值取到几率变小\r\n\r\n## Math上的属性\r\n| 属性 |  属性描述 |\r\n| ---- | ---- |\r\n|PI\t|返回圆周率（约等于3.14159）。|\r\n|E\t|返回算术常量 e，即自然对数的底数（约等于2.718）。|\r\n|LN2|\t返回 2 的自然对数（约等于0.693）。|\r\n|LN10\t|返回 10 的自然对数（约等于2.302）。|\r\n|LOG2E|\t返回以 2 为底的 e 的对数（约等于 1.414）。|\r\n|LOG10E|\t返回以 10 为底的 e 的对数（约等于0.434）。|\r\n|SQRT1_2|\t返回返回 2 的平方根的倒数（约等于 0.707）。|\r\n|SQRT2|\t返回 2 的平方根（约等于 1.414）。|\r\n","timestamp":1585877701769},{"name":"07-String对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/07-String对象.md","content":"# 字符串(String)\r\n>字符串用于存储和处理文本。字符串对象是用来处理字符串\r\n\r\n## 单引号和双引号的区别\r\n1. 代码编译的角度说的话，单引号在JS中被浏览器（IE，Chrome，Safari）编译的速度更快（在FireFox中双引号更快）\r\n2. 双引号会搜索引号内的内容是不是有变量，有则输出其值，没有则输出原有内容。\r\n3. 单引号内的内容会被认定为是纯字符串\r\n4. json格式的文件必须使用双引号\r\n    ```json\r\n    {\r\n        \"name\": \"张三\",\r\n        \"age\": 20\r\n    }\r\n    ```\r\n\r\n## 属性\r\n1. length :字符串的长度\r\n    ```js\r\n    var str=\'hello word\';\r\n    console.log(str.length)    //10\r\n    ```\r\n## 方法\r\n\r\n1. str.charAt(index);     \r\n    * 功能：返回下标为index的子字符串\r\n    * 参数: 数字下标\r\n    * 返回值: 对应下标字符串\r\n2. str.charCodeAt(index);       \r\n    * 功能: 根据下标，返回对应下标的字符的ACSCII码\r\n    * 参数: 数字下标\r\n    * 返回值: 对应下表字符ACSCII码\r\n3. String.fromCharCode(97);         \r\n    * 功能: 将ACSCII码转化成字符串，涉及到数字与字母之间的转化可以使用该方法\r\n    * 参数: 十进制ACSCII码\r\n    * 返回值: ACSCII码对应字符串\r\n4. str.indexOf(\'a\');       \r\n    * 功能： 查找一个字符或者字符串在字符串中第一次出现的位置,**未找到则返回-1**、\r\n    * 参数： 要查找的字符串\r\n    * 返回值： 目标字符串的下标位置，未找到则未-1\r\n    ```js\r\n    var str=\'hello world\';\r\n    str.indexOf(\'a\');         //-1\r\n    str.indexOf(\'o\');        //4\r\n    ```\r\n5. str.lastIndexOf(\'a\')     \r\n    * 功能： 倒序查找一个字符或者字符串在字符串中第一次出现的位置,返回位置，,**未找到则返回-1**、\r\n    ```js\r\n    var str=\'hello world\';\r\n    str.lastIndexOf(\'o\');      //7\r\n    ```\r\n6. str.replace(\"替换的内容\",\"替换后的内容\")   \r\n    * 功能： 将指定的字符串替换，**只能替换第一个**\r\n    * 参数： 1. 要替换的内容； 2. 替换后的内容 \r\n    * 返回值： 返回替换后的字符串\r\n    * 注意： 不修改原字符串，所以使用时需要将`replace`方法的返回值保存\r\n    ```js\r\n    var str=\'hello world\';\r\n    str.replace(\'o\',\'a\');        //\"hella world\"\r\n    ```\r\n    > `replace`支持正则查找，str.replace(/正则/,\"替换后的内容\")  \r\n\r\n7. str.slice(起始下标,结束下标)      \r\n    * 功能：字符串截取，识别负数，跟数组相同\r\n    * 参数：1. 截取起始下标； 2. 截取结束下标。参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\r\n    * 返回值：返回值是截取到的字符串\r\n    * 注意： 截取时，包含起始下标，不包含结束下标； 不修改原字符串\r\n8. str.substring(起始下标,结束下标)        \r\n    * 功能： 字符串截取，同`slice`方法，但不识别负数\r\n9.  str.substr(起始下标，截取的长度)          \r\n    * 功能：根据长度进行字符串截取\r\n    * 参数： 1. 起始下标； 2. 截取的长度\r\n\r\n10. str.split(\'\')     \r\n    * 功能： 以某一字符串将目标字符串分割，可用于将特定格式的字符串转化如`2018/10/20`\r\n    * 参数： 需要分割的字符串\r\n    * 返回值： 原字符串呗参数字符串分割之后的**数组**\r\n    * 注意： 返回值中传入的字符串会被删掉，不修改原字符串\r\n    ```js\r\n    var str=\'hello world\';\r\n    console.log(str.split(\'o\'));   //[\"hell\", \" w\", \"rld\"]\r\n    console.log(str.split(\'\'));    //[\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\r\n    ```\r\n11. str.toLowerCase()  \r\n    * 将str字符串中的字符转化为小写，不修改原字符串\r\n12. str.toUpperCase()  \r\n    * 将str字符串中的字符转化为大写\r\n13. str.trim()   \r\n    * 将字符串左右空格去除，可用于接收表单数据            IE9以下不识别\r\n    * 返回值： 去掉左右空格之后的字符串\r\n    ```js\r\n    var a=\'   aa   bb   \';\r\n    a.trim();       //\"aa   bb\"\r\n    ```\r\n14. str.match()     \r\n    * 在字符串内检索指定的值，或找到一个或多个正则表达式的匹配\r\n    * 参数： 可以是字符串或者正则表达式\r\n    * 返回值：检索到的结果\r\n    ```js\r\n    var str=\'hello world\';\r\n    str.match(\'o\');   //[\"o\", index: 4, input: \"hello world\", groups: undefined]\r\n    str.match(/o/g);   // (2) [\"o\", \"o\"]\r\n    ```\r\n15. str.concat(\'a\',\'b\',\'c\')        \r\n    * 功能： 用于连接两个或多个字符串,与数组中的concat方法很象，不会修改原字符串\r\n    * 参数： 多个字符串\r\n    * 返回值：拼接之后的长字符串\r\n16. str.padStart() 、str.padEnd()        \r\n    * 功能： 向字符串开头(padStart)或结尾(padEnd)添加字符，使字符串达到指定的长度。返回在原字符串开头或末尾填充指定的填充字符串直到目标长度所形成的新字符串\r\n    * 参数1: 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。\r\n    * 参数2: （可选）填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。\r\n    * 注意事项\r\n        * 不写第二个参数填充字符串，则默认用空格填充\r\n        * 填充字符串会自动重复直到达到目标长度\r\n        * 如果原字符串长度已经大于等于目标长度，则直接返回原字符串\r\n\r\n    ```js\r\n    \'abc\'.padStart(10);         // \"       abc\"\r\n    \'abc\'.padStart(10, \"123\");  // \"1231231abc\"\r\n    \'abc\'.padStart(6,\"123465\"); // \"123abc\"\r\n    \'abc\'.padStart(8, \"0\");     // \"00000abc\"\r\n    \'abc\'.padStart(1);          // \"abc\"\r\n\r\n    \'abc\'.padEnd(10);         // \"abc       \"\r\n    \'abc\'.padEnd(10, \"123\");  // \"abc1231231\"\r\n    \'abc\'.padEnd(6,\"123465\"); // \"abc123\"\r\n    \'abc\'.padEnd(8, \"0\");     // \"abc00000\"\r\n    \'abc\'.padEnd(1);          // \"abc\"\r\n    ```\r\n    * 使用场景：得到具有固定长度的数据 （时间、二进制数、十六进制数）\r\n    ```js\r\n    // 获取时间，如果只有一位则前面用0填充\r\n    var time = new Date();\r\n    var h = String(time.getHours()).padStart(2,\'0\')\r\n    var m = String(time.getMinutes()).padStart(2,\'0\')\r\n    var s = String(time.getSeconds()).padStart(2,\'0\')\r\n    console.log(`${h}:${m}:${s}`)    // 18:09:03\r\n    ```\r\n\r\n### 字符串与json对象之间的转换\r\n1. JSON.stringify()             将对象转化为字符串\r\n2. JSON.parse()                 将字符串转化为对象\r\n","timestamp":1585877701769},{"name":"08-Array对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/08-Array对象.md","content":"## 数组方法和属性\r\n### 属性\r\n1. length: 数组中元素的个数\r\n2. constructor: 返回对创建此对象的数组函数的引用（可以用来判断变量是否为数组）\r\n\r\n### 方法\r\n1. arr.push(); 向数组的末尾追加元素\r\n    * 会修改原数组\r\n    * 返回值：修改后的length值\r\n    * 可以追加多个\r\n    ```js\r\n    arr[1,2,3];\r\n    arr1[4,5,6];\r\n    arr2[...arr,...arr1];       //  ...扩展运算符，将数组展开\r\n    ```\r\n\r\n2. arr.unshift(); 向数组的开头添加函数\r\n    * 会修改原数组\r\n    * 返回值：修改后的length值\r\n    * 可以追加多个\r\n\r\n3. arr.pop();   删除末尾的元素\r\n    * 会修改原数组\r\n    * 返回值：被删除的数据\r\n    * 只能删除一个\r\n\r\n4. arr.shift();  开头删除一个元素\r\n    * 会修改原数组\r\n    * 返回值：被删除的数据\r\n    * 只能删除一个\r\n\r\n5. arr.splice(位置，删除元素的个数，要追加的元素);   任意位置添加删除\r\n    * 添加或者删除包含对应下标\r\n    * 添加数据时：删除元素的个数写0；\r\n    * 可以同时删除和添加（先删除，后添加）\r\n    * 修改原数组\r\n\r\n6. arr.join(\"分隔符\") 使用分隔符将数组数据隔开变为字符串\r\n    * 不修改原数组\r\n    * 返回值是分隔好的字符串\r\n7. arr.slice(截取的起始下标,结束下标) 数组的截取\r\n    * 截取时，包含起始下标，不包含结束下标\r\n    * 不修改原数组\r\n    * 返回值是截取到的数组\r\n    * 参数可以是负数，负数表示倒数，只传一个参数表示从起始下标截取到最后\r\n8. arr.concat 多个数组的连接\r\n    * 不修改原数组\r\n    * 返回值是连接之后的新数组       \r\n    ```js\r\n    var arr1=[1,2,3];\r\n    var arr2=[4,5,6];\r\n    console.log(arr1.concat(arr2,[7,8,9]));\r\n\r\n    // 控制台输出\r\n    // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n    ```\r\n9. arr.indexOf(值);   查找某个值在数组中第一次出现的下标\r\n    * 返回值是数据的下标，没有找到则返回-1\r\n    ```js\r\n    var arr=[1,5,6,99,52,663,22,66,552,123,6,622];\r\n    console.log(arr.indexOf(22));    //查找22在arr数组中的位置\r\n\r\n    // 控制台输出\r\n    // 6\r\n    ```\r\n\r\n10. arr.lastIndexOf(值);   倒叙查找某个值在数组中第一次出现的位置\r\n11. arr.sort()     数组的排序\r\n    * 如果没有参数，则从字符的编码开始按顺序排\r\n    * 如果有参数，这个参数必须是一个函数（回调函数）这个回调函数有两个参数，分别是a，b\r\n    * 修改原数组\r\n    * 返回值是排序之后的数组                \r\n    ```js\r\n    var arr3=[1,5,6,99,52,663,22,66,552,6,622];\r\n    arr3.sort(function(a,b){\r\n    //a-b 正序，\r\n    //b-a 倒序，  \r\n    return a-b;\r\n    })\r\n    console.log(arr3);\r\n    // 控制台输出\r\n    // (11) [1, 5, 6, 6, 22, 52, 66, 99, 552, 622, 663]\r\n    //箭头函数\r\n    arr.sort((a,b)=>a-b)     //正序，\r\n    arr.sort((a,b)=>b-a)     //倒序，\r\n    ```\r\n12. arr.forEach()   遍历数组\r\n    * 接收一个回调函数，回调函数第一个参数是 数组值\r\n    * 第二个参数是 下标\r\n    ```js\r\n    var arr3=[1,5,6,99,52,663,22,66,552,6,622];\r\n    arr3.forEach(function(value,index){\r\n        console.log(index,value)\r\n    })\r\n    // 箭头函数\r\n    arr3.forEach((value,index)=>{console.log(index,value)})\r\n    ```\r\n\r\n13. arr.filter()    过滤（根据条件筛选数组元素）\r\n    * 根据回调函数的返回值进行元素筛选\r\n        * 返回值是true，该元素会保留\r\n        * 返回值是false，该元素跳过\r\n    * 不修改原数组\r\n    * 返回值是筛选之后的数组\r\n    ```js\r\n    var arr=[1,5,6,99,52,663,22,66,552,123,6,622];\r\n    var newArr =arr.filter(function(value,index){\r\n    return value>100;       //筛选arr数组中值大于100的元素；\r\n    })\r\n    console.log(newArr);\r\n    // 控制台输出\r\n    // (4) [663, 552, 123, 622]\r\n    ```\r\n    ```js\r\n    var person = [\r\n    {name: \"张三\",age:20,sex: \"男\"},\r\n    {name: \"李四\",age:19,sex: \"女\"},\r\n    {name: \"王五\",age:22,sex: \"男\"},\r\n    {name: \"赵六\",age:21,sex: \"女\"}\r\n    ];\r\n    var x =person.filter(function(value,index){\r\n    return value.age>20;           // 筛选出年龄大于20岁的学生\r\n    // return value.sex==\"男\";     //筛选出男同学\r\n    })\r\n    console.log(x);\r\n    // 箭头函数\r\n    arr.filter((value,index)=>{return 判断条件})\r\n    ```\r\n14. arr.map()   映射 将数组中的所有数据按照条件改变，形成新数组\r\n    * 将回调函数每次的返回值，组成一个新的数组\r\n    * 返回值是映射改变之后的数组\r\n    * 不修改原数组\r\n    ```js\r\n    var arr=[1,5,6,99,52,663,22,66,552,123,6,622];\r\n    // var end=arr3.map(function(value,index){\r\n    // \treturn value*2;        //将数组中的所有元素都乘以2返回\r\n    // });\r\n    // 箭头函数\r\n    var end = arr.map((value,index)=>value*2);\r\n    console.log(end);\r\n    ```\r\n15. arr.some()    判断  根据回调函数的判断条件来选择真假\r\n    * 只要有一个回调函数返回值是true，最终some结果是true；\r\n    ```js\r\n    var arr3=[1,5,6,99,52,663,22,66,552,123,6,622];\r\n    var end=arr3.some(function(value,index){\r\n    return value<500;\r\n    });\r\n    console.log(end);     //true\r\n    ```\r\n\r\n16. arr.every()    判断   根据回调函数的判断条件来选择真假(与some比较记忆)\r\n    * 只要有一个回调函数返回值是false，最终every结果是false；\r\n    ```js\r\n    var arr3=[1,5,6,99,52,663,22,66,552,123,6,622];\r\n    var end=arr3.every(function(value,index){\r\n    return value<500;\r\n    });\r\n    console.log(end);     //false\r\n    ```\r\n\r\n17. arr.reverse() 数组倒序\r\n    * 返回修改后的数组\r\n    * 改变原数组\r\n    ```js\r\n    var arr=[1,5,8,6,9,4,2,3];\r\n    console.log(arr.reverse());     // (8) [3, 2, 4, 9, 6, 8, 5, 1]\r\n    console.log(arr);               // (8) [3, 2, 4, 9, 6, 8, 5, 1]\r\n    ```\r\n\r\n18. Array.from\r\n    * `Array.from` 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）\r\n    ```js\r\n    var a={length:2,0:\'aaa\',1:\'bbb\'};  \r\n    Array.from(a);        //[\'aaa\',\'bbb\']\r\n    // 原理：Array.prototype.slice.call(a);\r\n    var b={length:2};  \r\n    Array.from(b);       //[undefined.undefined]\r\n    ```\r\n\r\n20. Array.of\r\n    * `Array.of`方法用于将一组值，转换为数组。\r\n    * `Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\r\n    ```js\r\n    Array.of() // []\r\n    Array.of(undefined) // [undefined]\r\n    Array.of(1) // [1]\r\n    Array.of(1, 2) // [1, 2]\r\n    ```\r\n18. arr.includes()\r\n    * 用于检查数组是否包含某元素，包含返回true，否则返回false\r\n    * 无法检测对象是否存在\r\n    * 假如只想知道某个值是否在数组中而并不关心它的索引位置，建议使用`includes()`。如果想获取一个值在数组中的位置，那么你只能使用`indexOf`方法。并且`includes()`可以识别NaN\r\n    ```js\r\n    var arr = [1,2,{name:\"张三\"}]\r\n    arr.includes(2)     // true\r\n    arr.includes(4)     // false\r\n    arr.includes({name:\"张三\"})     // false\r\n    ```\r\n    * 可接收俩个参数：**要搜索的值,搜索的开始索引**\r\n    ```js\r\n    [\'a\', \'b\', \'c\', \'d\'].includes(\'b\')         // true\r\n    [\'a\', \'b\', \'c\', \'d\'].includes(\'b\', 1)      // true\r\n    [\'a\', \'b\', \'c\', \'d\'].includes(\'b\', 2)      // false\r\n    ```\r\n    * 此方法为 ES7新增，兼容性\r\n    ![arr.includes兼容性](assets/001/07/08-1545037228000.png)\r\n\r\n\r\n\r\n\r\n### 数组乱序\r\n> 将数组顺序打乱：例如不重复随机选取数组内容，可将数组打乱后按顺序取出\r\n\r\n`arr.sort(()=>Math.random()-0.5)`   数组乱序排列\r\n\r\n```js\r\nvar arr=[1,2,3,4,5,6,7,8,9];\r\narr.sort(()=>Math.random()-0.5)\r\nconsole.log(arr);\r\n```\r\n* 案例： 抽奖，有1等奖一名，2等奖1名，3等奖2名，未中奖5名，要求每次点击抽取一个奖项\r\n","timestamp":1585877701769},{"name":"09-Date对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/09-Date对象.md","content":"# Date对象\r\n>Date对象是用来处理日期和时间，Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。\r\n\r\n## 创建日期对象\r\n通过实例化Date来创建日期对象，传入参数的形式有以下几种\r\n\r\n```js\r\nnew Date()   \r\nnew Date(1543299465541);    //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\r\nnew Date(\'December 17, 1996 03:24:00\');   //传入日期的字符串形式\r\nnew Date(\'1995-12-17T03:24:00\');      \r\nnew Date(1996, 02, 07);           //传入年月日，不用加引号\r\nnew Date(1996, 02, 07, 3, 24, 0);   //  穿入年，月，日，时，分，秒\r\n\r\n\r\nnew Date();           //  不传参数返回当前时间对象 Tue Nov 27 2018 14:12:40 GMT+0800 (中国标准时间)\r\nnew Date(value);      //参数为时间戳返回时间戳对应的时间对象   (时间戳是从1970年1月1日开始的毫秒数 )\r\nnew Date(dateString);    //表示日期的字符串值。该字符串应该能被 Date.parse() 方法识别\r\nnew Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]);\r\n// year代表年份的整数值 month代表月份值（从0-11） day代表一个月中第几天  其余依次分别代表小时，分钟，秒，毫秒\r\n```\r\n\r\n## Date上的方法\r\n* Date.now()        返回自1970-1-1 00:00:00 UTC (世界标准时间)至今所经过的毫秒数。\r\n* Date.parse()    解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。\r\n\r\n### 获取日期信息的方法\r\n\r\n|方法|含义|\r\n|:----:|:----:|\r\n|getDate()|从 Date 对象返回一个月中的某一天 (1 ~ 31)|\r\n|getDay()| 从 Date 对象返回一周中的某一天 (0 ~ 6)|\r\n|getMonth()| 从 Date 对象返回月份 (0 ~ 11)|\r\n|getFullYear() |从 Date 对象以四位数字返回年份|\r\n|getHours()| 返回 Date 对象的小时 (0 ~ 23)|\r\n|getMinutes() |返回 Date 对象的分钟 (0 ~ 59)|\r\n|getSeconds() |返回 Date 对象的秒数 (0 ~ 59)|\r\n|getMilliseconds()| 返回 Date 对象的毫秒(0 ~ 999) |\r\n|getTime()| 返回 1970 年 1 月 1 日至今的毫秒数|\r\n|getTimezoneOffset() |返回本地时间与格林威治标准时间 (GMT) 的分钟差|\r\n\r\n### 设置日期的方法\r\n\r\n|    方法  |     含义  |\r\n|:--------:|:---------:|\r\n|setDate()| 设置 Date 对象中月的某一天 (1 ~ 31)|\r\n|setMonth() |设置 Date 对象中月份 (0 ~ 11)|\r\n|setFullYear()| 设置 Date 对象中的年份（四位数字）|\r\n|setHours()| 设置 Date 对象中的小时 (0 ~ 23)|\r\n|setMinutes()| 设置 Date 对象中的分钟 (0 ~ 59)|\r\n|setSeconds() |设置 Date 对象中的秒钟 (0 ~ 59)|\r\n| setMilliseconds() |设置 Date 对象中的毫秒 (0 ~ 999)|\r\n|setTime()| 以毫秒设置 Date 对象|\r\n| setUTCDate() |根据世界时设置 Date 对象中月份的一天 (1 ~ 31)|\r\n| setUTCMonth()| 根据世界时设置 Date 对象中的月份 (0 ~ 11)|\r\n| setUTCFullYear() |根据世界时设置 Date 对象中的年份（四位数字）|  \r\n| setUTCHours()| 根据世界时设置 Date 对象中的小时 (0 ~ 23)|\r\n| setUTCMinutes()| 根据世界时设置 Date 对象中的分钟 (0 ~ 59)|\r\n| setUTCSeconds()| 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)|\r\n| setUTCMilliseconds()| 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)|\r\n\r\n## 获取时间戳的方法\r\n1. var timestamp1 = Date.parse(new Date()); // 结果：1477808630000 不推荐这种办法，毫秒级别的数值被转化为000\r\n2. var timestamp2 = (new Date()).valueOf(); // 结果：1477808630404 通过valueOf()函数返回指定对象的原始值获得准确的时间戳值\r\n3. var timestamp3 = new Date().getTime(); // 结果：1477808630404 ，通过原型方法直接获得当前时间的毫秒值，准确\r\n4. var timetamp4 = Number(new Date()) ; //结果：1477808630404 ,将时间转化为一个number类型的数值，即时间戳\r\n5. Date.now()           //返回当前时间的时间戳\r\n\r\n\r\n## 课堂实例\r\n    * 网页动态显示当前时间\r\n    * 倒计时\r\n    * 网页版闹钟的实现\r\n    * 根据日期的不同时间段，做问候语：早上8:00-12:00 :“早上好！欢迎登陆系统” 中午12:00-14:00：“中午好！该休息了” 下午14:00-18:00：“下午好！欢迎登陆系统” 晚上19:00-00:00：“晚上好！XXXXXXXXX”\r\n    * 网页中实现一个计算当年还剩多少时间的倒数计时程序，要求网页上实时动态显示“××年还剩××天××时××分××秒”\r\n","timestamp":1585877701769},{"name":"10-正则对象.md","path":"001-前端/08-JavaScript/001-ECMA/07-对象/10-正则对象.md","content":"# 正则表达式\r\n>正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。\r\n>就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。\r\n\r\n## 正则的特点和应用\r\n* 灵活性、逻辑性和功能性非常强；\r\n* 可以迅速地用极简单的方式达到字符串的复杂控制。\r\n* 数据验证、文本替换、内容检索、过滤内容\r\n\r\n## javascript中的正则(RegExp 对象)\r\n>RegExp 是正则表达式的缩写。RegExp 对象用于存储检索模式，主要应用于数据验证和数据查询两个方面。\r\n\r\n### 创建\r\n* 实例化 RegExp对象\r\n```js\r\nvar reg=new RegExp(正则表达式,模式修正符);\r\n```\r\n\r\n|模式修正符|描述|\r\n| ---- | ---- |\r\n| i   | 执行对大小写不敏感的匹配。 |\r\n| g   | 执行全局匹配（查找所有匹配） |\r\n|  m  |  执行多行匹配 |\r\n\r\n```js\r\n// 简单案例\r\nvar arr=[\"aa\",\"bb\",\"cc\",\"dd\"];\r\nvar str=\"aaffddxxccrbbrffdd\";\r\nfunction mingan(arr,str){\r\n  arr.forEach((value,index)=>{\r\n    var reg=new RegExp(value,\"g\");\r\n    str=str.replace(reg,\"**\");\r\n  })\r\n  return str;\r\n}\r\nconsole.log(mingan(arr,str));\r\nconsole.log(str);\r\n```\r\n\r\n* 隐式创建\r\n```js\r\nvar reg=/正则表达式/\r\n//   //内不需要加引号\r\n```\r\n\r\n### RegExp的方法\r\n* test(字符串);         \r\n判断字符串是否符合正则的匹配，返回值是一个Boolean值\r\n\r\n* exec(字符串);    \r\n查询字符串中符合正则匹配的内容，返回值是数组。如果没有发现匹配，则返回 null。    \r\n    * 结果是数组\r\n    * index：查询到结果的下标\r\n    * input： 被查询到的字符串\r\n    * 如果正则表达式没有设置g，那么exec方法不会对正则表达式有任何的影响。 如果设置了g，那么exec执行之后会更新正则表达式的lastIndex属性，表示本次匹配后，所匹配字符串的下一个字符的索引，下一次再用这个正则表达式匹配字符串的时候就会从上次的lastIndex属性开始匹配。\r\n\r\n  ```js\r\n  var str=\"I love antzone ,this is animate\";\r\n  var reg=/an/g;\r\n  console.log(reg.exec(str));\r\n  console.log(reg.exec(str));\r\n  console.log(reg.exec(str));\r\n\r\n  // 控制台输出\r\n  //  [\"an\", index: 7, input: \"I love antzone ,this is animate\", groups: undefined]\r\n  //  [\"an\", index: 24, input: \"I love antzone ,this is animate\", groups: undefined]\r\n  //  null\r\n  ```\r\n* compile(正则表达式,[,flag]);     \r\n用于在脚本执行过程中编译正则表达式,也可用于改变和重新编译正则表达式。\r\n\r\n### 原子、量词、边界\r\n>原子是正则表达式中的最小的元素，包括英文、标点符号等\r\n\r\n| 原子 | 含义 |\r\n| ---- | ---- |\r\n| \\d   | 表示匹配1个0-9的数字 [0-9] |\r\n| \\D   [^0-9]  | 表示匹配除数字0-9以外的字符 |\r\n| \\w   | 匹配数字、字母、下划线 |\r\n| \\W   | 匹配除了数字、字母、下划线以外的字符 |\r\n| \\s   |  匹配空格 |\r\n| \\S   |  匹配非空格 |\r\n| .  |  查找单个字符，除了换行和行结束符  |\r\n| \\n |  查找换行符  |\r\n| \\n  |  换行字符 |\r\n| \\f  |　换页字符   |          \r\n|  \\r　| 回车字符 |\r\n|  \\t　|制表符 |\r\n|  \\v　|垂直制表符  |\r\n\r\n| 原子表  |  含义 |\r\n| ---- | ---- |\r\n|  [ ] |  只匹配其中的一个原子|\r\n|  [^]　| 只匹配\"除了\"其中字符的任意一个原子|\r\n|  [0-9]　| 匹配0-9任何一个数字|\r\n|  [a-z] |　匹配小写a-z任何一个字母|\r\n|  [A-Z]　|匹配大写A-Z任何一个字母|\r\n\r\n\r\n| 量词 | 含义 |\r\n| ---- | ---- |\r\n| {n}  |  规定前面的一个原子重复n次 |\r\n| {n,}  |  规定前面的一个原子重复n次及n次以上  |\r\n| {n,m}  |  规定前面的一个原子重复n-m次 |\r\n| * | 前面一个原子重复0-无数次 等价于{0,} |\r\n| + | 前面一个原子重复1-无数次 等价于{1,} |\r\n| ?=n  |  匹配任何其后紧接指定字符串 n 的字符串  |\r\n| ?!n  |  匹配任何其后没有紧接指定字符串 n 的字符串  |\r\n\r\n| 符号 | 含义 |\r\n| ---- | ---- |\r\n|  ^  |  从字符串开头进行匹配 |\r\n|  $  |  匹配到字符串的末尾  |\r\n| \\b |  匹配单词边界   |\r\n| \\B  |   匹配非单词边界   |\r\n|  &#166;(这是个管道符)  |  符号前后两个部分只要有一侧符合即可  |\r\n\r\n\r\n\r\n### 贪婪模式和吝啬模式\r\n1. 贪婪模式：查询时，查询到的字符尽可能多   （默认）\r\n2. 吝啬模式：查询时，查询到的字符尽可能少   \r\n      * `*?` 重复任意次，但尽可能少重复\r\n      * `+?` 重复1次或更多次，但尽可能少重复\r\n      * `??` 重复0次或1次，但尽可能少重复\r\n      * `{n,m}?` 重复n到m次，但尽可能少重复\r\n      * `{n,}?` 重复n次以上，但尽可能少重复\r\n\r\n### 字符串方法是用正则表达式\r\n1. search(/正则/)\r\n>返回值为第一个与正则相匹配的字符串的位置，如果没有找到任何匹配的子串，则返回 -1。\r\n\r\n2. replace(/正则/,str)\r\n>用str替换符合正则表达式的对应字符\r\n\r\n3. split(/正则/,num)\r\n>将字符串已正则匹配的内容分割为数组，num参数是可选参数，表示返回的个数\r\n\r\n\r\n### 小案例\r\n1. 用正则表达式验证身份证号\r\n```js\r\nvar reg=/^[1-9][0-9]{16}[0-9xX]$/     //正则匹配身份证号\r\nvar str=\"11112225478963589x\";\r\nconsole.log(reg.test(str))\r\n```\r\n2. 用正则表达式验证邮箱\r\n```js\r\nvar reg=new RegExp(/^([a-zA-Z0-9._-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/);\r\n```\r\n\r\n3. 16进制颜色正则\r\n```js\r\nvar reg=/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\r\n```\r\n\r\n4. 验证车牌号\r\n```js\r\nvar reg=/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/\r\n```\r\n\r\n#### js正则验证表单\r\n对表单进行验证是js正则最常用的地方，表单验证可以节省后台的一部分压力，提升网站的性能。主要验证有以下几个地方qq号、手机号、邮箱、姓名、密码、用户名等，通过结合onblur或者onchange事件，获取表单中的内容，对其进行正则判断，从而达到前台表单验证的效果。\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n <meta charset=\"UTF-8\">\r\n <title>完整验证表单</title>\r\n <style type=\"text/css\">\r\n *{margin: 0;padding: 0;list-style:none;}\r\n body{background:#ccc;}\r\n .demo{width:400px;padding:40px;background:#efefef;border:solid 1px #666;margin:100px auto 0;line-height:40px;}\r\n label{display:inline-block;width:20%;}\r\n input{width:60%;}\r\n </style>\r\n</head>\r\n<body>\r\n<div class=\"demo\">\r\n <ul>\r\n <li>\r\n  <label for=\"iptqq\">Q Q：</label>\r\n  <input type=\"text\" id=\"iptqq\">\r\n  <span></span>\r\n </li>\r\n <li>\r\n  <label for=\"iptPhone\">手机：</label>\r\n  <input type=\"text\" id=\"iptPhone\">\r\n  <span></span>\r\n </li>\r\n <li>\r\n  <label for=\"iptEmil\">邮箱：</label>\r\n  <input type=\"text\" id=\"iptEmil\">\r\n  <span></span>\r\n </li>\r\n <li>\r\n  <label for=\"iptNum\">密码：</label>\r\n  <input type=\"password\" id=\"iptNum\">\r\n  <span></span>\r\n </li>\r\n <li>\r\n  <label for=\"iptNum2\">再次密码：</label>\r\n  <input type=\"password\" id=\"iptNum2\">\r\n  <span></span>\r\n </li>\r\n <li>\r\n  <label for=\"iptName\">姓名：</label>\r\n  <input type=\"text\" id=\"iptName\">\r\n  <span></span>\r\n </li>\r\n  <li>\r\n  <label for=\"iptUser\">用户名：</label>\r\n  <input type=\"text\" id=\"iptUser\">\r\n  <span></span>\r\n </li>\r\n </ul>\r\n</div>\r\n</body>\r\n<script type=\"text/javascript\">\r\n (function(window){\r\n function $(id){\r\n  return document.getElementById(id);\r\n };\r\n // 获取对象\r\n var iptqq = $(\"iptqq\"),iptPhone = $(\"iptPhone\"),iptEmil = $(\"iptEmil\"),iptNum = $(\"iptNum\"),iptNum2 = $(\"iptNum2\"),iptName = $(\"iptName\"),iptUser= $(\"iptUser\");\r\n // 正则验证表达式\r\n // 验证密码\r\n var rxNum = /^[a-zA-Z]\\w{5,17}$/;\r\n // 验证QQ\r\n var rxqq = /^[1-9][0-9]{4,10}$/;\r\n // 验证手机\r\n var rxPhone = /^(13[0-9]|15[012356789]|18[0-9]|17[678]|14[57])[0-9]{8}$/;\r\n // 验证邮箱\r\n var rxEmil = /^\\w+@\\w+\\.\\w+$/;\r\n // 验证姓名\r\n var rxName = /^[\\u4E00-\\u9FA5]{2,}$/\r\n  // 验证用户名\r\n var rxUser = /^[a-zA-Z0-9_-]{4,16}$/\r\n // 验证密码\r\n cation(iptNum,rxNum);\r\n // 验证QQ\r\n cation(iptqq,rxqq);\r\n // 验证手机号\r\n cation(iptPhone,rxPhone);\r\n // 验证邮箱\r\n cation(iptEmil,rxEmil);\r\n // 验证姓名\r\n cation(iptName,rxName);\r\n // 验证用户名\r\n cation(iptUser,rxUser);\r\n // 封装验证函数\r\n iptNum2.onblur = function(){\r\n \tif(iptNum2.value==iptNum.value){\r\n\t \tiptNum2.nextElementSibling.innerHTML = \"正确\"\r\n\t   \tiptNum2.nextElementSibling.style.color = \"green\";\r\n\t}else{\r\n\t \tiptNum2.nextElementSibling.innerHTML = \"错误\"\r\n\t   \tiptNum2.nextElementSibling.style.color = \"red\";\r\n\t}\r\n }\r\n\r\n function cation(element,regExp){\r\n  element.onblur = function(){\r\n  var txt = this.value;\r\n  if( regExp.test( txt ) ){\r\n   this.nextElementSibling.innerHTML = \"正确\"\r\n   this.nextElementSibling.style.color = \"green\";\r\n  }else{\r\n   this.nextElementSibling.innerHTML = \"错误\"\r\n   this.nextElementSibling.style.color = \"red\";\r\n  }\r\n  }\r\n }\r\n })(window)\r\n</script>\r\n</html>\r\n```\r\n","timestamp":1585877701769},{"name":"08-Symbol.md","path":"001-前端/08-JavaScript/001-ECMA/08-Symbol.md","content":"# Symbol\r\n>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\r\n\r\n## Symbol函数的参数\r\n>Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。\r\n```js\r\n// 没有参数的情况\r\nvar s1 = Symbol();\r\nvar s2 = Symbol();\r\ns1 === s2 // false\r\n// 有参数的情况\r\nvar s3 = Symbol(\'fun\');\r\nvar s4 = Symbol(\'fun\');\r\ns3 === s4                // false\r\n```\r\n\r\n\r\n## 作为属性名的Symbol\r\n>每一个Symbol值都是不相等的，所以Symbol值可以作为标识符。      \r\n当用于对象的属性名时，可以保证不会出现同名的属性，防止某一个键被不小心改写或覆盖。    \r\n对象属性名是Symbol值时，不能用点运算符。\r\n\r\n```js\r\nvar mySymbol1 = Symbol()\r\nvar mySymbol2 = Symbol()\r\nvar mySymbol3 = Symbol()\r\nvar a = {}\r\na[mySymbol1] = \'hello!\';\r\nvar b = {\r\n   [mySymbol2]:\'hello!\'\r\n}\r\nvar c = {};\r\nObject.defineProperty(c, mySymbol3, { value: \'hello!\'});\r\nconsole.log(a[mySymbol1]);                 //hello！\r\nconsole.log(b[mySymbol2]);                 //hello！\r\nconsole.log(c[mySymbol3]);                 //hello！\r\n\r\n\r\nvar mySymbol = Symbol();\r\nvar a = {};\r\na.mySymbol = \'Hello!\';\r\na[mySymbol]                              // undefined\r\na[\'mySymbol\']                            // \"Hello!\"\r\n```\r\n\r\n### Symbol最为属性名遍历\r\n1. 使用Symbol作为属性名时，该属性将不会被 for...in 遍历,不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。\r\n2. 使用 Symbol 作为属性名时，该属性可以通过 Object.getOwnPropertySymbols() 方法获取。\r\n3. 使用 Symbol 作为属性名时，该属性不是私有属性。\r\n\r\n## Symbol的方法\r\n### Symbol.for()\r\n>有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。               \r\nSymbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。\r\n\r\n```js\r\nvar foo = Symbol(\'foo\');\r\nvar s1 = Symbol.for(\'foo\');\r\nvar s2 = Symbol.for(\'foo\');\r\n\r\nconsole.log(foo);                      //Symbol(foo)\r\nconsole.log(typeof foo);               //symbol\r\nconsole.log(s1);                        //Symbol(foo)\r\nconsole.log(typeof s1);              //symbol\r\nconsole.log(s2);                     //Symbol(foo)\r\nconsole.log(typeof s2);             //symbol\r\nconsole.log(foo === s1);            // false\r\nconsole.log(s1 === s2);             //true\r\n```\r\n\r\n\r\n\r\n### Symbol.keyFor()\r\n>Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。\r\n```js\r\nvar s1 = Symbol.for(\"foo\");\r\nSymbol.keyFor(s1)     // \"foo\"\r\n\r\nvar s2 = Symbol(\"foo\");\r\nSymbol.keyFor(s2)     // undefined\r\n```\r\n\r\n## Symbol的应用场景\r\n1. 在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。\r\n2. 解决属性名的冲突,因为传入对象属性时,同样的Symbol不相等;    \r\n解释:什么是冲突呢？当多人合作编码的时候，经常会出现你往对象上加了一个某某属性（比如 $ ），他人正好也想到了这个名称，当你们同时用了这个名称作为属性，代码之间就会发生冲突，互相覆盖。而用 symbol，即使都用了相同的描述，也不是同一个 symbol。\r\n3. Symbol值不能与其他类型的值进行运算，会报错。    \r\n","timestamp":1585877701769},{"name":"09-javascript Set数据结构.md","path":"001-前端/08-JavaScript/001-ECMA/09-javascript Set数据结构.md","content":"# Set && WeakSet\r\n\r\n\r\n## set兼容性\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=es5\" frameborder=\"0\"></iframe>\r\n\r\n## set 基本用法\r\n* 该数据结构，类似于数组，但是，它的成员都是唯一的。\r\n  ```javascript\r\n  var s = new Set();\r\n  [2, 3, 3, 5, 4, 5].map(x => {\r\n    s.add(x);\r\n    console.log(s);\r\n  });\r\n  // Set {2}\r\n  // Set {2, 3}\r\n  // Set {2, 3}\r\n  // Set {2, 3, 5}\r\n  // Set {2, 3, 5, 4}\r\n  // Set {2, 3, 5, 4}\r\n  ```\r\n\r\n* 在Set()函数中可以传入一个数组类型的参数。\r\n  ```javascript\r\n  var set = new Set([3,5,1,1,4]);\r\n  console.log([...set]);    // [3,5,1,4]\r\n  console.log(set.size);    // 4\r\n  ```\r\n\r\n* 在set中，判断是否重复，使用的是\"Same-value equality\",类似于\"===\",但是有例外，其中NaN不等于NaN。\r\n  ```javascript\r\n  var set = new Set();\r\n  set.add(NaN);\r\n  set.add(NaN);\r\n  set.add(\"1\");\r\n  set.add(1);\r\n  console.log(set) // Set {NaN, \"1\", 1}\r\n  ```\r\n\r\n## Set 实例的属性和方法\r\n\r\n### 属性\r\n* Set.prototype.constructor：构造函数，默认是 Set 函数。\r\n* Set.prototype.size：返回 Set 实例的成员总数。\r\n\r\n### 方法\r\n* 操作方法\r\n  * add(value)：添加某个值，返回Set结构本身。\r\n  * delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\r\n  * has(value)：返回一个布尔值，表示该值是否为Set的成员。\r\n  * clear()：清除所有成员，没有返回值。\r\n\r\n  ```javascript\r\n  var set = new Set();\r\n  set.add(1).add(2).add(2);\r\n\r\n  console.log(set.size) // 2\r\n\r\n  console.log(set.has(1)) // true\r\n  console.log(set.has(2)) // true\r\n  console.log(set.has(3)) // false\r\n  console.log(set.delete(2)); // true\r\n  console.log(set.delete(3)); // false\r\n  console.log(set) // set {1}\r\n  set.clear()\r\n  console.log(set) // set {}\r\n  ```\r\n\r\n* 遍历方法 (Set 的遍历顺序就是插入顺序)\r\n  * keys()：返回键名的遍历器\r\n  * values()：返回键值的遍历器\r\n    >由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法完全一致。\r\n\r\n  * entries()：返回键值对的遍历器\r\n  * forEach()：使用回调函数遍历每个成员\r\n\r\n  ```javascript\r\n  var set = new Set([1, 2, 3]);\r\n\r\n  console.log(set.keys());   // SetIterator {1, 2, 3}\r\n  console.log(set.values());   // SetIterator {1, 2, 3}\r\n  console.log(set.entries());   // SetIterator {[1,1],[2,2],[3,3]}\r\n  set.forEach((value, key) => console.log(value) )   // 1 2 3\r\n  ```\r\n\r\n## WeakSet\r\n* WeakSet的成员只能是对象，而不能是其他类型的值。\r\n* WeakSet中的对象都是弱引用，垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。\r\n","timestamp":1585877701769},{"name":"10-javascript Map数据结构.md","path":"001-前端/08-JavaScript/001-ECMA/10-javascript Map数据结构.md","content":"# Map && WeakMap\r\n\r\n## Map\r\n### 概述\r\n>javascript对象，本质上是键值对的集合。之前，只能用字符串当做键。<br/>\r\n>Map数据结构类似于对象，也是键值对的集合，但是\"键\"的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br/>\r\n>Object结构提供了\"字符串—值\"的对应，Map结构提供了\"值—值\"的对应，是一种更完善的Hash结构实现。<br/>\r\n>所以需要\"键值对\"的数据结构时，Map比Object更合适。<br/>\r\n\r\n### 兼容\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=es5\" frameborder=\"0\"></iframe> \r\n\r\n### 基本用法\r\n\r\n  * Map 作为一个构造函数，可以接受一个数组当做参数。\r\n  * Map 结构中，字符串\"true\" 和 布尔值true 是两个不同的键值。\r\n\r\n  ```javascript\r\n  var map = new Map([\r\n    [true, \'one\'],\r\n    [\'true\', \'two\']\r\n  ]);\r\n\r\n  console.log(map.get(true)) // \'one\'\r\n  console.log(map.get(\'true\')) // \'two\'\r\n  ```\r\n\r\n  * 只有对同一个对象的引用，Map结构才将其视为同一个键。所以下例中 set 和 get 中的 [1] 不是同一个键。\r\n  * 虽然NaN不严格相等于自身，但Map将其视为同一个键。\r\n\r\n  ```javascript\r\n  var map = new Map();\r\n\r\n  map.set([1], 111);\r\n  map.set(NaN, 222);\r\n  console.log(map.get([1]));  // undefined\r\n  console.log(map.get(NaN));  // 222\r\n  ```\r\n\r\n### Map 属性\r\n* size 返回 Map结构的成员个数。\r\n  ```javascript\r\n  var map = new Map([\r\n    [true, \'one\'],\r\n    [\'true\', \'two\']\r\n  ]);\r\n\r\n  map.set([1], 111);\r\n  console.log(map.size);  // 3\r\n  ```\r\n\r\n### Map 操作方法\r\n* set() 方法返回的是Map本身，因此也可以采用链式写法。\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\');\r\n  map.set(3, \'c\')\r\n  console.log(map) // Map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\r\n  ```\r\n\r\n* get() 方法读取对应的键值，如果找不到传入的键值，返回undefined。\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\')\r\n    .set(3, \'c\');\r\n\r\n  console.log( map.get(1) )   //\'a\'\r\n  console.log( map.get(2) )   //\'b\'\r\n  console.log( map.get(3) )   //\'c\'\r\n  ```\r\n\r\n* has() 方法返回一个布尔值，表示该键值是否在 Map 结构中。\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\')\r\n    .set(3, \'c\');\r\n\r\n  console.log( map.has(2) )   //  true\r\n  console.log( map.has(4) )   //  false\r\n  ```\r\n\r\n* delete() 方法删除某个键，返回true。如果删除失败，返回false。\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\')\r\n    .set(3, \'c\');\r\n\r\n  console.log( map.has(2) );     //  true\r\n  console.log( map.delete(2) );    // true\r\n  console.log( map.has(2) );    // false\r\n  console.log( map.delete(4) );   // false\r\n  ```\r\n\r\n* clear() 方法清除所有成员，没有返回值。\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\')\r\n    .set(3, \'c\');\r\n\r\n  console.log( map ); // Map {1 => \"a\", 2 => \"b\", 3 => \"c\"}\r\n  ```\r\n  ```javascript\r\n  var  map = new Map()\r\n    .set(1, \'a\')\r\n    .set(2, \'b\')\r\n    .set(3, \'c\');\r\n\r\n  console.log( map.clear() );  // undefined\r\n  console.log( map );         // Map {}\r\n  ```\r\n\r\n### Map 遍历方法\r\n  * keys()：返回键名的遍历器。\r\n  * values()：返回键值的遍历器。\r\n  * entries()：返回所有成员的遍历器。\r\n  ```javascript\r\n  var map = new Map([\r\n    [\'name\', \'bob\'],\r\n    [\'age\',  18],\r\n  ]);\r\n\r\n  for (let key of map.keys()) {\r\n    console.log(key);\r\n    // name\r\n    // age\r\n  }\r\n\r\n  for (let value of map.values()) {\r\n    console.log(value);\r\n    // bob\r\n    // 18\r\n  }\r\n\r\n  for (let kv of map.entries()) {\r\n    console.log(kv[0], kv[1]);\r\n    // name bob\r\n    // age 18\r\n  }\r\n\r\n  for (let [key, value] of map.entries()) {\r\n    console.log(key, value);\r\n    // name bob\r\n    // age 18\r\n  }\r\n\r\n  for (let [key, value] of map) {\r\n    console.log(key, value);\r\n    // name bob\r\n    // age 18\r\n  }\r\n  ```\r\n\r\n### Map && 数组\r\n* Map 转为 数组\r\n  ```javascript\r\n  var myMap = new Map().set(false, 0).set({aa: 1}, [2,3]);\r\n  var arr = [...myMap];\r\n  console.log( arr)\r\n  // [ [ false, 0 ], [ { aa: 1 }, [ 2, 3 ] ] ]\r\n  ```\r\n\r\n* 数组 转为 Map\r\n  ```javascript\r\n  var yMap = new Map([ [ false, 0 ], [ { aa: 1 }, [ 2, 3 ] ] ]);\r\n  console.log(yMap);\r\n  // Map {false => 0, Object {aa: 1} => [2, 3]}\r\n  ```\r\n\r\n### Map && 对象\r\n* Map 转为 对象\r\n  >如果所有Map的键都是字符串，它可以转为对象。\r\n\r\n  ```javascript\r\n  function strMapToObj(strMap) {\r\n    let obj = Object.create(null);\r\n    for (let [k,v] of strMap) {\r\n      obj[k] = v;\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  var myMap = new Map().set(\'yes\', true).set(\'no\', false);\r\n  strMapToObj(myMap)\r\n  // { yes: true, no: false }\r\n  ```\r\n\r\n* 对象 转为 Map\r\n\r\n  ```javascript\r\n  function objToStrMap(obj) {\r\n    let strMap = new Map();\r\n    for (let k of Object.keys(obj)) {\r\n      strMap.set(k, obj[k]);\r\n    }\r\n    return strMap;\r\n  }\r\n\r\n  objToStrMap({yes: true, no: false})\r\n  ```\r\n\r\n## WeakMap\r\n* WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名。\r\n* 键名所指向的对象，不计入垃圾回收机制。\r\n  ```javascript\r\n  var map = new WeakMap()\r\n  map.set(1, 2);        // Uncaught TypeError: Invalid value used as weak map key\r\n  map.set(Symbol(), 2); // Uncaught TypeError: Invalid value used as weak map key\r\n  ```\r\n","timestamp":1585877701769},{"name":"11-ES6 - ES9新特性总结.md","path":"001-前端/08-JavaScript/001-ECMA/11-ES6 - ES9新特性总结.md","content":"> JavaScript（ECMAScript）是跨多个平台的许多厂商实施的不断发展的标准。ES6（ECMAScript 2015）花费六年的时间敲定，是一个很大的发行版。新的年度发布流程被制定，以简化流程并更快地添加功能。 ES9（ES2018）是撰写本文时的最新版本。\r\n\r\n## ES6 新特性\r\n> 2015.06\r\n\r\n**数据**\r\n\r\n|||\r\n|---|---|\r\n|let const声明 |  块级作用域`{}` |\r\n|`Symbol`数据类型 | `Map` `Set`数据类型 |\r\n\r\n**字符串扩展**\r\n\r\n|||\r\n|---|---|\r\n| 模板字符串 | 字符串的`for...of`遍历 |\r\n|`includes()`判断一个字符串是否包含在另一个字符串中 | `startsWith()`判断一个字符串是否包含在另一个字符串开头|\r\n|`endsWith()`判断一个字符串是否包含在另一个字符串末尾 | `repeat()` 将字符串重复n次 |\r\n|`matchAll()`||\r\n\r\n**数值扩展**\r\n\r\n|||\r\n|---|---|\r\n| 二进制数值前缀0b（或0B）和八进制数值前缀0o（或0O） | |\r\n|`Number.isFinite()`判断一个值是否是有限`Infinity` | `Number.isNaN()`判断一个值是否是`NaN`|\r\n|`Number.isInteger()`判断一个值是否是整数 | `Number.isNaN()`判断一个值是否是`NaN`|\r\n|`Math.trunc()`删除一个数的小数部分 | `Math.sign()`判断一个数到底是正数、负数、还是零|\r\n\r\n**函数扩展**\r\n\r\n|||\r\n|---|---|\r\n| 函数参数默认值`function(a=0,b=0){}` | `...`rest参数接收函数参数 |\r\n| 函数的`name`属性，获得该函数的函数名 | 箭头函数|\r\n\r\n**数组扩展**\r\n\r\n|||\r\n|---|---|\r\n| 扩展运算符`...` | `Array.from() `将符合格式的对象转化为数组 |\r\n| `Array.of() `将一组值，转换为数组 | ``将符合格式的对象转化为数组 |\r\n| `find() `找出第一个符合条件的数组成员 | `findIndex() `找出第一个符合条件的数组成员的下标 |\r\n| `copyWithin() `指定位置的成员复制到其他位置 | `flat() `将多维数组变成一维的数组 |\r\n| 数组的遍历：`entries()`键值对 `keys()`键 `values()`值 | `fill() `使用给定值，填充一个数组 |\r\n\r\n**对象扩展**\r\n\r\n|||\r\n|---|---|\r\n| 属性方法的简写 | 方法的`name`属性 |\r\n| 属性名表达式，用字面量定义对象属性方法名 | 对象的解构赋值 |\r\n| 类 `class`与类的继承`extends` | `Object.is()`比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 |\r\n| `Object.assign()`对象的合并 | `Object.is()`比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 |\r\n| `Object.keys()` `Object.values()` `Object.entries() `遍历对象的键、值、键值对 | `for...of`对象遍历 |\r\n| `Iterator`遍历器 |  |\r\n\r\n\r\n**其他**\r\n\r\n|||\r\n|---|---|\r\n| `Promise`对象，用于异步编程 | `Generator`函数 |\r\n| module ES6模块化 |  |\r\n\r\n## ES2016 (ES7) 新特性\r\n> 2016.06\r\n\r\n**运算符扩展**\r\n\r\n|||\r\n|---|---|\r\n| 指数运算符`**`  | |\r\n\r\n\r\n**数组扩展**\r\n\r\n|||\r\n|---|---|\r\n| `includes()`检查数组是否包含某元素  | |\r\n\r\n\r\n\r\n## ES2017 (ES8) 新特性\r\n> 2017.06\r\n\r\n**字符串扩展**\r\n\r\n|||\r\n|---|---|\r\n|`padStart()`用某字符串在目标字符串**开头**补全到指定长度 | `padEnd()`用某字符串在目标字符串**末尾**补全到指定长度|\r\n\r\n**对象扩展**\r\n\r\n|||\r\n|---|---|\r\n|`Object.values()`对象的遍历，得到对象的可遍历的属性值组成的数组|`Object.entries()`对象的遍历，得到对象的可遍历的属性名与属性值组成的数组|\r\n|`Object.getOwnPropertyDescriptors()`返回指定对象所有自身属性（非继承属性）的描述对象||\r\n\r\n**函数扩展**\r\n\r\n||\r\n|---|\r\n|函数实参和形参中的尾随逗号|\r\n\r\n**异步编程**\r\n\r\n||\r\n|---|\r\n| `async` `await` 异步函数 |\r\n\r\n\r\n## ES2018 (ES9) 新特性\r\nES2018 是 ECMAScript 标准的最新版本，\r\n\r\n\r\n**对象扩展**\r\n\r\n|||\r\n|---|---|\r\n|对象的`Rest`扩展运算符| `Promise.prototype.finally()`Promise方法 |\r\n","timestamp":1585877701769},{"name":"98-错误与异常.md","path":"001-前端/08-JavaScript/001-ECMA/98-错误与异常.md","content":"# JavaScript错误与异常\r\n错误，指程序中的非正常运行状态，在其他编程语言中称为‘异常’或，‘错误’。解释器为每个错误情形创建并抛出一个`error对象`，其中包含错误的描述信息。     \r\n\r\n通过使用JavaScript提供的异常处理语句，可以用结构优化的方式捕捉发生的错误，让异常处理代码核心业务代码实现分离。\r\n\r\n## Error对象\r\nECMAScript预定义了六种类型的错误。执行代码期间可能会发生的错误类型有多种种类，每种种类都有对应的错误类型。当错误发生时，就会抛出对应类型的错误对象。  \r\n\r\n### 预定义错误类型\r\n| 错误类型 | 说明 |\r\n| ---- | ---- |\r\n| ReferenceError | 表示错误的原因：无效引用，所使用的数据未定义 |\r\n| RangeError | 表示错误的原因：数值变量或参数超出其有效范围 |\r\n| TypeError | 表示错误的原因：变量或参数部属于有效类型 |\r\n| InternalError | 表示javascript引擎内部错误的异常 |\r\n| EvalError | 表示错误的原因：与eval()有关 |\r\n| SyntaxError | 表示错误的原因：eval()在解析代码的过程发生的语法错误 |\r\n| URLError | 表示错误的原因：给encodeURL()或decodeURL()传递的参数无效 |\r\n\r\n![错误类型](assets/001/98-1545370533000.png)\r\n\r\n###  自定义错误类型\r\n除了浏览器预定义的六种错误类型，开发人员可自定义错误并进行处理(处理方法见下)：\r\n```js\r\nnew Error(\"提示信息\")\r\n```\r\n![自定义错误](assets/001/98-1545371172000.png)\r\n\r\n\r\n## 错误处理\r\n出错行以下的所有JS代码将中停执行，这是我们不希望看到的，果我们能获取 这些Error，然后弹出一些友好界面会有更好的体验。 所以说，对于拿不准的代码段、容易报错或产生兼容问题的代码段/语句块加上错误处理。       \r\n\r\n* 解决浏览器兼容性问题\r\n* 引用外部函数库，不确定函数库返回的结果正确与否。\r\n\r\n### try...catch语句\r\n\r\ntry...catch 语句作为js中处理异常的一种标准方式。try语句标记一块待尝试的语句，如果该语句出现错误，则通过catch语句进行捕捉。\r\n\r\n* **`try`** 语句允许我们定义在执行时进行错误测试的代码块。\r\n* **`catch`** 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。\r\n    * `catch`语句中可接收到错误对象，对象上有两个常用属性\r\n        * name：错误类型\r\n        * message：错误信息\r\n* **`finally`** 语句指不管try误与异常，都会执行的代码块。\r\n    * 在 finally 中我们可以放置我们必须要执行的代码。\r\n    * finally可以省略\r\nJavaScript 语句 `try` 和 `catch` 是成对出现的。\r\n\r\n```js\r\ntry {\r\n    console.log(v);//- 调用未定义的变量，语法报错\r\n}\r\n//用于处理try中出现的错误\r\ncatch (error){\r\n    //error - 表示try中出现错误的信息对象\r\n    console.log(error.name);\r\n    console.log(error.message);\r\n}\r\n//终结快 - 无论catch语句是否处理了try语句中的错误与异常，都会输出finally语句中的内容\r\nfinally {\r\n\r\n}\r\n```\r\n#### 注意事项\r\n1. `try...catch`只能捕获在其中执行的同步代码所抛出的异常，异步异常无法捕获\r\n2. `try...catch`会降低能，所以只将可能出错的代码片段放入`try...catch`\r\n\r\n\r\n### throw 抛出语句\r\n与`try...catch`语句配合使用的还有`throw`操作符，用于随时抛出定义错误。抛出错误是，必须给throw操作符制定一个值。（值不限类型）\r\n```js\r\nfunction fn(v) {\r\n    if (v){\r\n        return v;\r\n    }else {\r\n        throw {name : \'错误\'};\r\n    }\r\n}\r\n\r\nvar result;\r\ntry{\r\n    result=fn();\r\n}catch (e){\r\n    result = \'aa\'\r\n    console.log(e.name);//错误\r\n}\r\nconsole.log(result);//aa\r\n```\r\n\r\n`throw`常常会和 `Error对象`结合使用，用以抛出一个错误：\r\n```js\r\nthrow new Error(\"参数类型错误\");\r\n```\r\n\r\n\r\n- https://segmentfault.com/a/1190000016115486\r\n\r\n\r\n## 错误处理使用场景：\r\n\r\n### 同步场景中的错误\r\n1. 获取DOM元素进行DOM操作，如果未获取到元素需要进行错误判断\r\n```js\r\ndocument.querySelector(\".box\").onclick = function(){\r\n    // do something\r\n}\r\n// 如果未获取到元素则js代码会报错停止执行\r\n```\r\n错误处理\r\n```js\r\ntry {\r\n    document.querySelector(\".box\").onclick = function () {\r\n        // do something\r\n    }\r\n} catch (error) {\r\n    console.log(\"未获取到元素\")\r\n}\r\n```\r\n2. 兼容性错误\r\n```js\r\ntry {\r\n    div.addEventListener(doSomething)\r\n} catch (error) {\r\n    div.attachEvent(doSomething)\r\n}\r\n```\r\n\r\n\r\n### 异步函数中的错误\r\n由于`try...catch`只能捕获同步代码,所以在异步函数外部使用`try...catch`是错误的：\r\n```js\r\ntry {\r\n\tajax({})\r\n} catch (e) {\r\n    // 无法捕获到异步函数的错误\r\n}\r\n```\r\n\r\n所以，回调函数的的错误处理只能在回调函数的内部处理.例如\r\n```js\r\najax({\r\n    success(){\r\n        try{\r\n\r\n        }catch(e){\r\n\r\n        }\r\n    }\r\n})\r\n```\r\n\r\n或者使用`Promise`语法中的`catch`来捕获异步函数的错误：\r\n```js\r\nfetch(url, options)\r\n.then(res=>{\r\n    return res.json()\r\n}\r\n.catch(error){\r\n    // 利用Promise语法在catch中捕获错误\r\n}\r\n```\r\n\r\n\r\n\r\n","timestamp":1585877701769},{"name":"99-其他.md","path":"001-前端/08-JavaScript/001-ECMA/99-其他.md","content":"# 其他知识\r\n\r\n\r\n\r\n\r\n\r\n## 深拷贝(参考对象案例第五题)\r\n\r\n方案1：\r\n```javascript\r\nvar obj = {\r\n    id:1000,\r\n    name:\"张三\",\r\n    age:19,\r\n    favs:[\'足球\',\'电影\',\'游戏\',\'篮球\']\r\n}\r\nvar obj2 = JSON.parse(JSON.stringify(obj));\r\n```\r\n\r\n\r\n方案2:\r\n```js\r\n/**\r\n * [deepCopy 深拷贝]\r\n * @param  {[Array|Object]}   [要拷贝对象或数组]\r\n * @return {[Array|Object]}   [返回拷贝对象或数组]\r\n */\r\nfunction deepCopy(o){\r\n\tif(Array.isArray(o)){\r\n\t\tvar result = [];\r\n\t}else if(typeof o == \'object\'){\r\n\t\tvar result = {};\r\n\t}else{\r\n\t\treturn o;\r\n\t}\r\n\tfor(var i in o){\r\n\t\tif(typeof o[i]== \'object\'){\r\n\t\t\tresult[i] = deepCopy(o[i])\r\n\t\t}else{\r\n\t\t\tresult[i] = o[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n```\r\n>在拷贝日期正则等特殊对象是拷贝为空对象。如有需求加判断就可以解决。\r\n","timestamp":1585877701769},{"name":"01-window对象.md","path":"001-前端/08-JavaScript/002-BOM/01-window对象.md","content":"# BOM\r\n> BOM(Browser Object Model) 浏览器对象模型\r\n\r\n> ECMAScript提供核心语言功能，例如变量分支循环等功能\r\n> 而BOM提供与浏览器交互的方法和接口，使用BOM可以访问和操作浏览器窗口，可以控制浏览器显示的页面以外的部分\r\n\r\nBOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window；\r\n\r\n\r\n## window对象\r\n\r\n### window对象属性\r\n\r\n 属性| 描述| 可读写性 | 兼容性\r\n---|---|---|---\r\ninnerWidth | 浏览器窗口宽度 | 只读 | >ie8\r\ninnerHeight | 浏览器窗口高度 | 只读 | >ie8\r\nscreen.width | 屏幕宽度(分辨率) | 只读 | 全部\r\nscreen.height | 屏幕高度(分辨率) | 只读 | 全部\r\ntop | 返回窗口体系中的最顶层窗口的引用 | 只读 | 全部\r\n\r\n> `window.top` :返回最顶层的窗口对象，当在处理子框架时(iframes)，而想获取顶层框架时，这时可使用`window.top`\r\n\r\n\r\n> 兼容获取滚动条距离\r\n\r\n```js\r\nvar x = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\r\n\r\nvar y = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\r\n```\r\n\r\n\r\n\r\n### window对象方法\r\n\r\n  属性 | 参数 | 返回值 | 功能 | 兼容性\r\n---|---|---|---|---\r\nalert | string | undefined | 弹出带有一段消息和一个确认按钮的警告框 | 全部\r\nconfirm | string | boolean | 弹出带有一段消息以及确认按钮和取消按钮的对话框 | 全部\r\nprompt | string | undefined | 弹出可提示用户输入的对话框 | 全部\r\nopen | url | 新窗口的window对象引用 | 通过脚本打开新的窗口 |全部\r\nclose | 无 | undefined | 关闭当前浏览器窗口 |全部\r\nscrollBy | xpos,ypos | undefined | 在窗口中按指定的偏移量滚动文档 | 全部\r\nscrollTo | xpos,ypos | undefined | 在窗口中将文档滚动到指定位置 | 全部\r\n\r\n使用 `window.close()` 方法关闭使用 `window.open()` 打开的窗口\r\n```js\r\n//全局变量,存储将要打开的窗口的对象引用.\r\nvar openedWindow;\r\n\r\nfunction openWindow()\r\n{\r\n  openedWindow = window.open(\'https://www.baidu.com\');\r\n}\r\nfunction closeOpenedWindow()\r\n{\r\n  openedWindow.close();\r\n}\r\n```\r\n\r\n  属性 | 参数 | 返回值 | 功能 | 兼容性\r\n---|---|---|---|---\r\nsetInterval | `callback,time(ms)[,param]` | 该时间函数的id值，可用于取消执行 | 按照指定时间间隔执行回调函数 | 全部(IE9及一下版本不支持该第三个参数)\r\nclearInterval | name | undefined | 清除指定时间函数进程 | 全部\r\nsetTimeout | `callback,time(ms)[,param]` | 该时间函数的id值，可用于取消执行 | 在指定的时间后执行回调函数 | 全部\r\nclearTimeout | name | undefined | 清除指定的延时函数进程 | 全部\r\n\r\n`setInterval` 与 `clearTimeout`参数分别是\r\n1. callback： 必填。 函数，代表指定时间后执行该段代码\r\n2. time： 必填。 时间间隔，以毫秒计，不写单位\r\n3. param： 可选。传给执行函数的其他参数，多个参数以`,`隔开(IE9 及其更早版本不支持该参数)\r\n\r\ncallback回调函数可直接写到 `setInterval` 和 `setTimeout` 参数中，也可只写一个函数名:\r\n```js\r\nsetInterval(run,1000)\r\nfunction run(){\r\n    console.log(1)\r\n}\r\n\r\n// 上下相同\r\n\r\nsetInterval(function run(){\r\n    console.log(1)\r\n},1000)\r\n```\r\n\r\n案例： 输出1-10，每秒输出一次\r\n```js\r\nvar i = 1;\r\nvar t = setInterval(function(){\r\n    console.log(i)\r\n    i++\r\n    if(i>10){\r\n        clearInterval(t)\r\n    }\r\n},1000)\r\n\r\n```\r\n\r\n### 特殊\r\n* ES5中，顶层对象的属性与全局变量是等价的（相当于声明全局变量、全局函数其实就是将该变量、该函数赋值给了window）。\r\n    ```js\r\n    window.a = 1;\r\n    console.log(a) // 1\r\n    a = 2;\r\n    console.log(window.a) // 2\r\n    ```\r\n    上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\r\n\r\n* ES6中，全局变量将逐步与顶层对象的属性脱钩。\r\n    ```js\r\n    var a = 1;\r\n    console.log(window.a) // 1\r\n    let b = 1;\r\n    console.log(window.b) // undefined\r\n    ```\r\n    上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。\r\n","timestamp":1585877701769},{"name":"02-console对象.md","path":"001-前端/08-JavaScript/002-BOM/02-console对象.md","content":"\r\n# console对象\r\n`Console` 对象是 `windows`子对象，提供了对浏览器控制台的接入，可以在任何全局对象中访问，被浏览器定义为 `Window.console`，也可被简单的 `console` 调用。\r\n\r\n\r\n## console对象方法\r\n\r\n| 属性 | 参数 | 返回值 | 功能 | 兼容性|\r\n---|---|---|---|---\r\nlog | msg | undefined | 向 Web 控制台输出一条消息 | 全部\r\ndir | object | undefined | 打印出对象的所有属性和属性值 | >ie8\r\nerror | msg | undefined | 向 Web 控制台输出一条错误消息 | >ie7\r\nwarn | msg | undefined | 向 Web 控制台输出一条警告信息 | >ie7\r\ntime | timerName | undefined | 启动一个计时器（timer）来跟踪某一个操作的占用时长 | >ie10\r\ntimeEnd | timerName | undefined | 停止一个通过 `console.time()` 启动的计时器 | >ie10\r\n\r\n\r\n### 利用`console.time()` 进行js运行速度测试\r\n`consoel.time()`和`console.timeEnd()`这两个方法可以用来让WEB开发人员测量一个javascript脚本程序执行消耗的时间。\r\n\r\n`console.time`方法是开始计算时间，`console.timeEnd`是停止计时，输出脚本执行的时间:\r\n```js\r\n// 启动计时器\r\nconsole.time(\'testForEach\');\r\n// (测试用代码)\r\n// 停止计时，输出时间\r\nconsole.timeEnd(\'testForEach\');\r\n\r\n// testForEach 4522.303ms\r\n```\r\n\r\n#### 参数\r\n这两个方法中都可以传入一个参数，作为计时器的名称，它的作用是在代码并行运行时分清楚各个计时器。所以**两个方法的参数必须相同**。\r\n\r\n对`console.timeEnd`的调用会立即输出执行总共消耗的时间，单位是毫秒\r\n\r\n测试ajax请求所需时间：\r\n```js\r\nconsole.time(\"ajax请求时间\")\r\n$.ajax({\r\n  url:\"https://zhihu-daily.leanapp.cn/api/v1/last-stories\",\r\n  success(res){\r\n    console.timeEnd(\"ajax请求时间\")\r\n  }\r\n})\r\n//  ajax请求时间: 189.089111328125ms\r\n```\r\n\r\n\r\n\r\n\r\n","timestamp":1585877701769},{"name":"03-location对象.md","path":"001-前端/08-JavaScript/002-BOM/03-location对象.md","content":"\r\n## location 对象\r\n> `location` 对象是 `windows`子对象，其中包含当前窗口中加载的文档有关的信息。\r\n> `location`对象的用处不只表现在它保存着当前文档的信息，还表现在它将`url`解析为独立的片段，可以通过不同的属性访问这些片段:\r\n\r\n\r\n### location 对象属性\r\n> 一个完整的url 包括9个部分 协议://用户名：密码@域名：端口/路径；参数？查询#片段 不过几乎没有哪个url包含这些所有组件，最重要的三部分是协议，域名和路径:\r\n\r\n以该url为例：\r\n```\r\nhttp://www.baidu.com:80/javascript/?file=001/BOM/README.md/#location对象\r\n```\r\n\r\n属性|描述| 可读写性 | 结果\r\n---|---|---|---\r\nhref | 包含整个URL的一个字符串 | 读写 | `http://www.baidu.com:80/javascript/001/BOM/?file=README.md#location对象`\r\norigin | 包含页面来源的域名的标准形式字符串 | 只读 | `http://www.baidu.com:80`\r\nprotocol | 包含URL对应协议的字符串，最后有一个\":\" | 只读 | `http:`\r\nhost | 包含了域名和端口号的字符串，如没有端口号则只有域名 | 只读 | `www.baidu.com:80`\r\nhostname | 包含URL域名的字符串 | 只读 | `www.baidu.com`\r\nport | 包含端口号的字符串 | 只读 | `80`\r\npathname | 包含URL中路径部分的字符串，开头有一个\"/\" | 只读 | `/javascript/001/BOM/`\r\nsearch | 包含URL参数（查询字符串）的字符串，开头有一个“?” | 只读 | `?file=README.md`\r\nhash | 包含块标识符的字符串，开头有一个\"#\" | 只读 | `#location对象`\r\n\r\n\r\n### location 对象方法\r\n\r\n 属性 | 参数 | 返回值 | 功能 | 兼容性\r\n---|---|---|---|---\r\nassign | url | undefined | 加载给定URL的内容资源 | 全部\r\nreload | Boolean | undefined | 重新加载来自当前 URL的资源(刷新本页) | 全部\r\nreplace | url | undefined | 用给定的URL替换掉当前的资源 | 全部\r\ntoString | 无 | 包含整个URL的字符串 | 获取本窗口的url(只能获取，无法修改，读取效果与`location.href`相同) | 全部\r\n\r\n> `location.assign` 与 `location.replace`的区别: `replace()`替换的新页面不会被保存在会话的历史 History中，这意味着用户将不能用后退按钮转到该页面\r\n\r\n`location.reload` 的参数：\r\n* false或未写参数：检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。\r\n* true：那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。\r\n","timestamp":1585877701769},{"name":"04-history对象.md","path":"001-前端/08-JavaScript/002-BOM/04-history对象.md","content":"\r\n## history 对象\r\n>  `history` 对象是 `windows`子对象。`history` 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录,这些方法和事件能够帮助我们优雅的实现单页面应用，同时又不会影响搜索引擎对我们网站的搜录。现在所有的现代浏览器都已经支持这些新的特性，并且涌现出大量的路由框架，都内置集成了这些新的特性。比方说著名的`vue`框架里面的 `vue-route`等路由框架。\r\n\r\n### history 对象属性\r\n属性|描述| 可读写性 | 兼容性\r\n---|---|---|---\r\nlength | 包含当前页面在内的历史记录个数 | 只读 | 全部\r\n\r\n### history 对象方法\r\n\r\n 属性 | 参数 | 返回值 | 功能 | 兼容性\r\n---|---|---|---|---\r\nback | 无 | undefined | 加载 history 列表中的前一个 URL(等价于history.go(-1)) | 全部\r\nforward | 无 | undefined | 加载 history 列表中的下一个 URL(等价于history.go(1)) | 全部\r\ngo | number | undefined | 通过当前页面的相对位置从浏览器历史记录加载页面 | 全部\r\npushState | state, title, url | undefined | 无刷新的向浏览器 历史最前方 加入一条记录  | >ie9\r\nreplaceState | state, title, url | undefined | 无刷新的使用一条记录替换当前的历史记录  | >ie9\r\n\r\n* history.go方法\r\n    * history.go(-1)： 加载上一个历史记录\r\n    * history.go(1)： 加载下一个历史记录\r\n    * history.go(0) 或不传参： 刷新本页\r\n    类似地，你可以传递参数值2并向前移动2个页面，等等。    \r\n    如果已经没有页面，该方法不会报错，页面不会发生任何变化； 如果参数不是整数，页面也不会发生任何变化。\r\n\r\n* `history.pushState` 和 `history.replaceState`  方法有3个参数\r\n     * **状态对象state** —— 需要保存的数据，这个数据在触发`popstate`事件时保存在`event.state`上\r\n     * **标题title** —— 浏览器目前不识别该参数，传入一个空字符串\r\n     * **地址URL** —— 需要更改的url地址\r\n\r\n> `window.onpopstate`事件： 浏览器点击前进后退(或者在js中调用`history.back()`、`history.forward()`、`history.go()`方法)时触发的事件。`event.state`可以获取当前`url`下设置的`state`。\r\n\r\n*注：`pushState` 和 `replaceState`方法只能加载同源下的资url源（存在跨域问题）*\r\n\r\n```js\r\nwindow.onpopstate = function (event) {\r\n    console.log(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));\r\n};\r\n//绑定事件处理函数.\r\nhistory.pushState({ page: 1 }, \"title 1\", \"?page=1\");    //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1\r\nhistory.pushState({ page: 2 }, \"title 2\", \"?page=2\");    //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2\r\nhistory.replaceState({ page: 3 }, \"title 3\", \"?page=3\"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3\r\nhistory.back(); // 输出 \"location: http://example.com/example.html?page=1, state: {\"page\":1}\"\r\nhistory.back(); // 输出 \"location: http://example.com/example.html, state: null\r\nhistory.go(2);  // 输出 \"location: http://example.com/example.html?page=3, state: {\"page\":3}\r\n```\r\n\r\n### 总结\r\n* js刷新本页面方法汇总：\r\n    1. history.go(0)\r\n    2. location.reload()\r\n* js跳转页面方法汇总：\r\n    1. window.open(url)\r\n    2. location.href = \"\"\r\n    3. location.assign(url)\r\n","timestamp":1585877701769},{"name":"05-Navigator对象.md","path":"001-前端/08-JavaScript/002-BOM/05-Navigator对象.md","content":"# Navigator 对象\r\nNavigator 对象包含有关浏览器的信息,是window对象的属性，中文是\"导航器\"的意思\r\n\r\n## Navigator的属性\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n|language |\t返回当前浏览器的语言| \"zh-CN\"、\"en\"等 |\r\n|cookieEnabled | 返回指明浏览器中是否启用 cookie 的布尔值 |\r\n|onLine\t| 返回指明系统是否处于联网状态的布尔值 |\r\n|platform\t| 返回运行浏览器的操作系统平台。|  \"Win32\", \"Linux i686\", \"MacPPC\", \"MacIntel\", 等 |\r\n|userAgent |\t返回由客户机发送服务器的 user-agent 头部的值 |\r\n|mediaDevices\t| 返回一个 MediaDevices 对象。|\r\n\r\n\r\n### MediaDevices\r\nmediaDevices 是 Navigator 只读属性，返回一个 MediaDevices 对象，通常，只需直接使用此对象的成员`navigator.mediaDevices.getUserMedia()`\r\n\r\n#### MediaDevices.getUserMedia()\r\n该对象可提供对相机和麦克风等媒体输入设备的连接访问，也包括屏幕共享。\r\n\r\n该方法提醒用户需要使用音频（0或者1）和（0或者1）视频输入设备，比如相机，屏幕共享，或者麦克风。     \r\n\r\n此方法传入三个参数(配置对象，成功处理函数，失败处理函数)                            \r\n\r\n它返回一个 Promise 对象，成功后会resolve回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise会reject回调一个  PermissionDeniedError 或者 NotFoundError 。\r\n\r\n>返回的promise对象可能既不会resolve也不会reject，因为用户不是必须选择允许或拒绝。    \r\n\r\n```js\r\nnavigator.mediaDevices.getUserMedia(constraints)\r\n.then(function(stream) {\r\n  /* 使用这个stream stream */\r\n})\r\n.catch(function(err) {\r\n  /* 处理error */\r\n});\r\n```\r\n\r\n##### 参数-配置对象\r\n包含了video 和 audio两个成员的MediaStreamConstraints 对象，用于说明请求的媒体类型。必须至少一个类型或者两个同时可以被指定。           \r\n\r\n```js\r\n{\r\n  audio: true,\r\n  video: { width: 1280, height: 720 }     //想要使用1280x720的摄像头分辨率\r\n}\r\n// 如果无法准确满足此请求中参数要求，有可能返回其它的分辨率。强制使用关键字min, max, 或者 exact(就是 min == max)\r\n```\r\n```js\r\n{\r\n  audio: true,\r\n  video: {\r\n    width: { min: 1024, ideal: 1280, max: 1920 },\r\n    height: { min: 776, ideal: 720, max: 1080 }\r\n  }\r\n}\r\n//当请求包含一个ideal（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定的理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。\r\n```\r\n```js\r\n//移动设备\r\n{ audio: true, video: { facingMode: \"user\" } }     //优先使用前置摄像头\r\n{ audio: true, video: { facingMode: { exact: \"environment\" } } }  //强制使用后置摄像头\r\n```\r\n\r\n##### 返回值\r\n返回一个 Promise ， 这个Promise成功后的回调函数带一个 MediaStream 对象作为其参数。  \r\n\r\n\r\n##### 在旧的浏览器中使用新的API\r\n```js\r\n// 老的浏览器可能根本没有实现 mediaDevices，所以我们可以先设置一个空的对象\r\nif (navigator.mediaDevices === undefined) {\r\n  navigator.mediaDevices = {};\r\n}\r\n\r\n// 一些浏览器部分支持 mediaDevices。我们不能直接给对象设置 getUserMedia\r\n// 因为这样可能会覆盖已有的属性。这里我们只会在没有getUserMedia属性的时候添加它。\r\nif (navigator.mediaDevices.getUserMedia === undefined) {\r\n  navigator.mediaDevices.getUserMedia = function(constraints) {\r\n\r\n    // 首先，如果有getUserMedia的话，就获得它\r\n    var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n\r\n    // 一些浏览器根本没实现它 - 那么就返回一个error到promise的reject来保持一个统一的接口\r\n    if (!getUserMedia) {\r\n      return Promise.reject(new Error(\'getUserMedia is not implemented in this browser\'));\r\n    }\r\n\r\n    // 否则，为老的navigator.getUserMedia方法包裹一个Promise\r\n    return new Promise(function(resolve, reject) {\r\n      getUserMedia.call(navigator, constraints, resolve, reject);\r\n    });\r\n  }\r\n}\r\n\r\nnavigator.mediaDevices.getUserMedia({ audio: true, video: true })\r\n.then(function(stream) {\r\n  var video = document.querySelector(\'video\');\r\n  // 旧的浏览器可能没有srcObject\r\n  if (\"srcObject\" in video) {\r\n    video.srcObject = stream;\r\n  } else {\r\n    // 防止再新的浏览器里使用它，应为它已经不再支持了\r\n    video.src = window.URL.createObjectURL(stream);\r\n  }\r\n  video.onloadedmetadata = function(e) {\r\n    video.play();\r\n  };\r\n})\r\n.catch(function(err) {\r\n  console.log(err.name + \": \" + err.message);\r\n});\r\n```\r\n\r\n##### 权限\r\n在一个可安装的app（如Firefox OS app）中使用 getUserMedia() ，你需要在声明文件中指定以下的权限：\r\n```js\r\n\"permissions\": {\r\n  \"audio-capture\": {\r\n    \"description\": \"Required to capture audio using getUserMedia()\"\r\n  },\r\n  \"video-capture\": {\r\n    \"description\": \"Required to capture video using getUserMedia()\"\r\n  }\r\n}\r\n```       \r\n\r\n\r\n\r\n## 案例\r\n检测浏览器版本：\r\n```js\r\n function getExplorerInfo() {\r\n    var explorer = window.navigator.userAgent.toLowerCase();\r\n    //ie\r\n    if (explorer.indexOf(\"msie\") >= 0) {\r\n        var ver = explorer.match(/msie ([\\d.]+)/)[1];\r\n        return { type: \"IE\", version: ver };\r\n    }\r\n    else if (explorer.indexOf(\"edge\") >= 0) {\r\n        var ver = explorer.match(/edge\\/([\\d.]+)/)[1];\r\n        return { type: \"Edge\", version: ver };\r\n    }\r\n    //firefox\r\n    else if (explorer.indexOf(\"firefox\") >= 0) {\r\n        var ver = explorer.match(/firefox\\/([\\d.]+)/)[1];\r\n        return { type: \"Firefox\", version: ver };\r\n    }\r\n    //Chrome\r\n    else if (explorer.indexOf(\"chrome\") >= 0) {\r\n        var ver = explorer.match(/chrome\\/([\\d.]+)/)[1];\r\n        return { type: \"Chrome\", version: ver };\r\n    }\r\n    //Opera\r\n    else if (explorer.indexOf(\"opera\") >= 0) {\r\n        var ver = explorer.match(/opera.([\\d.]+)/)[1];\r\n        return { type: \"Opera\", version: ver };\r\n    }\r\n    //Safari\r\n    else if (explorer.indexOf(\"Safari\") >= 0) {\r\n        var ver = explorer.match(/safari\\/([\\d.]+)/)[1];\r\n        return { type: \"Safari\", version: ver };\r\n    }\r\n}\r\n```\r\n\r\nh5相机拍照\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head lang=\"en\">\r\n        <meta charset=\"UTF-8\">\r\n        <title></title>\r\n        <script type=\"text/javascript\" src=\"jquery.min.js\"></script>\r\n        <script>\r\n            window.addEventListener(\"DOMContentLoaded\", function () {\r\n                var canvas = document.getElementById(\"canvas\"),\r\n                    context = canvas.getContext(\"2d\"),\r\n                    video = document.getElementById(\"video\"),\r\n                    videoObj = {\r\n                        \"video\": true\r\n                    },\r\n                    errBack = function (error) {\r\n                        console.log(\"Video capture error: \", error.code);\r\n                    };\r\n                $(\"#snap\").click(function () {\r\n                    context.drawImage(video, 0, 0, 330, 250);\r\n                })\r\n                if (navigator.mediaDevices.getUserMedia) {\r\n                    navigator.mediaDevices.getUserMedia(videoObj)\r\n                    .then(function (stream) {\r\n                        video.srcObject = stream;\r\n                        video.play();\r\n                    })\r\n                    .catch(errBack)\r\n                } else if (navigator.webkitGetUserMedia) {\r\n                    navigator.webkitGetUserMedia(videoObj, function (stream) {\r\n                        video.src = window.webkitURL.createObjectURL(stream);\r\n                        video.play();\r\n                    }, errBack);\r\n                }\r\n            }, false);\r\n        </script>\r\n    </head>    \r\n    <body>\r\n        <div id=\"contentHolder\">\r\n            <video id=\"video\" width=\"320\" height=\"320\" autoplay></video>\r\n            <input type=\"button\" id=\"snap\" style=\"width:100px;height:35px;\" value=\"拍 照\" />\r\n            <canvas style=\"\" id=\"canvas\" width=\"320\" height=\"320\"></canvas>\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\n\r\n\r\n## Vibration（震动）\r\n```js\r\n// 可以传入一个大于0的数字，表示让手机震动相应的时间长度，单位为ms\r\nnavigator.vibrate(100)\r\n\r\n// 也可以传入一个包含数字的数组，比如下面这样就是代表震动300ms，暂停200ms，震动100ms，暂停400ms，震动100ms\r\nnavigator.vibrate([300,200,100,400,100])\r\n\r\n// 也可以传入0或者一个全是0的数组，表示暂停震动\r\nnavigator.vibrate(0)\r\n```\r\n\r\n### 用途\r\n使手机震动，用来给用户一个提示，例如说数据校验失败。\r\n![震动兼容性](assets/002/05-1545359841000.png)","timestamp":1585877701769},{"name":"01-DOM.md","path":"001-前端/08-JavaScript/003-DOM/01-DOM.md","content":"# DOM 文档对象模型\r\n>DOM 是 Document Object Model（文档对象模型）的缩写。\r\n>是用来呈现以及与任意 HTML 或 XML 交互的API文档。DOM 是载入到浏览器中的文档模型，它用节点树的形式来表现文档，每个节点代表文档的构成部分\r\n\r\n\r\n# DOM属性和方法\r\n\r\n## 属性\r\n| 属性 | 描述 |\r\n| ---- | ---- |\r\n| URL | 网站的url (只读) |\r\n| charset | 查看字符集 (只读) |\r\n| title | 文档的标题 (读写) |\r\n| forms | 文档中所有的form表单元素  |\r\n| imgages | 文档中所有的img元素 |\r\n| body | 获取body标签 |\r\n| documentElement | 获取html标签 |\r\n| cookie | 当前页面Cookie值的情况，它的值是一个字符串。 |\r\n| fileSize | 文件大小 (只读) |\r\n\r\n\r\n## 方法\r\n1. document.write()   动态向页面写入内容         \r\n\r\n### 获取元素\r\n1. 通过标签名获取元素   (结果是**数组**)         \r\n```js\r\ndocument.getElementsByTagName()\r\n```\r\n\r\n2. 通过类名获取元素  (结果是**数组**)     //ie6-8不支持\r\n```js\r\ndocument.getElementsByClassName()\r\n```\r\n\r\n3. 通过id获取元素  (结果是DOM元素)\r\n只能获取第一个拥有该id的元素    \r\n在IE6、7中会把表单元素的name当做ID值获取到。\r\n```js\r\ndocument.getElementById()        \r\n```\r\n\r\n4. 通过name属性获取元素 (结果是**数组**)    \r\n在IE浏览器中只能获取到表单元素，一般也只用它获取表单元素，从ie10开始可以不只是表单元素。\r\n```js\r\ndocument.getElementsByName()              \r\n```\r\n\r\n5. 通过css选择器获取元素         //不兼容IE7以及以下版本\r\n    1. 获取单个元素 (结果是一个DOM元素)\r\n    ```js\r\n    document.querySelector(\"css选择器\")\r\n    ```\r\n    2. 获取多个元素 (结果是 **数组**)\r\n    ```js\r\n    document.querySelectorAll(\"css选择器\")\r\n    ```\r\n\r\n>注意事项：获取元素的时候，document可以写成其他的标签，这样表示从这个标签内部来进行元素的筛选获取\r\n\r\n### 修改元素的内容\r\n1. 标签.innerHTML\r\n\r\n> 既能访问，又能修改\r\n> 可以识别标签，用来给元素内添加子标签很方便\r\n\r\n```js\r\n标签.innerHTML = \"内容\"\r\n```\r\n\r\n2. 标签.innerText\r\n\r\n> 既能访问，又能修改\r\n> 输出纯文本，无法识别标签\r\n\r\n```js\r\n标签.innerText = \"内容\"\r\n```\r\n\r\n3. textContent\r\n\r\n> 输出纯文本\r\n> 保留文本格式\r\n\r\n```js\r\n标签.textContent = \"内容\"\r\n```\r\n\r\n### 修改样式\r\n#### 修改类名、id\r\n1. className 属性\r\n\r\n> 访问、修改元素的类名\r\n\r\n```\r\n元素.className = \"类名\"\r\n```\r\n\r\n2. classList  属性    (ie9及以下不能用)\r\n    * add(类名1,类名2)    不修改原类名，添加新类名，可同时添加多个\r\n    * remove(类名1,类名2)  删除某一类名\r\n    * contains(类名)      判断一个类名是否存在\r\n    * toggle(类名1,类名2)     如果类名已存在，则删除；如果类名没有，则添加\r\n    ```js\r\n    元素.classList.add(\"类名\")\r\n    元素.classList.remove(\"类名\")\r\n    ```\r\n    > 注： ie11及以下都不支持add、remove、toggle的多个参数\r\n\r\n#### 修改行内样式\r\n> 当样式名作为对象的属性名时，样式名需要使用**驼峰命名法**，因为对象的属性名不能包含`-`    fontSize\r\n\r\n```js\r\n标签.style.样式名 = \"样式值\"       // 不会覆盖原样式\r\n\r\n// 所有行内样式组成的字符串\r\n// 等价于重写行内样式 (不需要驼峰命名法)\r\n// 原本行内样式会被覆盖\r\n标签.style.cssText = \"\"      \r\n\r\n// 原本行内样式 不会 覆盖\r\n标签.style.cssText += \"\"      \r\n```\r\n\r\n### 操作属性\r\n#### 原生属性\r\n> html标签自带的属性\r\n\r\n```js\r\n标签.属性名 = \"属性值\"\r\n标签.className = \"类名\"\r\n```\r\n\r\n例如：\r\n```js\r\ndiv.id = \"box\"\r\ninput.name = \"age\"\r\n```\r\n\r\n#### 自定义属性\r\n* 设置属性  setAttribute()\r\n* 获取属性  getAttribute()\r\n* 移除属性  removeAttribute()\r\n\r\n```js\r\n标签.setAttribute(属性名,属性值)\r\n标签.getAttribute(属性名)\r\n标签.removeAttribute(属性名)\r\n```\r\n\r\n>往HTML标签上添加自定义属性来存储和操作数据,例如我们把图片的地址存放到自定义属性上，需要加载时再把属性值赋给img的src属性，等等操作\r\n","timestamp":1585877701769},{"name":"02-事件.md","path":"001-前端/08-JavaScript/003-DOM/02-事件.md","content":"# DOM事件模型（DOM Event Model）\r\n> 事件是可以被 JavaScript 侦测到的行为，例如鼠标点击、键盘按键等。js与html的交互就是通过事件来进行的。\r\n\r\n## 事件的组成\r\n1. 事件源 ———— 标签\r\n2. 事件名称   \r\n3. 事件处理程序 ———— 函数\r\n\r\n## 事件集合\r\n### 鼠标事件\r\n1. 点击    onclick\r\n2. 双击    ondblclick\r\n3. 按下    onmousedown\r\n4. 抬起    onmouseup\r\n5. 移动    onmousemove\r\n6. 移入    onmouseover\r\n7. 移出    onmouseout\r\n8. 右键    oncontextmenu\r\n\r\n### 键盘事件\r\n1. 按下    onkeydown\r\n2. 抬起    onkeyup\r\n3. 按下    onkeypress    (只能触发数字字母符号)\r\n\r\n### 表单事件\r\n1. 获得焦点    onfocus   \r\n2. 失去焦点    onblur\r\n3. 失去焦点并内容改变    onchange\r\n4. 提交事件（form标签事件）    onsubmit\r\n5. 重置事件（form标签事件）    onreset\r\n\r\n### 其他事件\r\n1. 滚动条事件(滚动条位置改变)   onscroll\r\n2. 鼠标滚轮事件      onwheel\r\n3. 页面尺寸改变      onresize\r\n4. 页面加载完成之后执行该事件     onload\r\n\r\n### 自定义事件\r\n>详情查看后面\r\n\r\n## 添加事件的方法\r\n### 标签绑定事件\r\n```html\r\n<button onclick=\"click_fn()\">click</button>\r\n<script>\r\n  function click_fn(){\r\n    console.log(this);\r\n  }\r\n</script>\r\n```\r\n\r\n### DOM Document对象来绑定事件\r\n>重复监听某一事件，后者会覆盖前者，而不会两者先后触发\r\n\r\n```html\r\n<button>click</button>\r\n<script>\r\n  document.querySelector(\'button\').onclick=function(){\r\n                  console.log(\"第一个点击事件的方法\");\r\n               }\r\n  document.querySelector(\'button\').onclick=function(){\r\n                  console.log(\"第二个点击事件的方法\");\r\n                }      //第二个点击事件的方法会覆盖第一个方法,所以点击只会触发第二次的点击事件方法     \r\n</script>\r\n```\r\n\r\n### 事件监听\r\n> 为一个事件添加多个事件处理程序，解决了上面两种方法不能添加多个方法\r\n>更精细的控制事件监听器的触发阶段\r\n\r\n#### 添加事件处理程序\r\n```js\r\n标签.addEventListener(\"事件名称\",function(){},false);    //兼容到IE9及其以上\r\n\r\n标签.attachEvent(\"事件名称\",function(){})    //  ie8及以下\r\n```\r\n\r\n* 参数1： 表示事件类型的字符串 如：\"click\" \"mouseover\"  事件名称不添加on前缀\r\n* 参数2：回调函数 表示事件处理程序，函数中的this 指向添加监听的对象\r\n* 参数3：布尔值（可选） true表示在捕获阶段调用事件处理程序；false表示在冒泡阶段调用。后面会有事件流的详细解释\r\n\r\n#### 移除事件处理程序\r\n```html\r\n<button id=\"myBtn\"></button>\r\n<script type=\"text/javascript\">\r\n  var btn=document.getElementById(\'myBtn\');\r\n  function hander(){\r\n    console.log(this);\r\n  }\r\n  //兼容到IE9及其以上\r\n  btn.addEventListener(\'click\',hander,false);      //添加事件处理程序\r\n  btn.removeEventListener(\'click\',hander,false);    //移除事件处理程序\r\n\r\n  //  ie8及以下\r\n  btn.attachEvent(\'click\',hander);       // 添加\r\n  btn.detachEvent(\'click\',hander);       // 移除\r\n</script>\r\n```\r\n* 移除事件监听不能移除匿名的事件函数\r\n\r\n#### 事件监听的兼容写法\r\n```js\r\nfunction addEvent(obj,type,handle){\r\n  try{\r\n   obj.addEventListener(type,handle,false);\r\n  }catch(e){\r\n   try{\r\n    obj.attachEvent(\'on\'+type,handle);\r\n   }\r\n   catch(e){\r\n    obj[\'on\' + type]=handle;     //早期浏览器\r\n   }\r\n  }\r\n}\r\n```\r\n\r\n## 事件对象\r\n>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。所有浏览器都支持event对象，但支持方式不同。\r\n\r\n### 获取事件对象\r\n1. 一般地，event对象是事件程序的第一个参数(IE8及以下不支持)\r\n```html\r\n<div id=\"box\" style=\"height:30px;width:200px;background:pink;\"></div>\r\n<script>\r\nvar oBox = document.getElementById(\'box\');\r\noBox.onclick = function(a){\r\n    box.innerHTML = a;\r\n}\r\n</script>\r\n```\r\n2. 直接使用event变量(火狐浏览器不支持，输出event未定义)\r\n```html\r\n<div id=\"box\" style=\"height:30px;width:200px;background:pink;\"></div>\r\n<script>\r\nvar oBox = document.getElementById(\'box\');\r\noBox.onclick = function(){\r\n    box.innerHTML = event;\r\n}\r\n</script>\r\n```\r\n3. 兼容性写法\r\n```html\r\n<div id=\"box\" style=\"height:30px;width:200px;background:pink;\"></div>\r\n<script>\r\nvar oBox = document.getElementById(\'box\');\r\noBox.onclick = function(){\r\n  e = e || event;\r\n  box.innerHTML = e;\r\n}\r\n</script>\r\n```\r\n\r\n### 事件对象常用的方法和属性\r\n*  鼠标事件相关\r\n\r\n|属性|含义|\r\n|:----:|:----:|\r\n|clientX|当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置|\r\n|clientY|当鼠标事件发生的时候，鼠标相对于浏览器Y轴的位置|\r\n|offsetX|当鼠标事件发生的时候，鼠标相对于事件源X轴的位置|\r\n|offsetY|当鼠标事件发生的时候，鼠标相对于事件源Y轴的位置|\r\n|pageX|当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面横向滚动距离|\r\n|pageY|当鼠标事件发生的时候，鼠标相对于浏览器X轴的位置，包含页面纵向滚动距离|\r\n\r\n* 滚轮事件相关\r\n\r\n|属性|含义|\r\n|:----:|:----:|\r\n|deltaX|水平滚动量|\r\n|deltaY|垂直滚动量|\r\n|deltaMode|增值量的单位|\r\n\r\n* 键盘事件相关\r\n\r\n|属性|含义|\r\n|:----:|:----:|\r\n|keyCode|获取当前所按键的键盘码|\r\n|ctrlKey|判断当前ctrl键是否按下的状态|\r\n|shiftKey|判断当前shift键是否按下的状态|\r\n|altKey|判断当前alt键是否按下的状态|\r\n\r\n* 其他属性和方法\r\n\r\n|属性|含义|\r\n|:----:|:----:|\r\n|preventDefault()|阻止浏览器默认行为|\r\n|stopPropagation()|阻止事件流的传播|\r\n|currentTarget|指向被绑定事件的元素|\r\n|target|指向事件触发的对象，当事件是处在冒泡或者捕获阶段调用的时候，指向最先触发事件的事件源|\r\n|type|返回当前所触发事件的事件名称|\r\n\r\n## 事件流\r\n>事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。\r\n>事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。\r\n\r\n### 两种事件流模型\r\n1. 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。\r\n2. 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。</br>\r\n![捕获](amWiki/images/捕获.png)![冒泡](amWiki/images/冒泡.png)\r\n3. IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。\r\n\r\n### DOM事件流\r\n>DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。\r\n\r\n#### DOM事件流的三个阶段\r\nDOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。             \r\neventPhase属性返回一个整数值，表示事件目前所处的事件流阶段:0表示事件没有发生，1表示捕获阶段，2表示目标阶段，3表示冒泡阶段\r\n1. 事件捕获阶段：实际目标（`<div>`）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到`<html>`再到`<body>`就停止了。\r\n2. 处于目标阶段：事件在`<div>`上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。\r\n3. 冒泡阶段：事件又传播回文档。\r\n4. 所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。\r\n\r\n### 事件委派(子元素的事件加到父元素上)\r\n>事件委派的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。\r\n\r\n#### 用法\r\n1. 子元素的事件加到父元素上\r\n2. 触发事件时判断 触发该事件的元素是什么（e.target）\r\n     * 判断内容 innerHTML innerText\r\n     * 标签名 nodeName (判断的时候，标签名需要大写)\r\n     * 属性 e.target.hasAttribute(\"属性名\"); 有则是true 无则是false\r\n     * 类名 ID e.target.classList.contains(\"类名\")； 有则是true 无则是false\r\n3. 在判断成功中写对应的处理函数\r\n\r\n#### 应用场合\r\n1. 需要给大量元素添加同一事件处理程序的时候，提高代码运行的效率\r\n2. 在页面加载完成后新创建的元素， 比如通过ajax异步加载生成dom对象\r\n\r\n\r\n## 自定义事件(观察者模式)\r\n>自定义事件，顾名思义，就是自己定义事件类型，自己定义事件处理函数.\r\n\r\n### 事件创建\r\nJS中，最简单的创建事件方法，是使用Event构造器：\r\n```js\r\nvar myEvent = new Event(\'event_name\');\r\n```\r\n为了能够传递数据，使用 CustomEvent 构造器：\r\n```js\r\nvar myEvent = new CustomEvent(\'event_name\', { detail:{\r\n    // 将需要传递的数据写在detail中，以便在EventListener中获取\r\n    // 数据将会在event.detail中得到\r\n}, });\r\n```\r\n### 自定义事件的监听\r\nJS的EventListener是根据事件的名称来进行监听的，我们进行自定义事件监听的时候，需要创建相应的监听器\r\n```js\r\n//假设listener注册在window对象上\r\nwindow.addEventListener(\'event_name\', function(event){\r\n  // 如果是CustomEvent，传入的数据在event.detail中\r\n  console.log(\'得到数据为：\', event.detail);\r\n  // ...后续相关操作\r\n});\r\n```\r\n进行到这一步，window对象上就有了event_name这个事件的监听器，当触发这个事件时，相应的回调函数就会触发\r\n### 自定义事件的触发\r\n>普通的事件触发我们都有相对应的操作区，比如click，鼠标单击来触发，自定义事件需要我们显式的去触发它，使用dispatchEvent去触发(IE8低版本兼容，使用fireEvent);\r\n\r\n```js\r\nif(window.dispatchEvent) {  \r\n    window.dispatchEvent(myEvent);\r\n} else {\r\n    window.fireEvent(myEvent);\r\n}\r\n```\r\n\r\n### 简单的例子\r\n```js\r\nvar myEvent = new CustomEvent(\'event_name\', {\r\n  detail: { title: \'This is title!\'},\r\n});\r\nwindow.addEventListener(\'event_name\', function(event){\r\n  console.log(\'得到标题为：\', event.detail.title);\r\n});\r\n// 随后在对应的元素上触发该事件\r\nif(window.dispatchEvent) {\r\n  window.dispatchEvent(myEvent);\r\n} else {\r\n   window.fireEvent(myEvent);\r\n}\r\n```\r\n\r\n\r\n## DOM事件流的简单例子\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head lang=\"en\">\r\n    <meta charset=\"UTF-8\">\r\n    <title></title>\r\n</head>\r\n<style>\r\n    #outer{\r\n        position: absolute;\r\n        width: 400px;\r\n        height: 400px;\r\n        top:0;\r\n        left: 0;\r\n        bottom:0;\r\n        right: 0;\r\n        margin: auto;\r\n        background-color: deeppink;\r\n    }\r\n    #middle{\r\n        position: absolute;\r\n        width: 300px;\r\n        height:300px;\r\n        top:50%;\r\n        left: 50%;\r\n        margin-left: -150px;\r\n        margin-top: -150px;\r\n        background-color: deepskyblue;\r\n    }\r\n    #inner{\r\n        position: absolute;\r\n        width: 100px;\r\n        height:100px;\r\n        top:50%;\r\n        left:50%;\r\n        margin-left: -50px;\r\n        margin-top: -50px;;\r\n        background-color: darkgreen;\r\n        text-align: center;\r\n        line-height: 100px;\r\n        color:white;\r\n    }\r\n    #outer,#middle,#inner{\r\n        border-radius:100%;\r\n    }\r\n</style>\r\n<body>\r\n<div id=\"outer\">\r\n    <div id=\"middle\">\r\n        <div id=\"inner\">\r\n            click me!\r\n        </div>\r\n    </div>\r\n</div>\r\n<script>\r\n    var innerCircle= document.getElementById(\"inner\");\r\n    innerCircle.addEventListener(\"click\", function () {\r\n        alert(\"innerCircle的click事件在捕获阶段被触发\");\r\n    },true);\r\n    innerCircle.addEventListener(\"click\", function () {\r\n        alert(\"innerCircle的click事件在冒泡阶段被触发\");\r\n    },false);\r\n    var middleCircle= document.getElementById(\"middle\");\r\n    middleCircle.addEventListener(\"click\", function () {\r\n        alert(\"middleCircle的click事件在捕获阶段被触发\");\r\n    },true);\r\n    middleCircle.addEventListener(\"click\", function () {\r\n        alert(\"middleCircle的click事件在冒泡阶段被触发\");\r\n    },false);\r\n    var outerCircle= document.getElementById(\"outer\");\r\n    outerCircle.addEventListener(\"click\", function () {\r\n        alert(\"outerCircle的click事件在捕获阶段被触发\");\r\n    },true);\r\n    outerCircle.addEventListener(\"click\", function () {\r\n        alert(\"outerCircle的click事件在冒泡阶段被触发\");\r\n    },false);\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n","timestamp":1585877701769},{"name":"03-元素的尺寸和位置.md","path":"001-前端/08-JavaScript/003-DOM/03-元素的尺寸和位置.md","content":"# 元素的尺寸和位置\r\n### 元素的偏移量(只读属性，不能修改，返回的是一个数字)\r\n1. offsetHeight、offsetWidth: 表示元素的外尺寸：元素内容(content)+内边距(padding)+边框(border)(不包括外边距)\r\n2. offsetLeft、offsetTop：表示该元素的左上角距离最近的具有定位属性的祖先元素的左上角的水平距离和垂直距离。\r\n3. offsetParent：表示距离该元素最近的具有定位属性的祖先元素。   \r\n\r\n![offset](amWiki/images/offset.png)\r\n\r\n### 元素的内尺寸\r\n1. clientWidth/clientHeight: 表示元素的内尺寸：元素内容(content)+内边距(padding)\r\n2. clientTop/clientLeft: 表示元素的上边框和左边框大小：元素内容(border)\r\n\r\n![client](amWiki/images/client.png)\r\n\r\n### 元素的大小以及相对视口的位置getBoundingClientRect\r\n```js\r\nelement.getBoundingClientRect()     //返回一个对象，对象中包含\r\n//x\\y:元素的左上角和视口左上角的距离\r\n//width/height:边框 + 内边距 + 内容框\r\n//top:元素的上边界和视口上边界的距离\r\n//left:元素的左边界和视口左边界的距离\r\n//right:元素的右边界和视口的左边界的距离\r\n//bottom:元素的下边界和视口上边界的距离\r\n```\r\n![getBoundingClientRect](amWiki/images/位置大小对象.jpg)\r\n\r\n\r\n### 页面的实际大小\r\n```js\r\ndocument.documentElement.scrollWidth\r\ndocument.documentElement.scrollHeight\r\n```\r\n![scroll](amWiki/images/scroll.png)\r\n\r\n### 窗口左上角 与 屏幕左上角的 距离\r\n```js\r\nwindow.screenX\r\nwindow.screenY\r\n```\r\n\r\n### 屏幕宽高\r\n```js\r\nwindow.screen.width\r\nwindow.screen.height\r\n```\r\n\r\n### 屏幕可用宽高（去除任务栏）\r\n```js\r\nwindow.screen.availWidth\r\nwindow.screen.availHeight\r\n```\r\n### 窗口的内高度、内宽度（文档显示区域+滚动条）\r\n```js\r\nwindow.innerWidth\r\nwindow.innerHeight\r\n```\r\n### 窗口的外高度、外宽度\r\n```js\r\nwindow.outerWidth\r\nwindow.outerHeiht\r\n```\r\n","timestamp":1585877701769},{"name":"04-DOM节点.md","path":"001-前端/08-JavaScript/003-DOM/04-DOM节点.md","content":"# DOM 节点\r\n>在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。\r\n\r\n## 节点的种类\r\n1. 元素节点 (每个 HTML 元素是元素节点)       \r\n2. 属性节点    (每个 HTML 属性是属性节点)\r\n3. 文本节点   (文字、空格、换行)\r\n4. 注释节点   (文档中的注释)\r\n5. 文档节点   (整个文档是一个文档节点)\r\n\r\n### 五种节点所对应的信息属性\r\n|节点分类|节点类型(nodeTpe)|节点名称(nodeName)|节点内容(nodeValue)|\r\n|----   |----     |----    |----   |\r\n|元素节点 |1      |标签名    |null  |\r\n|属性节点| 2      |属性名   | 属性值|\r\n|文本节点|  3     | #text  |  文本  |\r\n|注释节点|  8     |#comment |注释的文字   |\r\n|文档节点|    9  |  #documen| null  |\r\n\r\n## 节点的属性\r\n1. parentNode    获取父节点\r\n2. childNodes      获取子节点\r\n3. firstChild     第一个子节点\r\n4. lastChild      最后一个子节点\r\n5. nextSibling     下一个兄弟节点\r\n6. previousSibling     上一个兄弟节点\r\n\r\n> 上面的6个属性在使用的时候有些情况下我们输出的时候会显示undefined，因为在浏览器解析的时候会把换行和空格一起解析，获取的并没有错误，只是获取的这些节点是一个换行或者是一个空格。所以推荐使用下面的四种方法来获取，它们会只获取元素节点\r\n\r\n1. nextElementSibling   下一个元素节点 (标签)\r\n2. previousElementSibling      上一个元素节点 (标签)\r\n3. firstElementChild      第一个元素子节点 (标签)\r\n4. lastElementChild      最后一个元素子节点 (标签)\r\n\r\n### 节点练习\r\n编写函数：\r\n* 获取一个元素的所有子元素节点         \r\n* 获取第一个子元素节点         \r\n* 获取最后一个子元素节点   \r\n\r\n\r\n\r\n\r\n## 节点的方法\r\n1. document.createElement() 创建一个元素节点\r\n>接收参数为string类型的nodename\r\n\r\n2. document.createTextNode() 创建一个文本节点\r\n>接收参数为string类型的text内容\r\n\r\n3. document.createAttribute() 创建一个属性节点\r\n>接收参数为string类型的属性名称\r\n\r\n4. document.createComment() 创建一个注释节点\r\n>接收参数为string类型的注释文本\r\n\r\n5. document.createDocumentFragment() 创建一个虚拟的节点对象\r\n>DocumentFragment节点不属于文档树,当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点。\r\n\r\n6. 父元素.insertBefore(要插入的节点, 插入到某个元素之前)\r\n1. 父元素.removeChild(子节点)      删除子节点\r\n2. 父元素.replaceChild(新节点,被修改的节点)            替换节点\r\n3. node.cloneNode(boolean)          克隆节点\r\n\r\n### 创建并插入节点流程\r\n1. document.createElement(\"标签名\")    (创建标签)\r\n2. 添加属性： (给创建的标签添加属性，参考DOM属性和方法)\r\n3. 添加内容： (给创建的标签添加内容，参考DOM属性和方法)\r\n4. 添加样式： (给创建的标签添加样式，参考DOM属性和方法)\r\n5. 父元素.appendChild(子节点)\r\n> 被插入的节点，可以是新创建的，也可是页面中已经存在的  \r\n\r\n6. 父元素.insertBefore(要插入的节点, 插入到某个元素之前)\r\n1. 父元素.removeChild(子节点)      删除子节点\r\n2. 父元素.replaceChild(新节点,被修改的节点)            替换节点\r\n3. node.cloneNode(boolean)          克隆节点\r\n```html\r\n<div class=\"box\">\r\n  <span>克隆节点</span>\r\n</div>\r\n<script type=\"text/javascript\">\r\n  var box=document.querySelector(\".box\");\r\n  // 参数为boolean，设置为true则意味着同时克隆该节点的所有子节点\r\n  var newBox=div.cloneNode(true);\r\n</script>\r\n```\r\n","timestamp":1585877701769},{"name":"05-移动端事件.md","path":"001-前端/08-JavaScript/003-DOM/05-移动端事件.md","content":"# 移动端事件\r\n> 在1996年，Netscape（网景）引入了鼠标事件和著名的鼠标悬停事件，使得Web开发者能够在PC端开发出可交互的网站。随后引入了键盘事件，能够让我们在网页中监控到用户的输入动作。这两种事件在PC端统治了长达15年，一直到iOS设备的出现，它既没有鼠标也没有键盘，所以在为移动Safari开发交互网页时，常规的鼠标和键盘事件根本不够用，于是又了第三种时间-触摸事件。随着Android中的WebKit的加入，很多这样的专有事件变成了事实标准。\r\n\r\n## 移动端常用事件\r\n|事件|作用|\r\n|:----:|:----:|\r\n|click| \t当点击时触发（单击）|\r\n|load|页面结束加载之后触发|\r\n|scroll|当元素滚动条被滚动时运行的脚本|\r\n|blur|元素失去焦点时运行的脚本|\r\n|focus| \t当元素获得焦点时运行的脚本|\r\n|change|在元素值被改变时运行的脚本|\r\n|input| \t代替keyup、keydown|\r\n|touch事件模型|处理单手指操作|\r\n|gesture事件模型|处理多手指操作|\r\n\r\n### touch事件模型（手势事件）\r\n\r\n|事件|含义|\r\n|:----:|:----:|\r\n|touchstart|当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。|\r\n|touchmove|当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动|\r\n|touchend|当手指从屏幕上离开的时候触发|\r\n|touchcancle|特殊情况下关闭/退出时触发|\r\n\r\n### gesture事件模型  （触摸事件）\r\n|事件|含义|\r\n|:----:|:----:|\r\n|gesturestart|当鼠标点击时触发|\r\n|gesturechange|当鼠标点击时触发|\r\n|gestureend|当鼠标点击时触发|\r\n\r\n* 触摸事件的事件对象\r\n> 我们可以同时又很多手指触摸屏幕，所以在事件对象里面给我们提供了相应的数组来存储每个手指的信息。\r\n\r\n      * touches：表示当前跟踪的触摸操作的touch对象的数组。\r\n      * targetTouches：特定于事件目标的Touch对象的数组。\r\n      * changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。\r\n\r\n＊事件对象属性\r\n\r\n|属性|含义|\r\n|:----:|:----:|\r\n|clientX|触摸目标在视口中的x坐标|\r\n|clientY|触摸目标在视口中的y坐标|\r\n|identifier|标识触摸的唯一ID|\r\n|pageX|触摸目标在页面中的x坐标|\r\n|pageY|触摸目标在页面中的y坐标|\r\n|screenX|触摸目标在屏幕中的x坐标|\r\n|screenY|触摸目标在屏幕中的y坐标|\r\n|timeStamp|从页面打开到当前时间触发所经过的毫秒数|\r\n```\r\n    clientX:65 // 触摸点在浏览器窗口中的横坐标\r\n    clientY:18 // 触摸点在浏览器窗口中的纵坐标\r\n    force:1 // 触摸点压力大小\r\n    identifier:0 // 触摸点唯一标识（ID）\r\n    pageX:65 // 触摸点在页面中的横坐标\r\n    pageY:18 // 触摸点在页面中的纵坐标\r\n    radiusX:11.5 // 触摸点椭圆的水平半径\r\n    radiusY:11.5 // 触摸点椭圆的垂直半径\r\n    rotationAngle:0 // 旋转角度\r\n    screenX:560 // 触摸点在屏幕中的横坐标\r\n    screenY:175 // 触摸点在屏幕中的纵坐标\r\n```\r\n\r\n### DeviceMotionEvent事件\r\nDeviceMotionEvent为web开发者提供了关于设备的位置和方向改变的速度的信息。       \r\n目前，Firefox 和 Chrome 处理坐标的方式不同。 在使用它们的时候要多加注意。  \r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=deviceorientation\" frameborder=\"0\"></iframe>          \r\n#### 原理  \r\n开发者从各个内置传感器那里获取未经修改的传感数据，并观测或响应设备各种运动和角度变化。这些传感器包括陀螺仪、加速器和磁力仪(罗盘)。        \r\n加速器和陀螺仪的数据都是描述沿着iOS设备三个方向轴上的位置，对于一个竖屏摆放的iPhone来说，X方向从设备的左边(负)到右边(正)，Y方向则是由设备的底部(-)到顶部(+)，而Z方向为垂直于屏幕由设备的背面(-)到正面(+)。           \r\nDeviceMotionEvent 会在设备发生有意义的摆动(或运动)时产生.事件对象封装有产生的间距值,旋转率,和设备加速度.      \r\n加速度的计算方式是重力和用户产生的两个加速度矢量之和.设备是通过 陀螺仪和加速计来区别这两者的.\r\n通过DeviceMotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。\r\n#### 属性(只读)\r\n1. DeviceMotionEvent.acceleration       \r\n提供了设备在X,Y,Z轴方向上加速度的对象。加速度的单位为 m/s2。\r\n```js\r\nwindow.addEventListener(\'devicemotion\', function(event) {\r\n  console.log(event.acceleration.x + \' m/s2\');\r\n});\r\n```\r\n2. DeviceMotionEvent.accelerationIncludingGravity      \r\n    提供了设备在X,Y,Z轴方向上带重力的加速度的对象。加速度的单位为 m/s2\r\n3. DeviceMotionEvent.rotationRate      \r\n提供了设备在 alpha，beta， gamma轴方向上旋转的速率的对象。旋转速率的单位为 ?°/s 。\r\n4. DeviceMotionEvent.interval         \r\n表示从设备获取数据的频率，单位是毫秒。  \r\n\r\n\r\n\r\n## 手势库\r\n### HammerJS\r\n#### 简介\r\n用于检测触摸手势的 JavaScript 库                 \r\n添加对触摸手势的支持并移除了点击的 300ms             \r\n支持最常见的单点和多点触摸手势，并且可以完全扩展以添加自定义手势        \r\n>安卓触屏上，tap 和 click 可以同时触发，但是 click 会有 300ms 左右的延时\r\n\r\n#### 兼容性\r\n查看兼容：http://hammerjs.github.io/browser-support/\r\n\r\n\r\n\r\n#### 下载安装\r\n点击下载：http://hammerjs.github.io/dist/hammer.min.js\r\n\r\n\r\n\r\n#### 基本使用\r\n```html\r\n<div id=\"test\" class=\"test\"></div>\r\n<script type=\"text/javascript\">\r\n       //创建一个新的hammer对象并且在初始化时指定要处理的dom元素\r\n       var hammertime = new Hammer(document.getElementById(\"test\"));\r\n       //为该dom元素指定触屏移动事件\r\n       hammertime.on(\"pan\", function (ev) {\r\n           //控制台输出\r\n           console.log(ev);\r\n       });\r\n</script>\r\n```\r\nhammer.js 提供了 tap, doubletap, press, horizontal pan, swipe 和多点触控的 pinch, rotate，默认情况下 pinch 与 rotate 是禁用的，因为它们会阻塞元素，可以通过以下命令来启用。\r\n```js\r\nhammertime.get(\'pinch\').set({ enable: true });\r\nhammertime.get(\'rotate\').set({ enable: true });\r\n```\r\n默认的 pan 仅支持水平方向，可以选择启用全部方向，swipe 也可以启用垂直方向\r\n```js\r\nhammertime.get(\'pan\').set({ direction: Hammer.DIRECTION_ALL });\r\nhammertime.get(\'swipe\').set({ direction: Hammer.DIRECTION_VERTICAL });\r\n```\r\n建议使用 viewport meta 禁用双击/缩放功能，更多的控制网页，支持触摸操作的浏览器不需要这样做\r\n```html\r\n<meta name=\"viewport\" content=\"user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1\">\r\n```\r\n\r\n#### 手势总结\r\n![HammerJS](amWiki/images/HammerJS.png)\r\n1. tap               \r\n在指定的 DOM 区域内，一个手指轻拍或点击时触发该事件（类似 PC 端的 click），该事件最大点击时间为 250ms，如果超过 250ms 则按 press 事件处理\r\n2. press\r\n在指定的 DOM 区域内，这个事件相当于 PC 端的 Click 事件，不能包含任何的移动，最小按压时间为 500ms，常用于我们在手机上用的复制粘贴等功能                      \r\n该事件事分别对以下事件进行监听并处理             \r\n      * pressup: 点击事件离开时触发\r\n3. pan\r\n在指定的 DOM 区域内，一个手指放下并移动事件，即触屏中的拖动事件                   \r\n该事件事分别对以下事件进行监听并处理                       \r\n      * panstart: 拖动开始\r\n      * panmove: 拖动过程\r\n      * panend: 拖动结束\r\n      * pancancel: 拖动取消\r\n      * panleft: 向左拖动\r\n      * panup: 向上拖动\r\n      * pandown: 向下拖动\r\n4. swipe\r\n在指定的 DOM 区域内，一个手指快速的在触屏上滑动，即平时用到最多的滑动事件                  \r\n该事件事分别对以下事件进行监听并处理             \r\n      * swipeleft: 向左滑动\r\n      * swiperight: 向右滑动\r\n      * swipeup: 向上滑动\r\n      * swipedown: 向下滑动\r\n5. pinch\r\n在指定的 DOM 区域内，两个手指（默认为两个手指，多指触控需要单独设置）或多个手指相对（越来越近）移动或相向（越来越远）移动时事件               \r\n该事件事分别对以下事件进行监听并处理            \r\n     * pinchstart: 多点触控开始\r\n     * pinchmove: 多点触控过程\r\n     * pinchend: 多点触控结束\r\n     * pinchcancel: 多点触控取消\r\n     * pinchin: 多点触控时两手指越来越近\r\n     * pinchout: 多点触控时两手指越来越远\r\n6. rotate\r\n在指定的 DOM 区域内，当两个手指或更多手指呈圆型旋转时触发                          \r\n该事件事分别对以下事件进行监听并处理            \r\n     * rotatestart: 旋转开始\r\n     * rotatemove: 旋转过程\r\n     * rotateend: 旋转结束\r\n     * rotatecancel: 旋转取消\r\n\r\n#### 事件对象\r\n|Name | Value |\r\n|---- | ---- |\r\n| type | 事件的名称，例如 panstart |\r\n| deltaX | X 轴移动 |\r\n| deltaY | Y 轴移动 |\r\n| deltaTime | 自从第一次 input 的总时间，单位 ms |\r\n| distance | 移动距离 |\r\n| angle | 角度 |\r\n|velocityX  |   X 轴上的速度，单位为 px/ms|\r\n|velocityY |   Y 轴上的速度，单位为 px/ms|\r\n|velocity  |    velocityX/velocityY 的最高值|\r\n|direction  |  移动方向，匹配 DIRECTION 常量|\r\n|offsetDirection| 相对于起点的方向，匹配 DIRECTION 常量|\r\n|scale | 在多点触摸缩放时，只是触摸时值为 1|\r\n|rotation | 在多点触摸旋转时，只是触摸时值为 0|\r\n|center | 多点触摸的中心位置，或者只是单独的点|\r\n|srcEvent | 源事件对象，类型为 TouchEvent，MouseEvent 或 PointerEvent|\r\n|target |  收到该事件的目标|\r\n|pointerType |  主要点类型，可能是 touch，mouse，pen 或 kinect|\r\n|eventType  | 事件类型，匹配 INPUT 常量|\r\n|isFirst  | 第一个 input 时为 true|\r\n|isFinal |  最后一个 input 时为 true|\r\n|pointers  | 所有点的数组，包括结束点（touchend，mouseup）|\r\n|changedPointers  |  包含所有 new/moved/lost 的点|\r\n|preventDefault   |参考 srcEvent.preventDefault() 方法|\r\n\r\n#### 使用注意事项\r\n1. 尽量避免垂直 pan/swipe            \r\n垂直 pan 用于滚动页面，一些（旧）浏览器不会触发这个事件，所以 hammer.js 无法识别\r\n2. 删除 Windows Phone 上的突出显示         \r\nWindows Phone 上的 IE10 和 IE11 在点击某个元素时会突出显示一个小点，添加这个 meta 来删除        \r\n`<meta name=\"msapplication-tap-highlight\" content=\"no\" />`\r\n3. tap 后，click 也被触发了          \r\n该点击事件也被称为 “幽灵点击”（ghost click）\r\n\r\n\r\n\r\n## 案例\r\n### 摇一摇\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n <head>\r\n     <meta charset=\"UTF-8\">\r\n     <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\">\r\n     <title>摇一摇抽奖</title>\r\n    <style type=\"text/css\">\r\n        html,body{ width:100%; height:100%; background-color: #000; margin:0; overflow: hidden;}\r\n       .tip{ position: absolute; bottom: 30px; left: 10px; color: #fff; font-family: \'楷体\'; text-align: center; right: 10px; height: 32px; line-height: 32px; background-color: rgba(255,255,255,.4); border-radius: 3px; } .tip.active{ -webkit-animation: jump 1.5s linear; animation: jump 1s linear; }\r\n   </style>\r\n</head>\r\n<body>\r\n    <div class=\"tip\" id=\"tip\"> </div>\r\n\r\n    <script type=\"text/javascript\">\r\n        var lastX = null,\r\n            lastY = null,\r\n            lastZ = null;\r\n        var threshold = 3; //灵敏度（值越小灵敏度越高）\r\n        var timeout = 1000;\r\n        var lastTime = null;\r\n        var isShaking = !1;\r\n        document.addEventListener(\'DOMContentLoaded\', function (e) {\r\n            ready();\r\n        }, !1);\r\n        /*脚本逻辑：\r\n        *移动端JS脚本逻辑的实现，摇一摇的实现需借助html5新增的devicemotion事件，获取设备在位置和方向上的改变速度的相关信息。\r\n        *devicemotion事件对象中有一个accelerationIncludingGravity属性，该属性包括：一个包含x、y 和z 属性的对象，在考虑z 轴自然重力加速度的情况下，告诉你在每个方向上的加速度。\r\n        */\r\n        function ready() {\r\n            if (window.DeviceMotionEvent) {\r\n                window.addEventListener(\'devicemotion\', handler, !1);\r\n                lastTime = new Date();\r\n            } else {\r\n                alert(\'你的浏览器不支持摇一摇功能.\');\r\n            }\r\n        }\r\n        function handler(e) {\r\n            var current = e.accelerationIncludingGravity;\r\n            var currentTime;\r\n            var timeDifference;\r\n            var deltaX = 0;\r\n            var deltaY = 0;\r\n            var deltaZ = 0;\r\n\r\n            //记录上一次设备在x,y,z方向上的加速度\r\n            if ((lastX === null) && (lastY === null) && (lastZ === null)) {\r\n                lastX = current.x;\r\n                lastY = current.y;\r\n                lastZ = current.z;\r\n                return;\r\n            }\r\n\r\n            //得到两次移动各个方向上的加速度绝对差距\r\n            deltaX = Math.abs(lastX - current.x);\r\n            deltaY = Math.abs(lastY - current.y);\r\n            deltaZ = Math.abs(lastZ - current.z);\r\n            //当差距大于设定的阀值并且时间间隔大于指定阀值时，触发摇一摇逻辑\r\n            if (((deltaX > threshold) && (deltaY > threshold)) || ((deltaX > threshold) && (deltaZ > threshold)) || ((deltaY > threshold) && (deltaZ > threshold))) {\r\n                currentTime = new Date;\r\n                timeDifference = currentTime.getTime() - lastTime.getTime();\r\n                //时间间隔\r\n                if (timeDifference > timeout) {\r\n                    //触发摇一摇事件\r\n                    dealShake();\r\n                    lastTime = new Date;\r\n                }\r\n            }\r\n\r\n            lastX = current.x;\r\n            lastY = current.y;\r\n            lastZ = current.z;\r\n        }\r\n\r\n        function dealShake() {\r\n            if (isShaking) return;\r\n             isShaking = !0;\r\n\r\n            document.getElementById(\"tip\").innerHTML = \"恭喜您，摇中：\" + GetName();\r\n\r\n            setTimeout(function () {\r\n                isShaking = !1;\r\n                document.getElementById(\"tip\").innerHTML = \" \";\r\n            }, 1000);\r\n\r\n        }\r\n        function GetName() {\r\n            var chars = [\"一等奖\", \"二等奖\", \"三等奖\", \"四等奖\", \"五等奖\"];\r\n            return chars[GetRandom(0, chars.length - 1)];\r\n        }\r\n        function GetRandom(minValue, maxValue) {\r\n            return Math.round(Math.random() * (maxValue - minValue)) + minValue;\r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n","timestamp":1585877701769},{"name":"06-本地存储.md","path":"001-前端/08-JavaScript/003-DOM/06-本地存储.md","content":"# 本地存储\r\n>js在客户端的存储主要分为三种cookie、localStorage和sessionStorage\r\n\r\n浏览器查看三种存储\r\n![本地存储](amWiki/images/本地存储.png)\r\n\r\n## cookie\r\n>Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。每个cookie不能超过 4KB，每个 Web 站点能设置的 Cookie 总数不能超过 20 个\r\n\r\n### 特点和应用\r\n* 存储方式：键值对\r\n* 大小：4kb,以20个为上限\r\n* 根据域名存储，不同域名的cookie无法访问\r\n* 清理机制:IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。\r\n* 缺陷：同域内http请求都会带cookie，浪费带宽\r\n* 主要应用：购物车，登录状态\r\n\r\n### 操作cookie\r\n> 注：cookie使用时需要服务器环境       \r\n键值对的方式设置：`document.cookie= \"键=值\"`\r\n\r\n```js\r\ndocument.cookie = name + \'=\' + value;    //设置cookie\r\n```\r\n```js\r\n// 设置cookie的有效时间\r\nvar d= new Date();\r\nd.setHours(d.getHours() + (24 * 30)); //保存一个月\r\ndocument.cookie = \"visited=yes; expires=\" + d.toUTCString();\r\n```\r\n```js\r\n// 读取cookie\r\ndocument.cookie.indexOf(\"key\")      //返回值 -1表示不存在此cookie\r\n```\r\n```js\r\n//删除cookie     原理：通过设置cookie的有效时间来删除cookie\r\nvar exp = new Date();\r\nexp.setTime(exp.getTime() - 1);\r\ndocument.cookie= name + \"=\"+cval+\";expires=\"+exp.toUTCString();\r\n```\r\n\r\n## localstorage\r\n>H5客户端存储是web存储的一种更为强大的版本，可提供更多的安全性、速度和易用性。在 Web 中可以存储数量巨大的数据。具体的数量则取决于 Web 浏览器，但通常都在 5MB 到10MB 之间，这对于一个 HTML应用程序而言已经足够大。另一个好处是此数据并不会在每次出现服务器请求时都被加载。\r\n\r\n\r\n### 特点和应用\r\n* **兼容性**    ie8+\r\n* 存储内容： 只要是能序列化成字符串的内容都可以存储，利用JSON.stringify()；\r\n    * JSON.stringify() 将对象转化为字符串\r\n    * JSON.parse() 将字符串转化为对象\r\n* 存储方式：键值对\r\n* 根据域名存储，不同域名的本地存储无法访问\r\n* 存储大小： 5m\r\n* 主要应用：常用于ajax请求缓存\r\n* 缺陷：\r\n    1. localstorage不被爬虫识别，所以不能用它完全取代url传參\r\n    2. 不能跨域共享，所以不要用以存储业务关键信息，更加不要存储安全信息，（cookie可以通过window.name解决，但是localstorage不能）\r\n\r\n* 常用于：\r\n    * 需要长期保存的数据，一段时候后打开浏览器仍然存在\r\n    * 网页游戏分数\r\n    * 记住用户名\r\n\r\n### 判断浏览器是否支持localstorage\r\n```js\r\nif (window.localStorage) {\r\n    console.log(\'浏览器支持\');\r\n} else {\r\n    console.log(\'浏览器不支持\');\r\n}\r\n```\r\n\r\n### 操作localstorage\r\n```js\r\nlocalStorage.setItem(\"name\",\"张三\")    //设置数据\r\nlocalStorage.getItem(\"name\");      //访问数据\r\nlocalStorage.removeItem(\"name\");   //移除本地存储\r\nlocalStorage.clear()；      //清空本地存储\r\n```\r\n\r\n\r\n\r\n## sessionStroage\r\n> 短期存储，页面关闭后存储消失，其他与长期存储一样\r\n\r\n* 常用于：\r\n    * 具有时效性的网站信息，一段时候后打开浏览器数据消失\r\n    * 登录信息保存\r\n    * 搜索记录\r\n    * 同一网站不同网页之间的数据可存储到本地存储共同使用\r\n\r\n\r\n### 三种存储方式的区别总结\r\n#### 相同点\r\n都保存在浏览器端，同源的\r\n#### 不同点\r\n1. 传递方式不同\r\n     * cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。\r\n     * sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\r\n2. 数据大小不同\r\n     * cookie数据不能超过4k\r\n     * sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\r\n3. 数据有效期不同\r\n     * cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。\r\n     * sessionStorage：仅在当前浏览器窗口关闭前有效。\r\n     * localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；\r\n\r\n## 课堂练习\r\n1. toDoList练习\r\n","timestamp":1585877701769},{"name":"07-JavaScript动画.md","path":"001-前端/08-JavaScript/003-DOM/07-JavaScript动画.md","content":"# JavaScript动画\r\n网页动画实现方式：  \r\n1. CSS3: 过渡transition 、 动画@media\r\n2. JavaScript原生动画\r\n3. JQuery的animate函数\r\n4. Web Animations API\r\n5. canvas\r\n6. 动画插件\r\n7. 引用gif图片\r\n\r\n\r\n## Web Animations API\r\n\r\n### 设置动画\r\nweb Animations API可以让我们用JavaScript写动画并且控制动画。\r\n\r\n语法：\r\n```js\r\nelement.animate(keyframes, timing)\r\n```\r\n\r\n参数：  \r\n* **keyframes**: 关键帧对象数组，代表原始css的每个帧\r\n* **timing**: 动画时间属性对象，规定运动时间、运动方式等属性\r\n\r\n以此css3动画为例，使用animate api来实现：\r\n```css\r\ndiv{\r\n    animation: turn 3s linear infinite ;\r\n}\r\n@keyframes turn {\r\n    0%{\r\n        background-color: #000;\r\n        transform: rotate(0);\r\n    }\r\n    100%{\r\n        background-color: #ccc;\r\n        transform: rotate(360deg);\r\n    }\r\n}\r\n```\r\n\r\n#### 参数1: keyframes\r\n\r\n```js\r\nvar keyframes = [\r\n  { backgroundColor: \'#000\', transform: \'rotate(0)\', offset:0},\r\n  { backgroundColor: \'#ccc\', transform: \'rotate(360deg)\', offset:1},\r\n];\r\n```\r\n\r\nkeyframes参数使用一个包含多个对象的数组，每个对象代表原始CSS中的一个帧。\r\n\r\n与CSS不同的是，Web动画API不需要指定每个帧出现的时间百分比，会根据给出帧的个数自动进行时间等分。\r\n如果需要设置某一个帧的时间时，可以使用`offset`属性，在30%的时间点则写`offset: 0.3`。\r\n\r\n\r\n**必须至少指定两个关键帧**（表示动画序列的开始和结束状态），否则会报错。\r\n\r\n\r\n#### 参数2: timing\r\n```js\r\nvar timing = {\r\n  duration: 3000,\r\n  iterations: Infinity,\r\n}\r\n```\r\n运动方式配置：\r\n\r\n| 属性 | 值 | 说明 |\r\n|---|---|---|\r\n| duration | ms | 一次动画持续的毫秒时间，只支持毫秒，不写单位 |\r\n| iterations | number | 动画次数. `Infinity`表示无数次。默认值 1 |\r\n| delay | number | 动画延迟时间，以ms计,不写单位。 默认值 0 |\r\n| direction | normal / reverse</br>alternate / alternate-reverse| 动画运动方向，reverse反向，alternate一次运动结束后逆向播放。 默认值 `normal` |\r\n| easing | cubic-bezier | 动画运动方式，\"linear\"，\"ease\"，\"ease-in\"，\"ease-out\"，和\"ease-in-out\"等。 默认值 \'linear\' |\r\n| fill | none / backwards / forwards / both | 保留动画状态，backwards保留播放前状态，forwards保留播放结束状态，both全部保留。 默认值 \'none\' |\r\n| delay | number | 动画延迟时间，以ms计,不写单位, 默认值 0 |\r\n\r\n\r\n\r\n\r\n动画参数整合：\r\n```js\r\nvar keyframes = [\r\n  { backgroundColor: \'#000\', transform: \'rotate(0)\', offset:0},\r\n  { backgroundColor: \'#ccc\', transform: \'rotate(360deg)\', offset:1},\r\n]\r\nvar timing = {\r\n  duration: 3000,\r\n  iterations: Infinity,\r\n}\r\n\r\nvar div = document.querySelector(\"div\");\r\ndiv.animate(keyframes, timing);\r\n```\r\n如果只需要指定动画的持续时间，可以单独传递毫秒:\r\n```js\r\nvar div = document.querySelector(\"div\");\r\ndiv.animate([\r\n  { backgroundColor: \'#000\', transform: \'rotate(0)\', offset:0},\r\n  { backgroundColor: \'#ccc\', transform: \'rotate(360deg)\', offset:1},\r\n], 3000);\r\n```\r\n\r\n\r\n### 动画播放控制\r\n`Element.animate()`方法执行会会返回一个动画对象，动画对象中还提供了一些控制播放的有用方法：\r\n\r\n 属性 | 功能\r\n---|---\r\nplaybackRate | 动画播放速度。取一个可以是0、负数或正数的数字。负值反转动画。该值是缩放因子，因此例如值2将使播放速度加倍\r\n\r\n\r\n 方法 | 功能\r\n---|---\r\npause() | 动画暂停\r\nplay() | 动画播放\r\nreverse() | 播放方向。如果在未播放的动画上调用，则向后播放整个动画。如果在暂停的动画上调用，则动画将反向继续\r\nfinish() | 立即完成动画\r\ncancel() | 立即关闭动画\r\n\r\n\r\n`Element.animate()` 方法会在调用后立即执行进行运动，为了在启动运动时加一写限制(例如点击开始运动),可以调用`Animation.pause()`，点击事件中调用`Animation.play()`：\r\n\r\n```js\r\nvar div = document.querySelector(\"div\");\r\nvar turn = div.animate([\r\n  { backgroundColor: \'#000\', transform: \'rotate(0)\', offset:0},\r\n  { backgroundColor: \'#ccc\', transform: \'rotate(360deg)\', offset:1},\r\n], 3000);\r\nturn.pause();  \r\n// 动画默认暂停，点击后开始运动\r\ndiv.onclick = function(){ turn.play() }\r\n\r\n```\r\n\r\n\r\n### 动画事件\r\n\r\n事件名 | 功能\r\n---|---\r\n onfinish | 动画播放完成后触发该事件 （播放完成或通过`finish()`完成动画）\r\n oncancel | 动画被关闭时触发该事件 （通过`cancel()`可关闭动画）\r\n\r\n\r\n### 兼容性\r\n\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=web-animation\" frameborder=\"0\"></iframe>\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 原生js动画\r\n由于`Web Animations API`兼容性较差，所以在设置JavaScript动画时会使用插件或使用原生js封装动画：\r\n\r\n```js\r\nfunction linear(t, b, c, d) {\r\n    return c / d * t + b\r\n}\r\n\r\nfunction animates(element, target, duration, callback) {\r\n    let change = {};\r\n    let begin = {};\r\n    for (let key in target) {\r\n        begin[key] = getCss(element, key);\r\n        change[key] = removeUnit(target[key]) - begin[key];\r\n    }\r\n\r\n    let time = 0;\r\n    let timing = setInterval(() => {\r\n        time += 20;\r\n      if (time >= duration) {\r\n          clearInterval(timing);\r\n          for (let key in target) {\r\n              setCss(element, key, target[key]);\r\n          }\r\n          callback && callback.call(element);\r\n          return;\r\n      }\r\n      for (let key in target) {\r\n          let current = linear(time, begin[key], change[key], duration);\r\n          setCss(element, key, current);\r\n      }\r\n  }, 20)\r\n}\r\n\r\nfunction getCss(ele, attr) {\r\n    let value = window.getComputedStyle(ele)[attr];\r\n    return removeUnit(value);\r\n}\r\n\r\nfunction removeUnit(value) {\r\n    let reg = /^[-+]?([1-9]\\d+|\\d)(\\.\\d+)?(px|pt|em|rem)$/;\r\n    if (isNaN(value) && reg.test(value)) return parseFloat(value);\r\n    if (isNaN(value)) return Number(value);\r\n    return value\r\n}\r\n\r\nfunction setCss(ele, attr, val) {\r\n    let reg = /^(width|height|top|bottom|left|right|(margin|padding)(Top|Left|Bottom|Right)?)$/;\r\n    if (!isNaN(val) && reg.test(attr)) {\r\n        ele.style[attr] = val + \"px\";\r\n        return;\r\n    }\r\n    ele.style[attr] = val;\r\n}\r\n```\r\n使用：\r\n```js\r\nlet box = document.querySelector(\"#box\");\r\nanimates(box, {left: 500}, 3000);\r\n```","timestamp":1585877701769},{"name":"01-AJAX简介与使用.md","path":"001-前端/08-JavaScript/004-异步编程/01-Ajax/01-AJAX简介与使用.md","content":"# AJAX(Asynchronous Javascript And XML（异步 JavaScript 和 XML）)\r\n>一种创建交互式网页应用的网页开发技术,当需要从服务器获取数据，并刷新页面的操作，如果不采用AJAX，则需要用提交整个表单的方式，当提交表单时，发送请求给服务器，页面需要等待服务器发送完response后，页面才能恢复操作。\r\n> 而`Ajax`是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\r\n\r\n**Ajax的唯一功能：发送数据和接收数据**\r\n\r\n#### Aajx原理：\r\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\r\n![Ajax原理图](assets/004/01/01-1544410570000.png)\r\n\r\n#### 应用场景\r\n1. 对数据进行过滤和操纵相关数据的场景\r\n2. 添加/删除树节点\r\n3. 添加/删除列表中的某一行记录\r\n4. 切换下拉列表item\r\n5. 注册用户名重名的校验\r\n\r\n\r\n## Ajax使用方法\r\n![Ajax的运行](assets/004/01/004-ajax.jpg)\r\n\r\n#### 1. 实例化ajax对象 new XMLHttpRequest()\r\n#### 2. open() 用于配置请求\r\n\r\n  |参数|值|\r\n  |:----:|:----:|\r\n  |request-type|发送请求的类型,典型的值是 GET 或 POST，默认为GET |\r\n  |url|要连接的 URL|\r\n  |asynch|如果希望使用异步连接则为 true，否则为 false。该参数是可选的，默认为 true|\r\n  |username|如果需要身份验证，则可以在此指定用户名。该可选参数没有默认值|\r\n  |password|如果需要身份验证，则可以在此指定口令。该可选参数没有默认值|\r\n\r\n> * 同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事\r\n> * 异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕\r\n\r\n\r\n#### 3. send() 用于发送请求\r\n```\r\n  * GET方式：如果不需要通过 send() 传递数据，则只要传递 null 作为该方法的参数即可，将传递的数据放在url地址后面进行传递。\r\n  * POST方式：**需要先设置请求头信息**，然后将需要发送的数据放到send()的参数中进行发送。 (注：头部的设置必须在open()和send()之间)\r\n```\r\n\r\n```javascript\r\n// GET方式：\r\nxhr.open(url+\'?name=zhangsan&pwd=123456\')\r\nxhr.send(null);\r\n\r\n// POST方式：\r\nxhr.open(url)\r\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\r\nxhr.send(\'name=zhangsan&pwd=123456\');\r\n```\r\n#### 4. onreadystatechange\r\n  * 每次Ajax请求状态改变时都会触发这个事件\r\n  * readyState： 请求的状态。有5个可取值\r\n\r\n  |值|含义|\r\n  |:----:|:----:|\r\n  |0|（未初始化）还没有调用send()方法|\r\n  |1|（正在载入）已调用send()方法，正在发送请求|\r\n  |2|（载入完成）send()方法执行完成，已经接收到全部响应内容 |\r\n  |3|（交互中）正在解析响应内容 |\r\n  |4|（完成）响应内容解析完成，可以在客户端调用了|\r\n\r\n##### 5. status\r\n当`readyState` 的值为4的时候，说明我们和服务器的交互是成功的，但是如何判断页面返回的数据是成功的呢？我们需要再来检测一下服务器的HTTP状态码，状态码保存在一个属性`status`上\r\n\r\n  |值|含义|\r\n  |:----:|:----:|\r\n  |200|OK 一切正常|\r\n  |304|Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用|\r\n  |404|Not Found 无法找到指定位置的资源|\r\n  |5xx|服务器错误|\r\n\r\n[HTTP状态码详解](https://blog.csdn.net/q1056843325/article/details/53147180)\r\n\r\n 1. 响应\r\n     * response 响应实体的类型由 responseType 来指定， 可以是 ArrayBuffer， Blob， Document， JavaScript 对象 (即 \"json\")， 或者是字符串。如果请求未完成或失败，则该值为 null。\r\n     * responesType 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。\r\n     * responseText 此次请求的响应为文本，或是当请求未成功或还未发送时为 null。\r\n     * responseXML 本次请求的响应是一个 Document 对象，如果是以下情况则值为 null：请求未成功，请求未发送，或响应无法被解析成 XML 或 HTML。当响应为text/xml 流时会被解析。\r\n\r\n 2.  upload\r\n 可以在 upload 上添加一个事件监听来跟踪上传过程。\r\n\r\n> ajax对象和upload对象拥有相同的事件\r\n\r\n|事件|含义|\r\n|:----:|:-----:|\r\n|onabort|当发生中止事件时触发的事件|\r\n|onerror|当发生加载错误是触发的事件|\r\n|onload|当加载结束后触发的事件，不论成功与否|\r\n|onloadend|加载结束后触发的事件|\r\n|onloadstart|当加载开始时触发的事件|\r\n|onprogress|在加载过程中不断触发的事件|\r\n|ontimeout|加载超时后执行的事件|\r\n\r\n```javascript\r\n xhr.upload.onprogress=function(e){\r\n //获取当前上传进度传递到progress中显示\r\n progress.value=parseInt(e.loaded/e.total*100)\r\n}\r\n```\r\n## get和post的区别\r\n* 功能\r\n  *  get是从服务器上获取数据 (查)\r\n  *  post是向服务器传送数据，用于创建资源 (增)\r\n* 数据量\r\n  * get受限于浏览器url长度，IE对URL长度的限制是2083字节(2K+35)，其他浏览器的限制取决于操作系统的支持\r\n  * post传送的数据量较大，一般被默认为不受限制\r\n* 安全性\r\n  * **GET方式请求的数据会被浏览器缓存起来**，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。\r\n  * POST方式相对来说就可以避免这些问题。\r\n\r\n\r\n若符合下列任一情况，则用`POST`方法：\r\n\r\n* 请求的结果有持续性的副作用，例如，数据库内添加新的数据行。\r\n* 若使用GET方法，则表单上收集的数据可能让URL过长。\r\n* 要传送的数据不是采用7位的ASCII编码。\r\n\r\n若符合下列任一情况，则用`GET`方法：\r\n\r\n* 请求是为了查找资源，HTML表单数据仅用来帮助搜索。\r\n* 请求结果无持续性的副作用，如进行搜索。\r\n* 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。\r\n","timestamp":1585877701769},{"name":"02-AJAX的封装、案例.md","path":"001-前端/08-JavaScript/004-异步编程/01-Ajax/02-AJAX的封装、案例.md","content":"## Ajax 封装\r\n```js\r\n// 兼容实例化一个ajax对象\r\nfunction newAjax(){\r\n    var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(\"Miscrosoft.XMLHTTP\")\r\n    return xhr;\r\n}\r\n\r\n//ajax函数\r\n  //1. type:方式 \"get\" \"post\"\r\n  //2. url:地址 url \"demo.php\"\r\n  //3.data:数据  \"id=0&name=zhangsan\"\r\n  //4.asynch:是否异步  true  false\r\n  //5.dataType:返回数据的格式 \"text\" \"json\" \"xml\"\r\n  //6.success返回数据之后进行的操作  function(){}\r\nfunction ajax(options){\r\n    //没有url 直接退出\r\n    if(!options.url){\r\n        alert(\'请输入URL\');\r\n        return;\r\n    }\r\n    var type = options.type || \'GET\';\r\n    var async = options.async==undefined?true:options.async;\r\n    var dataType = options.dataType || \'text\';\r\n    var dataStr = \"\";\r\n    if(options.data){\r\n        if(typeof options.data==\'string\'){\r\n            dataStr = options.data;\r\n        }else{\r\n            //{user:123,pwd:456}\r\n            for(var i in options.data){\r\n                 dataStr+= i+\'=\'+options.data[i]+\'&\'\r\n                //user=123&pwd=456&\r\n            }\r\n            dataStr = dataStr.slice(0,-1)\r\n        }\r\n    }\r\n    //dataStr = \"user=123&pwd=456\"\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    if(type.toUpperCase() ==\'GET\'){\r\n        if(dataStr){\r\n            xhr.open(\'GET\',options.url+\'?\'+dataStr,async);\r\n        }else{\r\n            xhr.open(\'GET\',options.url,async);\r\n        }\r\n        xhr.send();\r\n    }\r\n    if(type.toUpperCase() ==\'POST\'){\r\n        xhr.open(\'POST\',options.url,async);\r\n        xhr.setRequestHeader(\'Content-Type\',\'application/x-www-form-urlencoded;charset=utf-8\');\r\n        xhr.send(dataStr);\r\n    }\r\n    xhr.onreadystatechange = function(){\r\n        if(xhr.readyState==4){\r\n            if(xhr.status==200){\r\n                if(dataType==\'text\'){\r\n                    options.success&&options.success(xhr.response);\r\n                }else if(dataType==\'xml\'){\r\n                    options.success&&options.success(xhr.responseXML);\r\n                }else if(dataType==\'json\'){\r\n                    options.success&&options.success(JSON.parse(xhr.response));\r\n                }\r\n            }else if(xhr.status ==404){\r\n                alert(\'请求失败\');\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n## ajax大规模数据处理\r\n> 假设ajax要请求一条长度10000的数据并渲染,首先由于数据量大ajax请求花费事件会很长,并且前台在处理该数据时也会花费大量事件导致页面长时间留白。所以在请求大规模数据时有以下几种处理方法：\r\n\r\n### 1. 数据分页\r\n将大量的数据进行分页展示，每次只获取当前页的数据，则数据的请求和处理会更快。\r\n\r\n所以在发送ajax请求时就需要携带分页的参数，一个分页器一般包含`数据总条数`、`总页数`、`当前页码`、`每页数据条数`等数据。其中**当前页码**、**每页条数**需要在发送请求时携带，每当切换页码时重新携带当前页码和每页条数发送请求。\r\n\r\n而后台需要返回**当前页数据**，以及**数据总条数**，前台即可根据`数据总条数`及`每页数据条数`计算出`总页数`进行页面渲染。\r\n\r\n```js\r\nvar currentPage = 2,   // 当前页码\r\n    pageSize = 20;     // 每页数据条数   \r\najax({\r\n    url: \"\",\r\n    data:{\r\n        currentPage,  \r\n        pageSize,   \r\n    },\r\n    success(data){\r\n        var pageCount = Math.ceil(data.total / pageSize)   // 总数据条数total / 每页数据数pageSize   向上取整，即可求出总页数pageCount\r\n    }\r\n})\r\n```\r\n\r\n### 2. 分批次请求\r\n当前台不能进行分页时，大规模数据的请求可采用分批次的请求。如10000条数据，第一次请求100条数据（这样用户就很快看到有页面出来），剩余的数据，通过ajax分多次请求给客户端。（这里相当于：用户的一个请求结果，被切割成多次请求来完成）\r\n\r\n例如先展示100条数据，剩余数据按需(上拉或者触底)加载\r\n\r\n\r\n\r\n## 文件上传\r\n### 1. form文件上传\r\n> 上传图片必须为`POST`方式，并且设置编码方式`enctype=\"multipart/form-data\"`，否则会默认对文件进行编码则无法使用                \r\nenctype这个属性管理的是表单的MIME编码，有三个值，默认为`application/x-www-form-urlencoded`，是传递html代码的编码类型。`text/plain`,是纯文本传输的意思。`multipart/form-data`,是用来指定传输数据的特殊类型的，主要就是我们上传的非文本的内容，比如图片或者mp3等等。    \r\n\r\n```html\r\n<form action=\"\" method=\"POST\" enctype=\"multipart/form-data\">\r\n    <input type=\"file\" name=\"file\">\r\n</form>\r\n```\r\n\r\n### 2. Ajax上传文件\r\n> Ajax上传文件需要依靠表单对象`FormData`，在表单对象中添加数据进行上传    \r\n\r\n表单对象`FormData`的作用\r\n* 将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。\r\n* 异步上传文件    \r\n兼容性：Chrome 7+、Firefox 4+、IE 10+、Opera 12+、Safari 5+。\r\n\r\n#### formData对象\r\n实例化formData，来得到这个对象                             \r\n\r\n参数为form，一个HTML表单元素，可以包含任何形式的表单控件，包括文件输入框，是一个可选参数\r\n\r\n```js\r\nvar formData = new FormData();   \r\n```\r\n通过HTML表单创建FormData对象\r\n```js\r\nvar formData = new FormData(document.querySelector(\"form\"));   //包含了form表单里的数据\r\n```\r\n##### 方法\r\n* 通过append(name,value,filename)在数据末尾追加数据，参数值有三个,第三个为可选参数\r\n```js\r\nformdata.append(\"name\",\"laoliu\");   //通过append()方法在末尾追加key为name值为laoliu的数据\r\n```\r\n* 通过get(name)来获取相对应的值\r\n```js\r\n// 获取key为age的值\r\nformdata.get(\"age\");\r\n```\r\n* 通过set(key, value)来设置修改数据（key的值不存在，会添加一条数据）\r\n```js\r\nformdata.set(\"name\",\"laoli\");     \r\n```\r\n* 通过has(key)来判断是否存在对应的key值   返回一个布尔值\r\n```js\r\nformdata.has(\"name\")     \r\n```\r\n* 通过delete(key)可以删除数据\r\n```js\r\n//删除key为name的值\r\nformdata.delete(\"name\");\r\n```\r\n\r\n#### Ajax+FormData对象上传文件\r\n```js\r\nvar fileTag = document.querySelector(\"input[type=file]\");\r\n file.onchange=function(){\r\n    // 图片会保存到 标签的files属性中，并且可读取文件的名称、大小等信息\r\n    var fd = new FormData();\r\n    // 添加图片，字段名叫 files\r\n    fd.append(\'files\', fileTag.files[0]);\r\n    // 添加普通字段\r\n    fd.append(\"user\", \"zhangsan\");\r\n    fd.append(\"age\", 22); //数字22会被立即转换成字符串 \"22\"\r\n    // ...ajax代码\r\n    xhr.send(fd)\r\n    // ...ajax代码\r\n }\r\n```\r\n\r\n## 轮询\r\n> 原理： 每隔一段时间执行ajax请求，获取实时数据\r\n\r\n例：访问实时金价、实时停车等数据\r\n\r\n实现方式：在时间函数`setInterval`中进行ajax请求\r\n","timestamp":1585877701769},{"name":"04-同源策略和跨域.md","path":"001-前端/08-JavaScript/004-异步编程/01-Ajax/04-同源策略和跨域.md","content":"# 同源策略\r\n## 什么是同源\r\n> 源（origin）是指协议、域名和端口号。若地址里面的协议、域名和端口号均相同则属于同源。三者有一个不相同则代表着不同源  \r\n\r\n相对于http://www.baoyukun.com/index.html做同源检测\r\n* http://www.baoyukun.com/test/a.html    同源\r\n* https://www.baoyukun.com/index.html    协议不同\r\n* http://www.aaa.com/index.html          主机名不同\r\n* http://www.baoyukun.com:8080/index.html     端口号不同\r\n\r\n### IE 例外\r\n1. 两个相互之间高度互信的域名，不遵守同源策略的限制。\r\n2. IE 未将端口号加入到同源策略的组成部分之中\r\n\r\n\r\n\r\n## 同源策略\r\n>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的。\r\n\r\n# 跨域\r\n## 跨域限制的必要性\r\n>上面提到浏览器的同源策略是为了安全。跨域主要存在两方面安全问题\r\n\r\n1. DOM 同源策略                  \r\n我们用一个iframe把银行的网站嵌套在我们的网页上，这样的话，我们的网站和银行的网站除了域名没有其他的区别，如果没有同源策略，用户操作网页，我们就可以通过我们自己的网站跨域来访问银行的dom节点，从而拿到用户的信息。\r\n2. XMLHttpRequest 同源策略       \r\n用户访问银行的网站，银行在用户的客户端中cookie中添加标识。用户再访问恶意网站，如果没有同源策略，恶意网站就会向银行网站发送恶意的ajax请求，请求会把银行给用户cookie中添加的标识发送过去，银行网站识别到正确的cookie返回请求数据，这样数据就会泄漏\r\n\r\n## 跨域问题的解决办法\r\n### jsonp（与json并没有什么关系）\r\n在a.com的html页面里创建一个回调函数fun，动态添加`<script>`元素，向服务器发送请求，请求地址后面加上查询字符串，通过callback参数指定回调函数的名字。请求地址为`http://b.com/main.js?callback=fun`。在main.js中调用这个回调函数fun，并且以JSON数据形式作为参数传递，在a.com通过调用fun中接收参数。   \r\n>利用script标签没有跨域限制的特点\r\n\r\n#### 缺点\r\n1. 只能使用GET请求\r\n2. 不能很好的发现错误，并进行处理。\r\n\r\n### 服务器代理\r\n服务器端不存在跨域的问题，所以可以用服务器代理的方式来解决跨域问题。    \r\n让自己的服务器去访问另一个服务器，然后再把数据从我们自己的服务器上返回到页面。    \r\nA客户端（浏览器） ==> A服务器 ==> B服务器 ==> A客户端（浏览器）\r\n\r\n### CORS 的实现\r\n>CORS（跨源资源共享）是一个系统，由传输HTTP标头组成，用于确定浏览器是否阻止前端JavaScript代码访问跨源请求的响应。\r\n\r\n```js\r\nAccess-Control-Allow-Origin: http://www.xxx.com      //允许从http://www.xxx.com源请求代码来访问资源。 *代表允许所有的\r\nAccess-Control-Allow-Methods：PUT,POST,GET,DELETE,OPTIONS       //允许哪些请求方法\r\nAccess-Control-Allow-Headers：<header-name> [，<header-name> ] *   //请求需要具有的标头\r\n```\r\n\r\n\r\n### window.name+iframe\r\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。    \r\n在我们的当前页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取数据页面的数据，并把数据存放到window.name上，然后我们的当前页面再去得到iframe获取到的数据。\r\n\r\n### window.postMessage(message,targetOrigin)\r\nhtml5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。        \r\n调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。             \r\n需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。\r\n","timestamp":1585877701769},{"name":"02-Promise.md","path":"001-前端/08-JavaScript/004-异步编程/02-Promise.md","content":"## Promise\r\n### 兼容\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=promises\" frameborder=\"0\"></iframe>\r\n\r\n### 使用场景\r\n执行代码的时候，下次执行的代码需要依赖上次代码执行的结果，只能将第二次的代码放到第一次代码执行成功之后的回调函数中，导致回调函数的多次嵌套\r\n\r\n例如当进行ajax请求时，下次ajax请求需要依赖上次请求的结果，只能将第二次的ajax请求放在第一次的success函数中，容器嵌套过多\r\n\r\n```js\r\najax({\r\n\turl:\"1.txt\",\r\n\tsuccess(res){\r\n\t\t// 第一个ajax结束\r\n\t\tvar str1 = res\r\n\t\tajax({\r\n\t\t\turl:\"2.txt\",\r\n\t\t\tsuccess(res){\r\n\t\t\t\t// 第二个ajax结束\r\n\t\t\t\tvar str2 = res\r\n\t\t\t\tajax({\r\n\t\t\t\t\turl:\"3.txt\",\r\n\t\t\t\t\tsuccess(res){\r\n\t\t\t\t\t\t// 第三个ajax结束\r\n\t\t\t\t\t\tvar str3 = res\r\n\r\n\t\t\t\t\t\tconsole.log(str1+str2+str3)\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n})\r\n```\r\n\r\nPromise 是 ES6 原生支持的，他把原来嵌套的回调改为了级联的方式。\r\n\r\nPromise 主要就是为了解决异步回调的问题。用 Promise 来处理异步回调使得代码层次清晰，便于理解，且更加容易维护。\r\n\r\n### 兼容性\r\nPromise 是 ES6 原生支持的, Promise是新特性，在IE9-11中不支持\r\n```html\r\n通过 CDN 引入es6-promise.auto.js即可在ie中使用Promise：\r\n<script src=\"https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js\"></script>\r\n\r\nNPM\r\n如果使用 npm 包管理器，可以按照下列方式执行安装：\r\n\r\nnpm install es6-promise --save # npm\r\n或者更进一步，将下列代码添加到你使用 Vuex 之前的一个地方：\r\n\r\nimport \'es6-promise/auto\'\r\n```\r\n### 使用\r\n\r\n执行代码后的结果存入Promise实例化出的对象中，调用 该对象的 `than` 函数\r\n\r\n```js\r\nnew Promise(function(resolve,reject){\r\n\r\n    // resolve :函数执行成功调用，  调用之后会执行 then 方法\r\n    // reject ：当函数出现错误，  调用之后会执行 catch 方法\r\n\r\n    resolve(data)\r\n\r\n})\r\n.then(function(data){\r\n    // data 可接收上次resolve发送的数据\r\n    return new Promise(function(resolve,reject){\r\n      resolve(data2)\r\n  })\r\n})\r\n.then(function(data2){\r\n    //data2 接收上次return的数据\r\n})\r\n.catch(function(){\r\n    // 当请求出错时，会触发catch方法\r\n})\r\n.finally(function(){\r\n    // 无论函数执行结果如何都会执行 finally函数\r\n})\r\n\r\n```\r\n\r\n#### Promise 函数内部状态\r\n1. pending   进行中\r\n2. resolved  已完成   ( fulfilled )\r\n3. rejected   失败\r\n\r\n> Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获\r\n\r\n## 注意事项\r\n1. reject方法的作用，等同于抛出错误。\r\n2. 如果 Promise 状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。\r\n3. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\r\n4. then可以接收两个参数，成功和失败。  但是失败只能捕获本次的错误\r\n5. Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误，Promise可以“吃掉”错误\r\n6. catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法\r\n\r\n### Promise 对象方法\r\n#### then 方法：\r\nPromise异步函数结束之后，调用then方法\r\n#### catch 方法：\r\n当Promise 异步函数 出现错误，会调用catch方法\r\n#### finally 方法：\r\n无论成功 失败都会执行 finally 方法\r\n\r\n#### Promise.all 方法\r\n可以将多个Promise对象包装成一个新的 Promise 实例。 (并行)\r\n\r\n* Promise.all方法接受一个数组作为参数，参数必须都是 Promise 对象\r\n* 只有 参数 的状态都变成fulfilled，Promise.all 对象的结果才为fulfilled\r\n* Promise.all 对象可以接收每个 参数的返回值\r\n\r\n```js\r\nPromise.all([p1,p2]).then(([end1,end2])=>{\r\n    console.log(\"全部已完成\")\r\n}).catch(()=>{\r\n});\r\n```\r\n#### Promise.race 方法\r\n可以将多个Promise对象包装成一个新的 Promise 实例。\r\n\r\n* Promise.race方法接受一个数组作为参数，参数必须都是 Promise 对象\r\n* 只要参数之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数\r\n\r\n#### Promise.resolve 方法\r\n将任意数据变为变为 Promise 对象，如果其已经时Promise对象，则无任何操作。\r\n","timestamp":1585877701769},{"name":"03-Generator函数.md","path":"001-前端/08-JavaScript/004-异步编程/03-Generator函数.md","content":"# Generator 函数\r\n\r\n## 简介\r\n### 基本概念\r\nGenerator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。\r\n\r\nGenerator函数有多种理解角度。语法上，首先可以把它理解成Generator函数是一个状态机，封装了多个内部状态。\r\n\r\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\r\n\r\n### Generator函数语法\r\n形式上，Generator函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号；二是,函数体内部使用`yield`表达式，定义不同的内部状态(yield在英语里的意思就是\'产出\')。\r\n```js\r\nfunction* helloGenerator(){\r\n    yield \'hello\';\r\n    yield \'world\';\r\n    return \'ending\';\r\n}\r\nvar hello = helloGenerator();\r\n```\r\n### Generator 函数的调用\r\nGenerator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。\r\n\r\n接下来，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\r\n```js\r\nvar hello = helloGenerator();\r\nhello.next()\r\n// { value: \'hello\', done: false }\r\n\r\nhello.next()\r\n// { value: \'world\', done: false }\r\n\r\nhello.next()\r\n// { value: \'ending\', done: true }\r\n\r\nhello.next()\r\n// { value: undefined, done: true }\r\n```\r\n调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。\r\n\r\nES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。\r\n```js\r\nfunction * foo(x, y) { ··· }\r\nfunction *foo(x, y) { ··· }\r\nfunction* foo(x, y) { ··· }\r\nfunction*foo(x, y) { ··· }\r\n```\r\n由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。\r\n\r\n## yield 表达式\r\n由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\r\n\r\n遍历器对象的next方法的运行逻辑如下。\r\n\r\n1. 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\r\n- 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\r\n- 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\r\n- 如果该函数没有return语句，则返回的对象的value属性值为undefined。\r\n\r\n需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\r\n```js\r\nfunction* gen() {\r\n  yield  123 + 456;\r\n}\r\n```\r\n上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。\r\n\r\nyield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值\r\n","timestamp":1585877701769},{"name":"04-async函数.md","path":"001-前端/08-JavaScript/004-异步编程/04-async函数.md","content":"# async函数\r\n## 什么是async函数\r\n>async函数就是 Generator 函数的语法糖，对比Generator函数和async来看\r\n\r\n```js\r\n//Generator函数依次读取两个文件\r\nvar fs = require(\'fs\');\r\nvar readFile = function (fileName){\r\n return new Promise(function (resolve, reject){\r\n  fs.readFile(fileName, function(error, data){\r\n   if (error) reject(error);\r\n   resolve(data);\r\n  });\r\n });\r\n};\r\nvar gen = function* (){\r\n var f1 = yield readFile(\'/etc/fstab\');\r\n var f2 = yield readFile(\'/etc/shells\');\r\n console.log(f1.toString());\r\n console.log(f2.toString());\r\n};\r\n\r\n//把它改写成async函数\r\nvar asyncReadFile = async function (){\r\n var f1 = await readFile(\'/etc/fstab\');\r\n var f2 = await readFile(\'/etc/shells\');\r\n console.log(f1.toString());\r\n console.log(f2.toString());\r\n};\r\n```\r\nasync 函数就是将 Generator 函数的星号（`*`）替换成 async，将 yield 替换成 await，仅此而已。\r\n\r\n## async函数对比generator的优点\r\n1. 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\r\n2. 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\r\n3. 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\r\n4. 返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。用then方法指定下一步的操作。\r\n\r\n## async 函数的用法\r\n>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。\r\n\r\n```js\r\nfunction timeout(ms) {\r\n return new Promise((resolve) => {\r\n  setTimeout(resolve, ms);\r\n });\r\n}\r\nasync function asyncPrint(value, ms) {\r\n  await console.log(1111111);\r\n  await timeout(ms);\r\n  await console.log(2222222);\r\n  console.log(value)\r\n}\r\nasyncPrint(\'hello world\', 50);\r\n```\r\n\r\n### async函数的多种使用方法\r\n```js\r\n// 函数声明\r\nasync function foo() {}\r\n// 函数表达式\r\nconst foo = async function () {};\r\n// 对象的方法\r\nlet obj = { async foo() {} };\r\nobj.foo().then(...)\r\n// Class 的方法\r\nclass Storage {\r\n  constructor() {\r\n    this.cachePromise = caches.open(\'avatars\');\r\n  }\r\n  async getAvatar(name) {\r\n    const cache = await this.cachePromise;\r\n    return cache.match(`/avatars/${name}.jpg`);\r\n  }\r\n}\r\nconst storage = new Storage();\r\nstorage.getAvatar(\'jake\').then(…);\r\n// 箭头函数\r\nconst foo = async () => {};\r\n```\r\n\r\n## async函数使用注意\r\n1. await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\r\n```js\r\nasync function myFunction() {\r\n try {\r\n  await somethingThatReturnsAPromise();\r\n } catch (err) {\r\n  console.log(err);\r\n }\r\n}\r\n// 另一种写法\r\nasync function myFunction() {\r\n await somethingThatReturnsAPromise().catch(function (err){\r\n  console.log(err);\r\n });\r\n}\r\n```\r\n2. await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。\r\n3. 两个相互不依赖的异步操作同时触发\r\n\r\n```js\r\nlet foo = await getFoo();\r\nlet bar = await getBar();\r\n\r\n//让getFoo和getBar同时触发\r\n// 写法一\r\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\r\n\r\n// 写法二\r\nlet fooPromise = getFoo();\r\nlet barPromise = getBar();\r\nlet foo = await fooPromise;\r\nlet bar = await barPromise;\r\n```\r\n\r\n## async函数实现的原理\r\nasync 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。\r\n```js\r\nasync function fn(args){\r\n // ...\r\n}\r\n// 等同于\r\nfunction fn(args){\r\n return spawn(function*() {\r\n  // ...\r\n });\r\n}\r\n```\r\n所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。<br/>\r\n下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。\r\n```js\r\nfunction spawn(genF) {\r\n return new Promise(function(resolve, reject) {\r\n  var gen = genF();\r\n  function step(nextF) {\r\n   try {\r\n    var next = nextF();\r\n   } catch(e) {\r\n    return reject(e);\r\n   }\r\n   if(next.done) {\r\n    return resolve(next.value);\r\n   }\r\n   Promise.resolve(next.value).then(function(v) {\r\n    step(function() { return gen.next(v); });   \r\n   }, function(e) {\r\n    step(function() { return gen.throw(e); });\r\n   });\r\n  }\r\n  step(function() { return gen.next(undefined); });\r\n });\r\n}\r\n```\r\nasync 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。\r\n","timestamp":1585877701769},{"name":"05-fetch.md","path":"001-前端/08-JavaScript/004-异步编程/05-fetch.md","content":"# Fetch\r\n\r\n> 在开发过程中,我们向服务端发送请求,一般会使用三种方式, `XMLHttpRequest(XHR)`、`Fetch` 、`jQuery实现的AJAX`。\r\n\r\n1. `XMLHttpRequest`不符合关注分离,配置和调用方式比较混乱，还需要兼容于多层回调\r\n2. `jQuery实现的AJAX`兼容性和易用性方面都做了很大的提高，并支持jsonp，但仍存在回调地狱\r\n3. `fetch`是现代浏览器新增的的一种发送请求方式，用以替代ajax\r\n\r\n\r\n## 兼容性\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=fetch\" frameborder=\"0\"></iframe>\r\n\r\nFetch API是基于Promise设计，部分老浏览器不支持fetch，旧浏览器不支持 Promise，需要使用如下兼容可兼容到ie8:\r\n\r\n1. 引入 es6 的 polyfill: `babel-polyfill`\r\n2. 引入 promise 的 polyfill: `es6-promise` (参考Promise章节)\r\n3. 引入 fetch 探测库：`fetch-detector`\r\n4. 引入 fetch 的 polyfill: `fetch-ie8`\r\n5. 可选：如果你还使用了 jsonp，引入 `fetch-jsonp`\r\n\r\n### npm 命令行安装：\r\n```shell\r\nnpm install babel-polyfill es6-promise fetch-detector fetch-ie8 --save\r\n```\r\njs导入：\r\n```js\r\nimport \'babel-polyfill\';\r\nrequire(\'es6-promise\').polyfill();\r\nimport \'fetch-detector\';\r\nimport \'fetch-ie8\';\r\n```\r\n**注意**： fetch-detector 一定要在 fetch-ie8 之前引入\r\n\r\n### ie重新封装fetch\r\n\r\n\r\n\r\n## 使用方式\r\nfetch() 接收两个参数 —— 请求资源的路径和配置信息。无论请求成功与否，它都返回一个`promise`对象\r\n\r\n```js\r\nfetch(url, options)\r\n.then(res=>{\r\n    // handle HTTP response\r\n}, error=>{\r\n    // handle network error\r\n})\r\n```\r\n\r\n### 参数说明：\r\n1. `url`：请求资源的路径 (必填)\r\n2. `options`： 请求配置信息\r\n\r\n| 配置项 | 数据类型 | 功能说明 |\r\n| --- | --- | --- |\r\n| method | String | HTTP请求方法，默认为`GET` |\r\n| body | String | HTTP的请求参数 |\r\n| headers  | Object  | HTTP的请求头，默认为{} |\r\n| credentials | String  | 默认为`omit`,忽略的意思，也就是不带cookie;还有两个参数，`same-origin`，意思就是同源请求带cookie；`include`,表示无论跨域还是同源请求都会带cookie |\r\n\r\n### 返回值：\r\n第一个`then`函数里面处理的是`response`的格式，这里的`response`具体如下：    \r\n![fetch返回值](assets/005/02-1544519237000.png)\r\n\r\n1. status(number): HTTP返回的状态码，范围在100-599之间\r\n2. statusText(String): 服务器返回的状态文字描述，例如`OK`\r\n3. ok(Boolean): 如果状态码是以2开头的，则为true\r\n4. headers:  HTTP请求返回头\r\n5. body:  返回体，这里有处理返回体的一些方法\r\n\r\n#### 返回体的处理 (获取返回的数据)\r\n* text(): 将返回体处理成字符串类型\r\n* json()： 返回结果和 JSON.parse(responseText)一样\r\n* blob()： 返回一个Blob，Blob对象是一个不可更改的类文件的二进制数据\r\n* arrayBuffer()\r\n* formData()\r\n\r\n> 返回体处理的返回值均为Promise对象，所以后面可继续使用`then()`或`catch()`进行调用\r\n\r\n```js\r\n// 以处理json数据为例：\r\nfetch(url, options)\r\n.then(res=>{\r\n    return res.json()\r\n}\r\n.then(data=>{\r\n    console.log(data)\r\n})\r\n```\r\n\r\n\r\n\r\n\r\n### 设置请求头信息\r\n> 在POST提交的过程中，一般是表单提交，可是，经过查询，发现默认的提交方式是：`Content-Type:text/plain;charset=UTF-8`，这个显然是不合理的。\r\n\r\n```js\r\n// 通过fetch获取百度的错误提示页面\r\nfetch(\'https://www.baidu.com/rec?platform=wise&ms=1&rset=rcmd&word=123&qid=11327900426705455986&rq=123&from=844b&baiduid=A1D0B88941B30028C375C79CE5AC2E5E%3AFG%3D1&tn=&clientWidth=375&t=1506826017369&r=8255\', { // 在URL中写上传递的参数\r\n    method: \'GET\',\r\n    headers: {\r\n        \'Content-Type\': \'application/x-www-form-urlencoded\', // 指定提交方式为表单提交\r\n        \'Accept\': \'application/json\' // 通过头指定，获取的数据类型是JSON\r\n    },\r\n  })\r\n  .then((res)=>{\r\n    return res.json() // 返回一个Promise，可以解析成JSON\r\n  })\r\n  .then((res)=>{\r\n    console.log(res) // 获取JSON数据\r\n  })\r\n```\r\n\r\n### 携带cookie\r\n> 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于维护一个用户会话，则导致未经认证的请求(要发送 cookies，必须发送凭据头)\r\n\r\n```js\r\n// 通过fetch获取百度的错误提示页面\r\nfetch(\'https://www.baidu.com/search/error.html\', {\r\n    method: \'GET\',\r\n    credentials: \'include\' // 强制加入凭据头\r\n})\r\n.then((res)=>{\r\n    return res.json()\r\n})\r\n.then((res)=>{\r\n    console.log(res)\r\n})\r\n```\r\n\r\n### 错误处理\r\n> fetch在服务器返回`4xx`、`5xx`时是不会抛出错误的，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。这里需要手动通过，通过`response`中的ok字段和`status`字段来判断\r\n\r\n```js\r\nfetch(\'url\')\r\n.then(res => {\r\n    if (res.ok) {\r\n        return res.json()\r\n    } else {\r\n        // 抛出异常\r\n        throw new Error(\'something went wrong!\')\r\n\r\n        // 或者rejectPromise来调用catch\r\n        return Promise.reject({\r\n            status: res.status,\r\n            statusText: res.statusText\r\n        })\r\n    }\r\n})\r\n.then(data => console.log(data))\r\n.catch(error => console.log(error));\r\n```\r\n\r\n### 文件上传：\r\n```js\r\nconst input = document.querySelector(\'input[type=file]\');\r\n\r\n// This will upload the file after having read it\r\nconst upload = (file) => {\r\n  fetch(\'http://www.example.net\', { // Your POST endpoint\r\n    method: \'POST\',\r\n    headers: {\r\n      \"Content-Type\": \"You will perhaps need to define a content-type here\"\r\n    },\r\n    body: file // This is your file object\r\n  }).then(\r\n    response => response.json() // if the response is a JSON object\r\n  ).then(\r\n    success => console.log(success) // Handle the success response object\r\n  ).catch(\r\n    error => console.log(error) // Handle the error response object\r\n  );\r\n};\r\n\r\n// Event handler executed when a file is selected\r\nconst onSelectFile = () => upload(input.files[0]);\r\n\r\n// Add a listener on your input\r\n// It will be triggered when a file will be selected\r\ninput.addEventListener(\'change\', onSelectFile, false);\r\n```\r\n\r\n\r\n\r\n### fetch 封装\r\n\r\n\r\n> 参考资料： [使用Fetch](https://www.cnblogs.com/libin-1/p/6853677.html)\r\n> 参考资料： [fetch，终于认识你](https://segmentfault.com/a/1190000011433064)\r\n","timestamp":1585877701769},{"name":"01-严格模式.md","path":"001-前端/08-JavaScript/005-js扩展/01-严格模式.md","content":"# 严格模式(use strict)\r\nJavaScript 严格模式（strict mode）即在严格的条件下运行。\r\n\r\n## 使用严格模式\r\n> \"use strict\" 指令只允许出现在脚本或函数的开头。\r\n\r\n### 使用 \\\"use strict\\\"指令\r\n\"use strict\" 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。\r\n\r\n\"use strict\" 的目的是指定代码在严格条件下执行。例如：严格模式下你不能使用未声明的变量。\r\n\r\n### 浏览器支持情况\r\n\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=stricttransportsecurity\" frameborder=\"0\"></iframe>\r\n\r\n\r\n### 为什么使用严格模式\r\n消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\r\n- 消除代码运行的一些不安全之处，保证代码运行的安全；\r\n- 提高编译器效率，增加运行速度；\r\n- 为未来新版本的Javascript做好铺垫。\r\n\r\n\"严格模式\"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。\r\n\r\n另一方面，同样的代码，在\"严格模式\"中，可能会有不一样的运行结果；一些在\"正常模式\"下可以运行的语句，在\"严格模式\"下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。\r\n\r\n## 严格模式的限制\r\n不允许使用未声明的变量：\r\n```\r\n\"use strict\"\r\nx = 100;   // 报错 x 未定义\r\n```\r\n\r\n不允许删除变量或对象：\r\n```\r\n\"use strict\"\r\nvar pi = 3.1415;\r\ndelete pi; // 报错\r\n\r\nvar o = {};\r\ndelete o;  // 报错\r\n```\r\n\r\n不允许变量重名:\r\n```\r\n\"use strict\";\r\nfunction x(p1, p1) {};   // 报错\r\n```\r\n\r\n不允许使用八进制:\r\n```\r\n\"use strict\";\r\nvar x = 010;             // 报错\r\n```\r\n\r\n不允许使用转义字符:\r\n```\r\n\"use strict\";\r\nvar x = \\010;            // 报错\r\n```\r\n\r\n不允许删除一个不允许删除的属性：\r\n```\r\n\"use strict\";\r\ndelete Object.prototype; // 报错\r\n```\r\n\r\n变量名不能使用 \"eval\"、\"arguments\"\r\n\r\n由于一些安全原因，在作用域 eval() 创建的变量不能被调用：\r\n```js\r\n\"use strict\";\r\neval (\"var x = 2\");\r\nalert (x);               // 报错\r\n```\r\n\r\n禁止this关键字指向全局对象。\r\n```js\r\nfunction f(){\r\n    return !this;\r\n}\r\n// 返回false，因为\"this\"指向全局对象，\"!this\"就是false\r\n\r\nfunction f(){\r\n    \"use strict\";\r\n    return !this;\r\n}\r\n// 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\r\n\r\n\r\nfunction f(){\r\n    \"use strict\";\r\n    this.a = 1;\r\n};\r\nf();// 报错，this未定义\r\n```\r\n\r\n保留关键字,为了向将来Javascript的新版本过渡，严格模式新增了一些保留关键字：\r\n```\r\nimplements、interface、let、package、private、protected、public、static、yield\r\n```\r\n","timestamp":1585877701769},{"name":"02-调试工具.md","path":"001-前端/08-JavaScript/005-js扩展/02-调试工具.md","content":"## 移动端js调试 (vConsole)\r\n> 平时在web应用开发过程中，我们可以`console.log`去输出一些信息，但是在移动端，也就是在手机上，`console.log`的信息我们是看不到的。如果将console.log应用到移动端呢？则需要借助第三方插件：`vConsole`\r\n\r\n> 原理：改写了console.log,重写了实现，用vConsole代理\r\n\r\n[npm官网使用教程](https://github.com/Tencent/vConsole/blob/1eef3bee16ead445cec0264a1111e0912bf1265b/doc/tutorial_CN.md)\r\n\r\n### 安装\r\n\r\n#### 1.下载模块\r\n\r\n下载 vConsole 的[最新版本](https://github.com/WechatFE/vConsole/releases/latest)。\r\n\r\n或者使用 `npm` 安装：\r\n\r\n```\r\nnpm install vconsole\r\n```\r\n\r\n然后复制 `dist/vconsole.min.js` 到自己的项目中。\r\n\r\n#### 2.引入模块\r\n\r\n(1) 如果未使用 AMD/CMD 规范，可直接在 HTML 中引入 vConsole 模块。为了便于后续扩展，建议在 `<head>` 中引入：\r\n\r\n```html\r\n<head>\r\n  <script src=\"path/to/vconsole.min.js\"></script>\r\n  <script>\r\n    var vConsole = new VConsole();\r\n  </script>\r\n</head>\r\n```\r\n\r\n(2) 如果使用了 AMD/CMD 规范，可在 module 内使用 `require()` 引入模块：\r\n\r\n```javascript\r\nvar VConsole = require(\'path/to/vconsole.min.js\');\r\nvar vConsole = new VConsole();\r\n```\r\n\r\n请注意，`VConsole` 只是 vConsole 的原型，而非一个已实例化的对象。所以在手动 `new` 实例化之前，vConsole 不会被插入到网页中。\r\n\r\n\r\n### 使用方法\r\n\r\n#### 初始化 & 配置\r\n\r\n引入后, 需要手动初始化 vConsole：\r\n\r\n```javascript\r\nvar vConsole = new VConsole(option);\r\n```\r\n\r\n`option` 是一个选填的 object 对象，具体配置定义请参阅 [公共属性及方法](https://github.com/Tencent/vConsole/blob/1eef3bee16ead445cec0264a1111e0912bf1265b/doc/public_properties_methods_CN.md)。\r\n\r\n使用 `setOption()` 来更新 `option`：\r\n\r\n```javascript\r\nvConsole.setOption(\'maxLogNumber\', 5000);\r\n// 或者：\r\nvConsole.setOption({maxLogNumber: 5000});\r\n```\r\n\r\n### 打印日志\r\n\r\n与 PC 端打印 log 一致，可直接使用 `console.log()` 等方法直接打印日志：\r\n\r\n```javascript\r\nconsole.log(\'Hello World\');\r\n```\r\n\r\n未加载 vConsole 模块时，`console.log()` 会直接打印到原生控制台中；加载 vConsole 后，日志会打印到页面前端+原生控制台。\r\n\r\n\r\n#### 日志类型\r\n\r\n支持 5 种不同类型的日志，会以不同的颜色输出到前端面板：\r\n\r\n```javascript\r\nconsole.log(\'foo\');   // 白底黑字\r\nconsole.info(\'bar\');  // 白底紫字\r\nconsole.debug(\'oh\');  // 白底黄字\r\nconsole.warn(\'foo\');  // 黄底黄字\r\nconsole.error(\'bar\'); // 红底红字\r\n```\r\n\r\n#### 特殊格式\r\n\r\n支持使用 `[system]` 作为第一个参数，来将 log 输出到 System 面板：\r\n\r\n```javascript\r\nconsole.log(\'[system]\', \'foo\'); // \'foo\' 会输出到 System 面板\r\nconsole.log(\'[system] bar\'); // 这行日志会输出到 Log 面板而非 System 面板\r\n```\r\n\r\n\r\n### 内置插件\r\n\r\n#### Network 网络\r\n\r\n所有 `XMLHttpRequest` 请求都会被显示到 Network tab 中。\r\n\r\n若不希望一个请求显示在面板中，可添加属性 `_noVConsole = true` 到 XHR 对象中：\r\n\r\n```javascript\r\nvar xhr = new XMLHttpRequest();\r\nxhr._noVConsole = true; // 不会显示到 tab 中\r\nxhr.open(\"GET\", \'http://example.com/\');\r\nxhr.send();\r\n```\r\n\r\n[前往：文档索引](https://github.com/Tencent/vConsole/blob/1eef3bee16ead445cec0264a1111e0912bf1265b/doc/a_doc_index_CN.md)\r\n\r\n\r\n\r\n\r\n## 浏览器断点使用\r\n\r\n[js断点调试心得](https://www.cnblogs.com/w10234/p/5441335.html)\r\n\r\n[使用VSCode 断点调试 js项目，html页面](https://blog.csdn.net/arvin0/article/details/53673351)\r\n\r\n\r\n\r\n","timestamp":1585877701769},{"name":"03-ESLint 代码检查.md","path":"001-前端/08-JavaScript/005-js扩展/03-ESLint 代码检查.md","content":"# ESLint 代码检查\r\n在协同开发过程中，每个人都有独立的编码习惯，虽然团队可以通过制定强制执行的规范来保持大家代码风格的尽量一致。但是，在实际编码过程中，个人可能会不经意地继续使用着自己的代码风格，而等到发现不一致再解决又未免有点迟。\r\n\r\n> ESLint是一款当前应用十分广泛的JavaScript代码检查工具，使用 Node.js 编写。ESLint 的初衷是为了让程序员可以创建自己的检测规则，使其可以在编码的过程中发现问题而不是在执行的过程中。\r\n\r\n### 安装 ESLint\r\n如果仅仅想让 ESLint 成为你项目构建系统的一部分，我们可以在项目根目录进行本地安装：\r\n```shell\r\n$ npm install eslint --save-dev\r\n```\r\n\r\n如果想使 ESLint 适用于所有的项目，建议使用全局安装，使用全局安装 ESLint 后，你使用的任何 ESLint 插件或可分享的配置也都必须在全局安装。\r\n\r\n```shell\r\n$ npm install -g eslint\r\n```\r\n\r\n\r\n监测是否下载成功\r\n```shell\r\n$ eslint -v    # v4.15.0\r\n```\r\n\r\n\r\n### 配置\r\n如果我们要使用ESLint来检查自己的日常JavaScript代码，而并非在项目中使用的话，可以使用`eslint --init`命令来在全局生成一个规则配置文件。\r\n\r\n`eslint --init`命令会以命令行选择交互的方式来生成这个规则文件。在输入命令后，会得到如下的结果：\r\n```shell\r\n? How would you like to configure ESLint? (Use arrow keys)\r\n> Answer questions about your style\r\n  Use a popular style guide\r\n  Inspect your JavaScript file(s)\r\n```\r\n1. Answer questions about your style* 通过回答问题来生成规则文件\r\n2. Use a popular style guide* 使用已经配置好的流行的规则(别人推荐的最佳实践)\r\n3. Inspect your JavaScript file(s)* 检查现有的JavaScript文件来自动生成\r\n\r\n\r\n### 检查规则释义\r\n.eslintrc.js文件生成后，rules部分整体是一个json对象。键是规则的名字，值是关于此规则的配置。\r\n\r\n关于每条规则名称的具体含义，我们可以通过其中文意思进行理解，或者查看ESLint官方Rules介绍文档。\r\n\r\n而配置则都由这些值开始：\r\n\r\n    * \"off\" 或者0 - 代表关闭此条规则，即不做关于此规则的检测。\r\n    * \"warn\" 或者 1 - 将此条规则设置为需要进行warning警告的规则，eslint程序的返回码不变。\r\n    * \"error\" 或者 2 - 将此条规则设置为需要进行error报错的规则，eslint程序的返回码将变为1。\r\n\r\n\r\n### 执行检查\r\n**检测单个文件**\r\n```shell\r\n$ eslint yourfile.js\r\n```\r\n**检测多个文件**\r\n```shell\r\n$ eslint foo.js bar.js\r\n```\r\n\r\n**检测目录下所有文件**  \r\n这里可以指定格式，因为ESLint不止可以检查js文件。\r\n```shell\r\n$ eslint your_directory/**.js\r\n```\r\n\r\n**检测目录**\r\n```shell\r\n$ eslint directory_name [directory_name2]\r\n```\r\n\r\n\r\n#### VSCode 中使用ESLint： [VScode格式化ESlint-方法](https://www.jianshu.com/p/23a5d6194a4b)\r\n\r\n> 参考资料：[使用ESLint进行JavaScript代码检查](https://ntnyq.github.io/use-eslint-linter-js-code/)\r\n","timestamp":1585877701769},{"name":"04-模块化开发.md","path":"001-前端/08-JavaScript/005-js扩展/04-模块化开发.md","content":"## 模块化概述\r\n模块化，即将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 例如CSS的`@import`\r\n\r\n\r\nJavaScript原本的模块化可以通过函数或对象实现：\r\n\r\n**函数**： 将几个函数封装到一个文件，需要的时候记载这个文件，调用其中函数即可。  但是这样会污染全局变量，造成命名冲突。\r\n\r\n**对象**： 模块写成一个对象，模块成员都封装在对象里，通过调用对象属性，访问使用模块成员。但同时也暴露了模块成员，外部可以修改模块内部状态。\r\n\r\n\r\n而JavaScript历史上并没有模块体系，无法将一个大程序拆分，对开发大型的、复杂的项目形成了巨大障碍。所以，社区制定了一些模块加载方案，最主要的有 `CommonJS` 和 `AMD` 、`CMD`。\r\n\r\n\r\n> 模块化开发的前提就是所有开发者必须以同样的方式编写模块，否则你有你的写法，我有我的写法，就会乱套，所以出现了四种规范 CommonJS，AMD，CMD，ES6模块化。\r\n\r\n* **CommonJS**: 服务器端模块化，如Node.js\r\n* **AMD**: 浏览器模块化，`RequireJS` 在推广过程中对模块定义的规范化的产出\r\n* **CMD**: 浏览器模块化，国内发展出来的，CMD有个浏览器的实现`SeaJS`，`SeaJS`要解决的问题和`requireJS`一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\r\n* **ES6 Module**: 浏览器模块化，ES6标准的模块化，用以取代 CommonJS 和 AMD 规范。\r\n\r\n\r\n## AMD\r\nAMD规范不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎`RequireJS`。\r\n\r\n它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。\r\n\r\n### 1. 引入require.js文件\r\n```html\r\n<script src=\"https://cdn.bootcss.com/require.js/2.3.6/require.min.js\"></script>\r\n```\r\n\r\n### 2. 模块编写 (define)\r\nrequire.js中，每个模块就是一个js文件。RequireJS定义了一个函数 `define`，它是全局变量，用来定义模块:\r\n\r\n```js\r\ndefine(id?, dependencies?, factory);\r\n```\r\n参数说明：\r\n参数|值|说明\r\n---|---|---\r\nid | string | (可选)模块名称\r\ndependencies| array | (可选)依赖数组,表示该模块所依赖的模块，模块名不需要加js后缀\r\nfactory | array/object | 模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\r\n\r\n\r\n#### 导出模块\r\nrequire.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。\r\n\r\n假定现在顶一个模块`math.js`，如果不需要依赖其他模块，则:\r\n```js\r\ndefine(function(){\r\n    var num = 10;\r\n    function add(a, b){ return a + b };\r\n\r\n    // 声明了两个属性进行导出\r\n    return {\r\n        num,\r\n        add\r\n    }\r\n})\r\n```\r\n#### 导入模块\r\n例子：main.js文件加载两个模块(jquery, math)并在回调函数中使用：\r\n```js\r\n// main.js 文件\r\nrequire([\'jquery\', \'math\'], function ($, math){\r\n    // 回调函数中的math即为刚才导出的{ num, add }\r\n　　alert( math.add(1,2) )   // 3\r\n});\r\n```\r\n\r\n\r\n### 模块加载的配置\r\n上面案例中，引入三个模块(jquery, math)，默认情况下，require.js假定这两个模块与main.js在同一个目录，文件名分别为`jquery.js`和`math.js`，然后自动加载。\r\n\r\n使用`require.config()`方法，可以对模块的加载行为进行自定义:\r\n```js\r\nrequire.config({\r\n    baseUrl: \"./js\",\r\n　　paths: {\r\n　　　　\"jquery\": \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min\",\r\n　　　　\"math\": \"lib/math.min\",    // 省略js后缀\r\n　　}\r\n});\r\n```\r\n| 配置项 | 值 | 说明 |\r\n|---|---|---|\r\n| baseUrl | string | 定义读取模块的根目录|\r\n| paths | object | 定义模块路径与别名，如上例模块路径`lib/math.min`，用`math`指代|\r\n\r\n### 兼容性\r\n![requireJS兼容性](assets/005/04-1545123005000.png)\r\n\r\n\r\n\r\n## CMD\r\nCMD规范是国内发展出来的，CMD的浏览器的实现是`sea.js`，SeaJS与requireJS类似，只不过在模块定义方式和模块加载（运行、解析）时机上有所不同。\r\n\r\n导入：\r\n```html\r\n<script src=\"https://cdn.bootcss.com/seajs/3.0.3/sea.js\"></script>\r\n```\r\n\r\n### CMD 模块编写\r\n在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:\r\n```js\r\ndefine(function(require, exports, module) {\r\n\r\n  // 模块代码\r\n\r\n});\r\n```\r\n|参数|说明|\r\n|---|---|\r\n| require | 可以用来导入其他模块 |\r\n| exports | 可以把该模块内容属性方法导出 |\r\n| module | 一个对象，存储了与当前模块相关联的一些属性和方法 |\r\n\r\n[CMD 模块定义规范 ](https://github.com/seajs/seajs/issues/242)\r\n\r\n#### 定义模块 （define）\r\n```js\r\n// math.js文件\r\ndefine(function(require, exports, module) {\r\n    require(\'./jquery.min.js\')     // require 导入jquery\r\n    $.ajax()\r\n    exports.add = function(a, b){ return a+b };        // export导出函数add\r\n});\r\n```\r\n\r\n#### 导入模块 （seajs.use）\r\n```js\r\nseajs.use([\'./math.js\'], function (math) {\r\n   math.add(1, 2);    // 3\r\n});\r\n```\r\n\r\n#### 配置Sea.js  （ seajs.config() ）\r\n| 配置项 | 值 | 说明\r\n|---|---|---\r\n| base | string | 定义读取模块的根目录\r\n| alias | object | 定义模块路径与别名，如模块路径`../lib/jquery.min.js`，用`jquery`指代\r\n\r\n```js\r\nseajs.config({\r\n    base:\"./js\"  \r\n    alias:{\r\n        \'jquery\':\'../lib/jquery.min.js\'\r\n    }\r\n});\r\n```\r\n\r\n\r\n### AMD 与 CMD 的区别\r\n* AMD是依赖关系前置,在定义模块的时候就要声明其依赖的模块;\r\n* CMD是按需加载依赖就近,只有在用到某个模块的时候再去require：\r\n\r\n```js\r\n// CMD\r\ndefine(function(require, exports, module) {\r\n  var a = require(\'./a\')\r\n  a.doSomething()\r\n  // 此处略去 100 行\r\n  var b = require(\'./b\') // 依赖可以就近书写\r\n  b.doSomething()\r\n  // ...\r\n})\r\n\r\n// AMD 默认推荐的是\r\ndefine([\'./a\', \'./b\'], function(a, b) { // 依赖必须一开始就写好\r\n  a.doSomething()\r\n  // 此处略去 100 行\r\n  b.doSomething()\r\n  ...\r\n})\r\n```\r\n\r\n### 兼容性\r\n![SeaJS兼容性](assets/005/04-1545123073000.png)\r\n\r\n\r\n\r\n\r\n## ES6中的模块化\r\n> ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。\r\n\r\n\r\nES6 的模块自动采用严格模式，不管你有没有在模块头部加上`\"use strict\"`;。\r\n\r\n> 注意：ES6模块中，顶层的`this`指向 `undefined`，即不应该在顶层代码使用`this`。\r\n\r\n\r\n模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\r\n\r\n### 1. export命令\r\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。`export`可以让我们把变量，函数，对象进行模块化，提供外部调用接口，让外部进行引用。\r\n\r\n```\r\nexport var firstName = \'Michael\';\r\nexport var lastName = \'Jackson\';\r\nexport var year = 1958;\r\n```\r\n或在文件末尾多变量输出：\r\n```\r\nvar firstName = \'Michael\';\r\nvar lastName = \'Jackson\';\r\nvar year = 1958;\r\n\r\nexport {firstName, lastName, year};\r\n```\r\n\r\n\r\n`export`命令除了输出变量，还可以输出函数或类（class）。\r\n```\r\nexprot function fun(){ }\r\n```\r\n或\r\n```\r\nfunction fun() {}\r\n\r\nexprot {fun};\r\n```\r\n\r\n\r\n\r\n有些时候并不想暴露模块里边的变量名称，还可使用`as`关键字对变量进行重命名\r\n\r\n```\r\nexport {\r\n    v1 as firstName,\r\n    v2 as lastName,\r\n    v3 as lastName\r\n};\r\n```\r\n\r\n### 2. export default 命令\r\n1. `export`与`export default`均可用于导出常量、函数、文件、模块等\r\n2. 你可以在其它文件或模块中通过`import+(常量 | 函数 | 文件 | 模块)名`的方式，将其导入，以便能够对其进行使用\r\n3. 在一个文件或模块中，`export`、`import`可以有多个，`export default`仅有一个\r\n4. 通过`export`方式导出，在导入时要加`{ }`，`export default`则不需要\r\n\r\n```js\r\nvar name=\"李四\";\r\nexport { name }\r\n//import { name } from \"./a.js\"\r\n可以写成：\r\nvar name=\"李四\";\r\nexport default name\r\n//import name from \"./a.js\" 这里name不需要大括号\r\n```\r\n\r\n### 3. import 命令\r\n使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。\r\n\r\n`export`对应的导入方式\r\n```js\r\nexport var a =\'js\';\r\nexport function add(a,b){\r\n    return a+b;\r\n}\r\n\r\nimport {a,add} from \'./temp\';\r\n\r\n//也可以分开写\r\nimport a from \'./temp\';\r\nimport add from \'./temp\';\r\n```\r\n\r\n`export defalut`对应的导入方式\r\n```js\r\nvar a =\'js\';\r\nfunction add(a,b){\r\n    return a+b;\r\n}\r\nexport defalut {a, add}\r\n\r\nimport obj from \'./temp\';\r\n```\r\n\r\n* import用as方式引入 (多个变量用一个空对象来代理,你所有的方法和属性都是在types命名空间)\r\n\r\n```js\r\nconst LOGIN = \'login\';\r\nconst LOGOUT = \'logout\';\r\nconst TITLE = \'title\'\r\nexport {LOGIN,LOGOUT,TITLE}\r\n```\r\n```js\r\nimport * as types from \'./temp.js\' //你所有的方法和属性都是在types命名空间\r\n// 调用里面里面的值可以 这样做\r\ntypes.LOGIN\r\ntypes.LOGOUT\r\ntypes.TITLE\r\n```\r\n\r\n### ES6模块化兼容性\r\n![ES6模块化兼容性](assets/005/01-1544507503000.png)\r\n\r\n由于ES6的模块化在浏览器端兼容性较差，不能直接在浏览器中预览，必须要使用Babel进行编译之后正常看到结果。\r\n","timestamp":1585877701769},{"name":"05-内存管理.md","path":"001-前端/08-JavaScript/005-js扩展/05-内存管理.md","content":"# 内存管理\r\n## 内存生命周期\r\n不管什么程序语言，内存生命周期基本是一致的：   \r\n\r\n1. 分配你所需要的内存\r\n2. 使用分配到的内存（读、写）\r\n3. 不需要时将其释放、归还\r\n\r\n所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像JavaScript这些高级语言中，大部分都是隐含的。\r\n\r\njs的内存生命周期：\r\n\r\n1. 定义变量时就完成了内存分配\r\n```js\r\nvar n = 123; // 给数值变量分配内存\r\nvar s = \"azerty\"; // 给字符串分配内存\r\nvar o = {\r\n  a: 1,\r\n  b: null\r\n}; // 给对象及其包含的值分配内存\r\nfunction f(a){\r\n  return a + 2;\r\n} // 给函数（可调用的对象）分配内存\r\n```\r\n2. 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。\r\n3. 而内存的释放而依赖GC机制（高级语言解释器嵌入的“垃圾回收器”）。\r\n\r\n## 垃圾回收\r\n\r\n### 引用\r\n垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。\r\n\r\n#### 引用计数垃圾收集(计数算法)\r\n把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。      \r\n无法处理循环引用\r\n\r\n```js\r\n// 创建一个对象person，他有两个指向属性age和name的引用\r\nvar person = {\r\n    age: 12,\r\n    name: \'aaaa\'\r\n};\r\nperson.name = null;  // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收\r\nvar p = person;\r\nperson = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收\r\np = null;           //原person对象已经没有引用，很快会被回收\r\n```\r\n\r\n##### 循环引用(上面垃圾回收的限制)\r\n```js\r\nfunction fun(){\r\n  var obj = {};\r\n  var obj2 = {};\r\n  obj.a = obj2; // obj 引用 obj2\r\n  obj2.a = obj; // obj2 引用 obj\r\n  return \"azerty\";\r\n}\r\nfun();\r\n```\r\n两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。\r\n\r\n#### 标记-清除算法\r\n现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。            \r\n\r\n标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\r\n\r\n\r\n### 内存泄漏\r\n对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏。                     \r\n\r\n#### 内存泄漏的识别方法\r\n如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。\r\n\r\n1. 浏览器方法\r\n     1. 打开开发者工具，   \r\n     2. 在顶部的Capture字段里面勾选 Memory   选择 Timeline 面板\r\n     3. 点击左上角的录制按钮。\r\n     4. 在页面上进行各种操作，模拟用户的使用情况。\r\n     5. 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。    \r\n\r\n如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。 反之，就是内存泄漏了。\r\n\r\n2. 命令行方法\r\n命令行可以使用 Node 提供的 `process.memoryUsage` 方法。                   \r\n\r\nprocess.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，\r\n```js\r\nconsole.log(process.memoryUsage());\r\n//  rss:        所有内存占用，包括指令区和堆栈。\r\n//  heapTotal:     \"堆\"占用的内存，包括用到的和没用到的。\r\n//  heapUsed:    用到的堆的部分。\r\n//  external:     V8 引擎内部的 C++ 对象占用的内存。\r\n\r\n// 判断内存泄漏，以heapUsed字段为准。\r\n```\r\n\r\n### 常见内存泄漏\r\n如果还需要兼容老旧浏览器，那么就需要注意代码中的循环引用问题。或者直接采用保证兼容性的库来帮助优化代码。                 \r\n\r\n对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关。\r\n\r\n1. 绝对不要定义全局变量      \r\nJavaScript用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window 。为了防止这种意外，可以使用严格模式来阻止\r\n2. 手工解除变量引用           \r\n一个变量已经确切是不再需要了，那么就可以手工解除变量引用，以使其被回收。\r\n3. 闭包     \r\n4. DOM外引用                 \r\n","timestamp":1585877701769},{"name":"06-优化.md","path":"001-前端/08-JavaScript/005-js扩展/06-优化.md","content":"# js性能优化\r\n1. 重复使用的调用结果，事先保存到局部变量\r\n```js\r\n//避免多次取值的调用开销\r\nvar h1 = element1.clientHeight + num1;\r\nvar h4 = element1.clientHeight + num2;\r\n//可以替换为：\r\nvar eleHeight = element1.clientHeight;\r\nvar h1 = eleHeight + num1;\r\nvar h4 = eleHeight + num2;\r\n```\r\n\r\n1. 避免全局查找   \r\n在一个函数中会用到全局对象存储为局部变量来减少全局查找，因为访问局部变量的速度要比访问全局变量的速度更快些\r\n```js\r\nfunction search() {\r\n    //当我要使用当前页面地址和主机域名\r\n    alert(window.location.href + window.location.host);\r\n}\r\n//最好的方式是如下这样  先用一个简单变量保存起来\r\nfunction search() {\r\n    var location = window.location;\r\n    alert(location.href + location.host);\r\n}    \r\n```\r\n\r\n3. 浮点数转换成整型    \r\nparseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，应该使用Math.floor()或者Math.round()\r\n\r\n4. 各种类型转换\r\n```js\r\nvar myVar = \"3.14159\",\r\nstr = \"\" + myVar, //  to string  \r\ni_int = ~ ~myVar,  //  to integer  \r\nf_float = 1 * myVar,  //  to float  \r\nb_bool = !!myVar,  /*  to boolean - any string with length\r\n                        and any number except 0 are true */\r\narray = [myVar];  //  to array  \r\n```\r\n如果定义了toString()方法来进行类型转换的话，推荐显式调用toString()，因为内部的操作在尝试所有可能性之后，会尝试对象的toString()方法尝试能否转化为String，所以直接调用这个方法效率会更高\r\n\r\n4. 使用一次innerHTML赋值代替构建dom元素\r\n对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。\r\n```js\r\nvar frag = document.createDocumentFragment();\r\nfor (var i = 0; i < 1000; i++) {\r\n    var el = document.createElement(\'p\');\r\n    el.innerHTML = i;\r\n    frag.appendChild(el);\r\n}\r\ndocument.body.appendChild(frag);\r\n//可以替换为：\r\nvar html = [];\r\nfor (var i = 0; i < 1000; i++) {\r\n    html.push(\'<p>\' + i + \'</p>\');\r\n}\r\ndocument.body.innerHTML = html.join(\'\');\r\n```\r\n\r\n5. 删除dom节点之前,一定要删除注册在该节点上的事件\r\n否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点\r\n\r\n6. 使用事件代理    \r\n任何可以冒泡的事件都不仅仅可以在事件目标上进行处理，目标的任何祖先节点上也能处理，使用这个知识就可以将事件处理程序附加到更高的地方负责多个目标的事件处理，同样，对于内容动态增加并且子节点都需要相同的事件处理函数的情况，可以把事件注册提到父节点上，这样就不需要为每个子节点注册事件监听了。另外，现有的js库都采用observe方式来创建事件监听,其实现上隔离了dom对象和事件处理函数之间的循环引用,所以应该尽量采用这种方式来创建事件监听\r\n\r\n6. 避免双重解释\r\n    * 尽量少使用eval函数\r\n    * 不要使用Function构造器\r\n7. 通过javascript创建的dom对象，必须append到页面中\r\n>IE下，脚本创建的dom对象，如果没有append到页面中，刷新页面，这部分内存是不会回收的！\r\n\r\n8. 尽量使用原生方法  \r\n8. 条件分支\r\n    * 将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数\r\n    * 在同一条件子的多（>2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。\r\n    * 使用三目运算符替代条件分支\r\n10. 优化循环\r\n    * 减值迭代\r\n    * 简化终止条件\r\n    * 简化循环体\r\n    * 使用后测试循环\r\n>在JavaScript中，我们可以使用for(;;),while(),for(in)三种循环，事实上，这三种循环中for(in)的效率极差，因为他需要查询散列键，只要可以，就应该尽量少用。for(;;)和while循环，while循环的效率要优于for(;;)，可能是因为for(;;)结构的问题，需要经常跳转回去。\r\n","timestamp":1585877701769},{"name":"07-设计模式.md","path":"001-前端/08-JavaScript/005-js扩展/07-设计模式.md","content":"# JavaScript设计模式\r\n\r\n## 什么是设计模式?\r\n模式是一种可复用的解决方案，可用于解决项目中遇到的常见问题，将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。如在编写的JavaScript应用程序的实例中，同类型问题共用一种解决方法。          \r\n所有设计模式都有一个共同的目的，那就是让编程更加模块化，系统化，明确化。\r\n\r\n## 为什么使用设计模式\r\n1. 使用已经验证的解决方案，可以快速可靠解决项目开发中遇到的问题\r\n2. 复用代码，使代码更加简洁\r\n\r\n## 设计模式的六大原则\r\n总原则－开闭原则\r\n\r\n对扩展开放，对修改封闭。 在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。 想要达到这样的效果，我们需要使用接口和抽象类等。\r\n\r\n1. 单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。\r\n\r\n2. 里氏替换原则（Liskov Substitution Principle） 任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。\r\n\r\n3. 依赖倒转原则（Dependence Inversion Principle） 面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。\r\n\r\n4. 接口隔离原则（Interface Segregation Principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。\r\n\r\n5. 迪米特法则（最少知道原则）（Demeter Principle） 一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。\r\n\r\n6. 合成复用原则（Composite Reuse Principle） 尽量首先使用合成/聚合的方式，而不是使用继承。\r\n\r\n## 单体模式(单例模式)\r\n`单体模式`就是保证一个类仅有一个实例，例如浏览器中的window对象。实际上，在事项对象的字面量创建对象时，就是正在创建一个单体。                                         \r\n单体模式（Singleton Pattern）就是确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。                 \r\n\r\n### 简单案例\r\n\r\n```js\r\nvar Single = (function(){\r\n    var instance;\r\n    function init() {\r\n        //define private methods and properties\r\n        //do something\r\n        return {\r\n            //define public methods and properties\r\n        };\r\n    }\r\n\r\n    return {\r\n        // 获取实例\r\n        getInstance:function(){\r\n            if(!instance){\r\n                instance = init();\r\n            }\r\n            return instance;\r\n        }\r\n    }\r\n})();\r\n\r\nvar obj1 = Single.getInstance();\r\nvar obj2 = Single.getInstance();\r\n\r\nconsole.log(obj1 === obj2);               //true\r\n```\r\n\r\n\r\n### 适用场合\r\n在 JavaScript开发中，单体模式的用途同样非常广泛。试想一下，当单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单体模式来创建。                       \r\n要求生成唯一序列号的环境                    \r\n整个项目需要一个共享访问点或共享数据                      \r\n创建一个对象消耗资源过多\r\n\r\n\r\n## 工厂模式\r\n工厂模式是用来创建对象的一种最常用的设计模式。不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。          \r\n工厂模式分为三种：简单工厂模式、工厂方法模式、抽象工厂模式\r\n### 简单工程模式\r\n简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。对于非大型的前端应用来说，灵活使用简单工厂其实就能解决大部分问题。            \r\n\r\n简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。\r\n```js\r\n//User类\r\nclass User {\r\n  //构造器\r\n  constructor(opt) {\r\n    this.name = opt.name;\r\n    this.viewPage = opt.viewPage;\r\n  }\r\n\r\n  //静态方法\r\n  static getInstance(role) {\r\n    switch (role) {\r\n      case \'superAdmin\':\r\n        return new User({ name: \'超级管理员\', viewPage: [\'首页\', \'通讯录\', \'发现页\', \'应用数据\', \'权限管理\'] });\r\n        break;\r\n      case \'admin\':\r\n        return new User({ name: \'管理员\', viewPage: [\'首页\', \'通讯录\', \'发现页\', \'应用数据\'] });\r\n        break;\r\n      case \'user\':\r\n        return new User({ name: \'普通用户\', viewPage: [\'首页\', \'通讯录\', \'发现页\'] });\r\n        break;\r\n      default:\r\n        throw new Error(\'参数错误, 可选参数:superAdmin、admin、user\')\r\n    }\r\n  }\r\n}\r\n//调用\r\nlet superAdmin = User.getInstance(\'superAdmin\');\r\nlet admin = User.getInstance(\'admin\');\r\nlet normalUser = User.getInstance(\'user\');\r\nconsole.log(superAdmin);\r\nconsole.log(admin);\r\nconsole.log(normalUser);\r\n```\r\n\r\n### 工厂方法模式\r\n与简单工厂模式相比，主要区别就是它不是另外使用一个对象或者类来创建实例，而是使用一个子类。工厂是一个将其成员对象的实例化推迟到子类中进行的类。                  \r\n\r\n```js\r\nclass User {\r\n  constructor(name = \'\', viewPage = []) {\r\n    //new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。\r\n    if(new.target === User) {\r\n      throw new Error(\'抽象类不能实例化!\');\r\n    }\r\n    this.name = name;\r\n    this.viewPage = viewPage;\r\n  }\r\n}\r\nclass UserFactory extends User {\r\n  constructor(name, viewPage) {\r\n    super(name, viewPage)\r\n  }\r\n  create(role) {\r\n    switch (role) {\r\n      case \'superAdmin\':\r\n        return new UserFactory( \'超级管理员\', [\'首页\', \'通讯录\', \'发现页\', \'应用数据\', \'权限管理\'] );\r\n        break;\r\n      case \'admin\':\r\n        return new UserFactory( \'普通用户\', [\'首页\', \'通讯录\', \'发现页\'] );\r\n        break;\r\n      case \'user\':\r\n        return new UserFactory( \'普通用户\', [\'首页\', \'通讯录\', \'发现页\'] );\r\n        break;\r\n      default:\r\n        throw new Error(\'参数错误, 可选参数:superAdmin、admin、user\')\r\n    }\r\n  }\r\n}\r\nlet userFactory = new UserFactory();\r\nlet superAdmin = userFactory.create(\'superAdmin\');\r\nlet admin = userFactory.create(\'admin\');\r\nlet user = userFactory.create(\'user\');\r\n```\r\n\r\n### 抽象工厂模式\r\n抽象工厂模式并不直接生成实例，而是用于对产品类簇的创建,不负责创建某一类产品的实例。\r\n\r\n```js\r\nclass User {\r\n  constructor(type) {\r\n    if (new.target === User) {\r\n      throw new Error(\'抽象类不能实例化!\')\r\n    }\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nclass UserOfWechat extends User {\r\n  constructor(name) {\r\n    super(\'wechat\');\r\n    this.name = name;\r\n    this.viewPage = [\'首页\', \'通讯录\', \'发现页\']\r\n  }\r\n}\r\n\r\nclass UserOfQq extends User {\r\n  constructor(name) {\r\n    super(\'qq\');\r\n    this.name = name;\r\n    this.viewPage = [\'首页\', \'通讯录\', \'发现页\']\r\n  }\r\n}\r\n\r\nclass UserOfWeibo extends User {\r\n  constructor(name) {\r\n    super(\'weibo\');\r\n    this.name = name;\r\n    this.viewPage = [\'首页\', \'通讯录\', \'发现页\']\r\n  }\r\n}\r\n\r\nfunction getAbstractUserFactory(type) {\r\n  switch (type) {\r\n    case \'weixin\':\r\n      return UserOfWechat;\r\n      break;\r\n    case \'qq\':\r\n      return UserOfQq;\r\n      break;\r\n    case \'weibo\':\r\n      return UserOfWeibo;\r\n      break;\r\n    default:\r\n      throw new Error(\'参数错误, 可选参数:weixin  qq  weibo\')\r\n  }\r\n}\r\nlet WechatUserClass = getAbstractUserFactory(\'weixin\');\r\nlet QqUserClass = getAbstractUserFactory(\'qq\');\r\nlet WeiboUserClass = getAbstractUserFactory(\'weibo\');\r\n\r\nlet wechatUser = new WechatUserClass(\'微信小孙\');\r\nlet qqUser = new QqUserClass(\'QQ老马\');\r\nlet weiboUser = new WeiboUserClass(\'微博小李\');\r\nconsole.log(wechatUser)\r\nconsole.log(qqUser)\r\nconsole.log(weiboUser)\r\n```\r\n\r\n### 使用场合\r\n* 创建一些用不同方式实现统一接口的对象，那么可以使用一个工厂方法或者简单工厂对象来简化实现过程。\r\n* 对象要进行复杂的并且彼此相关的设置的时候，那么工厂模式可以很显著的减少每种对象的代码量。将特定的设置代码提取出来会使得代码有极大地提升。并且能优化结构便于维护。\r\n* 许多小型对象组成一个大对象\r\n\r\n\r\n## 迭代器模式\r\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。javascript内置了迭代器==>JavaScript 的 `Array.prototype.forEach`\r\n\r\n### 内部迭代器\r\n已经定义好了迭代规则，它完全接手整个迭代过程，外部只需一次初始调用。\r\n\r\n#### jQuery中的迭代器\r\n```js\r\n$.each([1, 2, 3], function(i, n) {\r\n  console.log(\"当前下标为：\"+ i + \" 当前元素为：\"+ n );\r\n});\r\n```\r\n#### 原生javascript实现\r\n```js\r\nvar each = function(ary, callback) {\r\n  for(var i = 0, l = ary.length; i < l; i++) {\r\n    callback.call(ary[i], i, ary[i]);\r\n  }  \r\n};\r\neach([1, 2, 3], function(i, n) {\r\n  console.log(\"当前下标为：\"+ i + \" 当前元素为：\"+ n );\r\n});\r\n```\r\n\r\n### 外部迭代器\r\n必须显式地请求迭代下一个元素。\r\n```js\r\n// 外部迭代器\r\nvar Iterator = function(obj) {\r\n  var current = 0,\r\n    next = function() {\r\n      current++;\r\n    },\r\n    isDone = function() {\r\n      return current > obj.length; \r\n    },\r\n    getCurrentItem = function() {\r\n      return obj[current];\r\n    };\r\n  return {\r\n    next: next,\r\n    isDone: isDone,\r\n    getCurrentItem: getCurrentItem\r\n  };\r\n};\r\n// 比较函数\r\nvar compareAry = function(iterator1, iterator2) {\r\n  while( !iterator1.isDone() && !iterator2.isDone() ){      //判断两个数组是否为最后一位\r\n    if(iterator1.getCurrentItem() !== iterator2.getCurrentItem()) {\r\n      throw new Error(\"不相等\");\r\n    }\r\n    iterator1.next();       //比较数组的下一个\r\n    iterator2.next();       //比较数组的下一个\r\n  }\r\n  console.log(\"相等\");\r\n}\r\ncompareAry(new Iterator([1, 2, 3]), new Iterator([1, 2, 3]));\r\n```\r\n\r\n### 使用场合\r\n对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。\r\n\r\n## 组合模式\r\n将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。                         \r\n组合模式主要有三个角色：\r\n1. 抽象组件（Component）：抽象类，主要定义了参与组合的对象的公共接口\r\n2. 子对象（Leaf）：组成组合对象的最基本对象\r\n3. 组合对象（Composite）：由子对象组合起来的复杂对象\r\n\r\n### 经典案例\r\n假设我们开发一个旅游产品网站，其中包含机票和酒店两种子产品，我们定义了子对象如下：\r\n```js\r\nfunction FlightOrder() { }\r\nFlightOrder.prototyp.create = function () {\r\n    console.log(\"flight order created\");\r\n}\r\nfunction HotelOrder() { }\r\nHotelOrder.prototype.create = function () {\r\n    console.log(\"hotel order created\");\r\n}\r\n```\r\n上面的代码定义了两个类：机票订单类和酒店订单类，每个类都有各自的订单创建方法。               \r\n接下来我们创建一个总订单类：\r\n```js\r\nfunction TotalOrders() {\r\n    this.orderList = [];\r\n}\r\nTotalOrders.prototype.addOrder = function (order) {\r\n    this.orderList.push(order);\r\n}\r\nTotalOrders.prototype.create = function (order) {\r\n    for (var i = 0, length = this.orderList.length; i < length; i++) {\r\n        this.orderList[i].create();\r\n    }\r\n}\r\n```\r\n这个对象主要有3个成员：订单列表，添加订单的方法，创建订单的方法。                 \r\n在客户端使用的时候如下：    \r\n```js\r\nvar flight = new FlightOrder();\r\nflight.create();\r\n\r\nvar orders = new TotalOrders();\r\norders.addOrder(new FlightOrder());\r\norders.addOrder(new HotelOrder());\r\norders.create();\r\n```\r\n客户端调用展示了两种方式，一种是单一的创建机票订单，一种是创建多张订单，但最终都是通过create方法进行创建，这就是一个很典型的组合模式的应用场景。    \r\n\r\n### 使用场景\r\n1. 想表示对象的部分-整体层次结构时\r\n2. 希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）\r\n3. 对象具有明显的层次结构并且想要统一地使用它们，这就非常适合使用组合模式。\r\n\r\n## 装饰者模式\r\n给对象动态添加职责的方式就是装饰者模式，能够在不改变原对象的情况下，在运行的时候给对象添加新的职责。                   \r\n\r\n天气冷了，就添加衣服来保暖；天气热了，就将外套脱下；这个例子很形象地含盖了装饰器的神韵，随着天气的冷暖变化，衣服可以动态的穿上脱下。         \r\n\r\n### 使用\r\n开发一个射击游戏，随着时间进行，会吃到道具，火力就越来越强，吃一颗星，不仅可以发普通子弹，还会发射散弹，再吃一颗，不仅可以发射普通子弹和散弹，还有跟踪导弹\r\n```js\r\nvar plane = {\r\n    fire: function(){\r\n        console.log(\'发射子弹\');\r\n    }\r\n}\r\nplane.fire();\r\n//发射子弹\r\nvar fire1 = plane.fire;\r\nvar shot = function(){\r\n    console.log(\'发射散弹\');\r\n}\r\nplane.fire = function(){\r\n    fire1();\r\n    shot();\r\n}\r\nplane.fire();\r\n//发射子弹 发射散弹\r\nvar fire2 = plane.fire;\r\nvar track = function(){\r\n    console.log(\'发射跟踪导弹\');\r\n}\r\nplane.fire = function(){\r\n    fire2();\r\n    track();\r\n}\r\nplane.fire();\r\n//发射子弹 发射散弹 发射跟踪导弹\r\n```\r\n给对象动态的增加职责的方式就没有改变对象自身,一个对象放入另一个对象,形成了一条装饰链（一个聚合对象），而上面的shot和track也就是是装饰者、装饰函数，当函数执行时，会把请求转给链中的下一个对象\r\n\r\n### AOP(面向切面编程)\r\n把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式参入业务逻辑模块中。                     \r\nAOP好处\r\n* 保证业务逻辑模块的纯净和高内聚性\r\n* 方便复用日志统计等功能模块\r\n\r\n#### JS实现AOP思路：把一个函数“动态织入”到另一个函数之中。我们使用Function.prototype来实现\r\n```js\r\nFunction.prototype.before = function(beforefn){\r\n\tvar _self = this;      //保存原函数引用\r\n\treturn function(){    \r\n\t\tbeforefn.apply(this,arguments);      //执行新函数，修正this\r\n\t\treturn _self.apply(this,arguments);  //执行原函数\r\n\t}\r\n};\r\n\r\nFunction.prototype.after = function(afterfn){\r\n\tvar _self = this;\r\n\treturn function(){\r\n\t    var ret = _self.apply(this, arguments);   //不要直接写在return中\r\n              afterfn.apply(this, arguments);\r\n              return ret;\t\t\r\n\t}\r\n}\r\n\r\nvar func = function(){\r\n\tconsole.log(\"2\")\r\n}\r\n\r\nfunc = func.before(function(){\r\n\tconsole.log(\"1\");\r\n}).after(function(){\r\n\tconsole.log(\"3\");\r\n});\r\n\r\nfunc();   //1 2 3\r\n```\r\n把负责打印1和打印3的两个函数通过AOP方式动态插入func函数。通过执行上述函数，控制台一次输出1 2 3。\r\n\r\n### 缺点\r\n* 装饰链叠加了函数作用域，如果过长也会产生性能问题\r\n* 如果原函数上保存了属性，返回新函数后属性会丢失\r\n\r\n### 使用场景\r\n* 扩展一个类的功能\r\n* 动态增加功能，动态撤销。\r\n\r\n\r\n## 策略模式(算法簇模式)        \r\n定义了不同的算法，并且之间可以互相替换，此模式让算法的变化独立于使用算法的客户。             \r\n\r\n策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。     \r\n\r\n### 简单案例\r\n```js\r\n/*\r\n示例：公司计算奖金，分A、B、C 三种绩效，计算方式如下\r\n * 绩效为A，奖金乘以5\r\n * 绩效为B，奖金乘以4\r\n * 绩效为C，奖金乘以3\r\n*/\r\nvar Strategies = {\r\n \"A\":function(salary){\r\n  return salary * 5;\r\n },\r\n \"B\":function(salary){\r\n  return salary * 4;\r\n },\r\n \"C\":function(salary){\r\n  return salary * 3;\r\n }\r\n};\r\nvar caculateBonus = function(level,salary){\r\n return Strategies[level](salary);\r\n};\r\nconsole.log(caculateBonus(\"A\",2000));\r\n```\r\n\r\n### 策略模式优缺点\r\n#### 优点\r\n* 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句           \r\n* 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的对象中，使得它们易于切换，易于理解，易于扩展\r\n#### 缺点\r\n* 会在程序中增加许多策略类或者策略对象\r\n* 使用策略模式，必须了解所有的策略，才能更好的选择一个合适的策略\r\n\r\n## 代理模式\r\n一个对象充当另一个对象(本体对象)的接口，所有对本体对象的操作都依靠这个接口对象执行。             \r\n举个例子来描述，你想要给你一个女孩子送花，你又不好意思，于是便委托你朋友帮你送，这时就使用了代理模式\r\n\r\n### 虚拟代理\r\n把一些开销很大的对象，延迟到真正需要用到这个对象的时候才去创建                   \r\n\r\n#### 虚拟代理图片预加载\r\n```js\r\nvar addImg = (function(){\r\n    var img = document.createElement(\'img\');\r\n    document.body.appendChild(img);\r\n    return {\r\n        setSrc: function(src){\r\n            img.src = src;\r\n        }\r\n    }\r\n})();\r\nvar proxyAddImg = (function(){\r\n    var img = new Image();\r\n    img.onload = function(){\r\n        addImg.setSrc(this.src);\r\n    }\r\n    return {\r\n        setSrc: function(src){\r\n            addImg.setSrc(\'loading.gif\');\r\n            img.src = src;\r\n        }\r\n    }\r\n})();\r\nproxyAddImg.setSrc(\'demo.png\');\r\n```\r\n\r\n#### 虚拟代理同步数据\r\n当前台向服务器提交数据时，如果每次前台提交都向服务器发送请求，前台在很短的时间内多次提交数据的话，就会造成很大的服务器性能浪费，网络开销费非常大。---------------   这时我们使用虚拟代理，防止客户端短时间内频繁操作，我们把客户端的请求合并到一起发送给服务器\r\n\r\n```html\r\n<body>\r\n<input type=\"checkbox\" id=\"A\">内容一<br>\r\n<input type=\"checkbox\" id=\"B\">内容二<br>\r\n<input type=\"checkbox\" id=\"C\">内容三<br>\r\n<input type=\"checkbox\" id=\"D\">内容四<br>\r\n<input type=\"checkbox\" id=\"E\">内容五<br>\r\n<input type=\"checkbox\" id=\"F\">内容六<br>\r\n<input type=\"checkbox\" id=\"G\">内容七<br>\r\n<input type=\"checkbox\" id=\"H\">内容八<br>\r\n<script>\r\nvar synData = function(ID){\r\n    console.log(ID +　\'正在同步到服务器...\');\r\n}\r\nvar proxySynData = (function(){\r\n    var cache = {}, //用对象作为缓存载体\r\n        timer;\r\n    return function(ID){\r\n        if(!timer){\r\n            timer = setTimeout(function(){\r\n                synData(Object.keys(cache).join());\r\n                cache = {};\r\n                clearTimeout(timer);\r\n                timer = null;\r\n            }, 2000);\r\n        }\r\n        cache[ID] = 1;\r\n    }\r\n})();\r\nvar list = document.getElementsByTagName(\'input\');\r\nfor(var i = 0, item; item = list[i]; i++){\r\n    item.onclick = function(){\r\n        if(this.checked){\r\n            proxySynData(this.id);\r\n        }\r\n    };\r\n}\r\n</script>\r\n</body>\r\n```\r\n\r\n### 缓存代理\r\n缓存一些开销很大的运算结果，将需要重复使用的函数运算结果保存在一个变量里，下次使用时直接使用这个变量就OK了。                  (这个很好理解)\r\n\r\n### 使用场景\r\n假如初始化本体对象的开销很大，而且在客户端初始化该本体对象以后程序却很少使用它，这时可以使用代理通过代理替换本体对象的接口从而避免高昂的操作开销。                                              \r\n\r\n>不能滥用代理，有时候仅仅是给代码增加复杂度\r\n\r\n## 中介者模式\r\n对象之间相互不直接“沟通”，通过一个中介者对这些对象进行通信，从而形成松散耦合。                                      \r\n中介者模式可以让多个对象之间松耦合，并降低维护成本       \r\n\r\n中介者模式理解起来十分简单，就像我们生活中去中介租房子，我们租客不关心这是谁的房子，房东不关心他的房子出租给了谁，中介人在租房者和房东出租者之间形成一个中介。这就是中介模式，很简单的理解。       \r\n\r\nMVC三层模型实体模型（Model）、视图表现层（View）还有控制层（Control/Mediator）。控制层便是位于表现层与模型层之间的中介者。笼统地说MVC也算是中介者模式在框架设计中的一个应用。\r\n\r\n### 适用场景\r\n一组定义良好的对象，现在要进行复杂的通信。\r\n\r\n定制一个分布在多个类中的行为，而又不想生成太多的子类。\r\n\r\n可以看出，中介对象主要是用来封装行为的，行为的参与者就是那些对象，但是通过中介者，这些对象不用相互知道。               \r\n### 中介模式的优缺点\r\n#### 优点\r\n* 降低了系统对象之间的耦合性，使得对象易于独立的被复用。\r\n* 提高系统的灵活性，使得系统易于扩展和维护。\r\n\r\n#### 缺点\r\n过度集中化，如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。\r\n\r\n\r\n### 简单案例\r\n飞机场飞机与飞机之间彼此的交流，以调度中心为中介。\r\n\r\n```js\r\n//飞机对象的构造函数\r\nvar feiji=function(name){\r\n    this.name=name;\r\n}\r\nfeiji.prototype.send=function(msg,to){\r\n    console.log(this.name+\"发送了信息\");\r\n    diaodu.send(msg,to);\r\n}\r\nfeiji.prototype.jieshou=function(msg){\r\n    console.log(this.name+\"接受到\"+msg);\r\n}\r\n//调度中心对象\r\nvar diaodu={\r\n    //将飞机对象通过zhuce函数添加到all对象里\r\n    all:{},\r\n    zhuce:function(feiji){\r\n        this.all[feiji.name]=feiji;\r\n    },\r\n    send:function(msg,to){\r\n        this.all[to.name].jieshou(msg);\r\n    }\r\n}\r\nvar feiji1=new feiji(\'feiji1\');\r\nvar feiji2=new feiji(\'feiji2\');\r\ndiaodu.zhuce(feiji1);\r\ndiaodu.zhuce(feiji2);\r\nfeiji1.send(\"我马上降落，还有200米\",feiji2);\r\n```\r\n\r\n## 观察者模式(订阅/发布模式)(Vue的双向绑定原理就是基于此模式)\r\n观察者模式在 javascript 中使用非常广泛。它定义了一种一对多的依赖关系，即当一个对象的状态发生改变的时候，所有依赖于它的对象都会得到通知并自动更新，解决了主体对象与观察者之间功能的耦合。      \r\n松耦合的代码、一对多的关系、主体状态变化时，所有依赖被通知、主体和观察者互不知晓。\r\n### 适用于以下场景\r\n当一个抽象模型有两个方面，其中一个方面依赖于另一方面。讲这两者封装在独立的对象中可以让它们可以各自独立的改变和复用         \r\n对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。                      \r\n对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。\r\n\r\n### 观察者模式的优缺点\r\n#### 优点\r\n观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知\r\n\r\n#### 缺点\r\n* 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\r\n* 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。\r\n* 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\r\n* 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\r\n\r\n### 观察者模式与中介者模式的区别\r\n观察者模式和中介者模式看起来非常的相似，核心原理都是一样的，这里有一个细微的差别，中介者模式注重状态告知，观察者模式侧重组件数据通信，其实我们这里完全使用观察者模式也可以实现状态告知，不过 但观察者是分发性的，所有的观察者都会受到信息，而且中介者则是单一的，对象的通信由中介者处理。         \r\n\r\n当组件之间依赖关系简单时，可以直接使用 观察者模式                     \r\n当组件之间依赖关系复杂是，需要借助 中介者模式 梳理关系\r\n\r\n### 简单案例\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <div>\r\n        <label>用户名称：<input type=\"text\" id=\"pba\" placeholder=\"请输入用户名称\" /></label><br /><br />\r\n        <label>生成邮箱：<input type=\"text\" id=\"oba\" readonly /></label>\r\n        <label>生成ID：<input type=\"text\" id=\"obb\" readonly /></label>\r\n    </div>\r\n\r\n    <script type=\"text/javascript\">\r\n        //发布者\r\n        function Publisher(obj){\r\n            this.observers = [];\r\n            var state = obj.value;     //让该内容不能直接访问\r\n\r\n            //新增两个对于state的操作 获取/更新\r\n            this.getState=function(){\r\n                return state;\r\n            }\r\n            this.setState=function(value){\r\n                state = value;\r\n                this.notice();\r\n            }\r\n            this.obj = obj;\r\n\r\n        }\r\n        Publisher.prototype.addOb=function(observer){\r\n            var flag = false;\r\n            for (var i = this.observers.length - 1; i >= 0; i--) {\r\n                if(this.observers[i]===observer){\r\n                    flag=true;                \r\n                }\r\n            };\r\n            if(!flag){\r\n                this.observers.push(observer);\r\n            }\r\n            return this;\r\n        }\r\n        Publisher.prototype.removeOb=function(observer){\r\n            var observers = this.observers;\r\n            for (var i = 0; i < observers.length; i++) {\r\n                if(observers[i]===observer){\r\n                    observers.splice(i,1);\r\n                }\r\n            };\r\n            return this;\r\n        }\r\n        Publisher.prototype.notice=function(){\r\n            var observers = this.observers;\r\n            for (var i = 0; i < observers.length; i++) {\r\n                    observers[i].update(this.getState());\r\n            };\r\n        }\r\n        //订阅者\r\n        function Subscribe(obj){\r\n            this.obj = obj;\r\n            this.update = function(data){\r\n                this.obj.value = data;\r\n            };\r\n        }\r\n\r\n        //实际应用\r\n        var oba = new Subscribe(document.querySelector(\"#oba\")),\r\n            obb = new Subscribe(document.querySelector(\"#obb\"));\r\n\r\n        var pba = new Publisher(document.querySelector(\"#pba\"));\r\n\r\n        pba.addOb(oba);\r\n        pba.addOb(obb);\r\n\r\n        oba.update = function(state){\r\n            this.obj.value = state+\"@w3c.com\";\r\n        }\r\n        obb.update = function(state){\r\n            this.obj.value = \"ID-\"+state;\r\n        }\r\n\r\n        pba.obj.addEventListener(\'keyup\',function(){\r\n            pba.setState(this.value);\r\n        });\r\n\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n","timestamp":1585877701769},{"name":"08-参考Vue实现MVVM流程.md","path":"001-前端/08-JavaScript/005-js扩展/08-参考Vue实现MVVM流程.md","content":"# VUE实现\r\nVue是一个典型的MVVM框架\r\n\r\n## 数据处理(数据双向绑定)\r\n双向数据绑定就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view。                   \r\nvue实现对数据的双向绑定，通过对数据劫持结合发布者-订阅者模式实现的。                                 \r\nangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图。            \r\n\r\nvue通过Object.defineProperty来实现数据劫持，会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。                           \r\n\r\ndefineProperty方法是这里的重点，需要了解请移步Object对象。\r\n\r\n\r\n```html\r\n<body>\r\n    <input type=\"text\" id=\"input\">\r\n    <span id=\"span\"></span>\r\n</body>\r\n<script>\r\n    var input=document.querySelector(\'#input\');\r\n    var span=document.querySelector(\'#span\');\r\n    var obj={};\r\n    console.log(Array.from(input.attributes));\r\n    Object.defineProperty(obj,\'hello\',{\r\n        set(newValue){\r\n            input.value=newValue;\r\n            span.innerHTML=newValue;\r\n        }\r\n    })\r\n    document.addEventListener(\'keyup\',function(e){\r\n        obj.hello=e.target.value;\r\n    })\r\n</script>\r\n```\r\n\r\n## 实现mvvm\r\n实现mvvm需要实现数据监听器+指令解析器+Watcher\r\n\r\n### 数据监听器\r\n数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者               \r\n我们利用Obeject.defineProperty()来监听属性变动，需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。         \r\n```js\r\nvar data = {name: \'kindeng\'};\r\nobserve(data);\r\ndata.name = \'dmq\'; // 哈哈哈，监听到值变化了 kindeng --> dmq\r\n\r\nfunction observe(data) {\r\n    if (!data || typeof data !== \'object\') {\r\n        return;\r\n    }\r\n    // 取出所有属性遍历\r\n    Object.keys(data).forEach(function(key) {         \r\n        defineReactive(data, key, data[key]);\r\n    });\r\n};\r\n\r\nfunction defineReactive(data, key, val) {        //给对象上的值添加get和set\r\n    observe(val); // 监听子属性\r\n    Object.defineProperty(data, key, {\r\n        enumerable: true, // 可枚举\r\n        configurable: false, // 不能再define\r\n        get: function() {\r\n            return val;\r\n        },\r\n        set: function(newVal) {\r\n            console.log(\'哈哈哈，监听到值变化了 \', val, \' --> \', newVal);\r\n            val = newVal;\r\n        }\r\n    });\r\n}\r\n```\r\n可以监听到每个数据的变化，我们再把这些变化通知给订阅者，需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法。\r\n```js\r\nfunction defineReactive(data, key, val) {\r\n    var dep = new Dep();           //给上面的代码添加Dep实例\r\n    observe(val); // 监听子属性\r\n\r\n    Object.defineProperty(data, key, {\r\n        // ... 省略\r\n        set: function(newVal) {\r\n            if (val === newVal) return;\r\n            console.log(\'哈哈哈，监听到值变化了 \', val, \' --> \', newVal);\r\n            val = newVal;\r\n            dep.notify(); // 通知所有订阅者\r\n        }\r\n    });\r\n}\r\nfunction Dep() {\r\n    this.subs = [];\r\n}\r\nDep.prototype = {\r\n    addSub: function(sub) {\r\n        this.subs.push(sub);\r\n    },\r\n    notify: function() {\r\n        this.subs.forEach(function(sub) {\r\n            sub.update();\r\n        });\r\n    }\r\n};\r\n```\r\n\r\n接着往往订阅器添加订阅者，订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就需要在闭包内操作，所以我们可以在 getter里面操作\r\n```js\r\nObject.defineProperty(data, key, {\r\n    get: function() {\r\n        // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除\r\n        Dep.target && dep.addDep(Dep.target);\r\n        return val;\r\n    }\r\n});\r\n\r\n// Watcher.js\r\nWatcher.prototype = {\r\n    get: function(key) {\r\n        Dep.target = this;\r\n        this.value = data[key];    // 这里会触发属性的getter，从而添加订阅者\r\n        Dep.target = null;\r\n    }\r\n}\r\n```\r\n\r\nObserver(数据监听器)就已经具备了监听数据和数据变化通知订阅者的功能。\r\n\r\n### 指令解析器\r\n对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。简单来说就是把我们写的指令解析出来，然后进行相应的操作。                           \r\n\r\n遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中\r\n```js\r\nfunction Compile(el) {\r\n    this.$el = this.isElementNode(el) ? el : document.querySelector(el);\r\n    if (this.$el) {\r\n        this.$fragment = this.node2Fragment(this.$el);\r\n        this.init();          \r\n        this.$el.appendChild(this.$fragment);\r\n    }\r\n}\r\nCompile.prototype = {\r\n    init: function() { this.compileElement(this.$fragment); },     \r\n    node2Fragment: function(el) {\r\n        var fragment = document.createDocumentFragment(), child;\r\n        // 将原生节点拷贝到fragment\r\n        while (child = el.firstChild) {\r\n            fragment.appendChild(child);\r\n        }\r\n        return fragment;\r\n    },\r\n    //compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定\r\n    compileElement: function(el) {          \r\n        var childNodes = el.childNodes, me = this;\r\n        [].slice.call(childNodes).forEach(function(node) {\r\n            var text = node.textContent;\r\n            var reg = /\\{\\{(.*)\\}\\}/;    // 表达式文本\r\n            // 按元素节点方式编译\r\n            if (me.isElementNode(node)) {\r\n                me.compile(node);\r\n            } else if (me.isTextNode(node) && reg.test(text)) {\r\n                me.compileText(node, RegExp.$1);\r\n            }\r\n            // 遍历编译子节点\r\n            if (node.childNodes && node.childNodes.length) {\r\n                me.compileElement(node);\r\n            }\r\n        });\r\n    },\r\n    compile: function(node) {\r\n        var nodeAttrs = node.attributes, me = this;\r\n        [].slice.call(nodeAttrs).forEach(function(attr) {\r\n            // 规定：指令以 v-xxx 命名\r\n            // 如 <span v-text=\"content\"></span> 中指令为 v-text\r\n            var attrName = attr.name;    // v-text\r\n            if (me.isDirective(attrName)) {\r\n                var exp = attr.value; // content\r\n                var dir = attrName.substring(2);    // text\r\n                if (me.isEventDirective(dir)) {\r\n                    // 事件指令, 如 v-on:click\r\n                    compileUtil.eventHandler(node, me.$vm, exp, dir);\r\n                } else {\r\n                    // 普通指令\r\n                    compileUtil[dir] && compileUtil[dir](node, me.$vm, exp);\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\r\n\r\n// 指令处理集合\r\nvar compileUtil = {\r\n    text: function(node, vm, exp) {\r\n        this.bind(node, vm, exp, \'text\');\r\n    },\r\n    // ...省略\r\n    bind: function(node, vm, exp, dir) {\r\n        var updaterFn = updater[dir + \'Updater\'];\r\n        // 第一次初始化视图\r\n        updaterFn && updaterFn(node, vm[exp]);\r\n        // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher\r\n        new Watcher(vm, exp, function(value, oldValue) {\r\n            // 一旦属性值有变化，会收到通知执行此更新函数，更新视图\r\n            updaterFn && updaterFn(node, value, oldValue);\r\n        });\r\n    }\r\n};\r\n\r\n// 更新函数\r\nvar updater = {\r\n    textUpdater: function(node, value) {\r\n        node.textContent = typeof value == \'undefined\' ? \'\' : value;\r\n    }\r\n};\r\n```\r\n通过递归遍历保证了每个节点及子节点都会解析编译到，监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知\r\n\r\n### Watcher\r\nWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:\r\n1. 在自身实例化时往属性订阅器(dep)里面添加自己\r\n2. 自身必须有一个update()方法\r\n3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。\r\n\r\n```js\r\nfunction Watcher(vm, exp, cb) {\r\n    this.cb = cb;\r\n    this.vm = vm;\r\n    this.exp = exp;\r\n    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解\r\n    this.value = this.get();\r\n}\r\nWatcher.prototype = {\r\n    update: function() {\r\n        this.run();    // 属性值变化收到通知\r\n    },\r\n    run: function() {\r\n        var value = this.get(); // 取到最新值\r\n        var oldVal = this.value;\r\n        if (value !== oldVal) {\r\n            this.value = value;\r\n            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图\r\n        }\r\n    },\r\n    get: function() {\r\n        Dep.target = this;    // 将当前订阅者指向自己\r\n        var value = this.vm[exp];    // 触发getter，添加自己到属性订阅器中\r\n        Dep.target = null;    // 添加完毕，重置\r\n        return value;\r\n    }\r\n};\r\n// 这里再次列出Observer和Dep，方便理解\r\nObject.defineProperty(data, key, {\r\n    get: function() {\r\n        // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除\r\n        Dep.target && dep.addDep(Dep.target);\r\n        return val;\r\n    }\r\n    // ... 省略\r\n});\r\nDep.prototype = {\r\n    notify: function() {\r\n        this.subs.forEach(function(sub) {\r\n            sub.update(); // 调用订阅者的update方法，通知变化\r\n        });\r\n    }\r\n};\r\n```\r\n\r\n实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。\r\n\r\n### 整合\r\n使用Vue作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\r\n```js\r\nfunction Vue(options) {\r\n    this.$options = options;\r\n    var data = this._data = this.$options.data, me = this;\r\n    // 属性代理，实现 vm.xxx -> vm._data.xxx\r\n    Object.keys(data).forEach(function(key) {\r\n        me._proxy(key);\r\n    });\r\n    observe(data, this);\r\n    this.$compile = new Compile(options.el || document.body, this)\r\n}\r\n\r\nVue.prototype = {\r\n    _proxy: function(key) {\r\n        var me = this;\r\n        Object.defineProperty(me, key, {\r\n            configurable: false,\r\n            enumerable: true,\r\n            get: function proxyGetter() {\r\n                return me._data[key];\r\n            },\r\n            set: function proxySetter(newVal) {\r\n                me._data[key] = newVal;\r\n            }\r\n        });\r\n    }\r\n};\r\n```\r\n主要还是利用了`Object.defineProperty()`这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了`vm._data`的属性值\r\n","timestamp":1585877701769},{"name":"09-简单Vue实现.md","path":"001-前端/08-JavaScript/005-js扩展/09-简单Vue实现.md","content":"```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n  <title>简单vue的实现</title>\r\n</head>\r\n\r\n<body>\r\n  <div id=\"app\">\r\n    {{name}}\r\n    {{text.name}}\r\n    <p v-if=\"isShow\">\r\n      <span>{{name}}</span>\r\n    </p>\r\n    <input type=\"text\" id=\"a\" v-model=\"name\">\r\n\r\n  </div>\r\n\r\n  <script>\r\n\r\n    function compile(node, vm) {\r\n\r\n      var reg = /\\{\\{(.*)\\}\\}/;                 //正则验证双大括号\r\n      if (node.nodeType === 1) {               //元素节点\r\n        var attr = Array.from(node.attributes);       \r\n        //解析属性\r\n        for (var i = 0; i < attr.length; i++) {      //遍历元素上的属性，查找特殊的属性，比如v-model和v-if\r\n          if (attr[i].nodeName == \'v-model\') {\r\n            var name = attr[i].nodeValue;\r\n            node.addEventListener(\'input\', function (e) {\r\n\r\n              vm[name] = e.target.value;\r\n              //eval(`vm.data.${name}=e.target.value`)\r\n              console.log(vm)\r\n            })\r\n            node.value = eval(`vm.${name}`);\r\n            node.removeAttribute(\'v-model\');\r\n          }\r\n          if (attr[i].nodeName == \'v-if\') {\r\n            var name = attr[i].nodeValue;\r\n            var isInsert = eval(`vm.${name}`);\r\n            if (!isInsert) {\r\n              node = \'\';\r\n              return node;\r\n            } else {\r\n              node.removeAttribute(\'v-if\');\r\n            }\r\n\r\n          }\r\n        }\r\n\r\n      }\r\n      if (node.nodeType === 3) {              //文本节点        \r\n        if (reg.test(node.nodeValue)) {        //正则验证节点内容是否符合双大括号包裹\r\n          var name = RegExp.$1;          //name是双大括号包裹内容\r\n          //RegExp.$n是非标准的，尽量不要在生产环境中使用。    \r\n          //RegExp.$n（n为1-9之间的数值）指的是与正则表达式匹配的第n个 子匹配(以括号为标志)字符串。\r\n          //RegExp.$_与正则表达式匹配的完整字符串。\r\n          name = name.trim();\r\n          //node.nodeValue = eval(`vm.data.${name}`);\r\n          new Watcher(vm, node, name)//这里给每个属性文本节点生成一个Watcher对象，嗯，大致跟vue的原理相似\r\n        }\r\n      }\r\n      return node;\r\n    }\r\n\r\n    function nodeToFragment(node, vm) {\r\n      var flag = document.createDocumentFragment();     \r\n      var child;\r\n\r\n      while (child = node.firstChild) {\r\n        child = compile(child, vm)\r\n        if (child !== \"\") {\r\n          if (child.childNodes.length != 0) {\r\n            child.append(nodeToFragment(child, vm));\r\n          }\r\n        } else {\r\n          node.removeChild(node.firstChild)\r\n        }\r\n\r\n        flag.append(child);\r\n      }\r\n      return flag;\r\n    }\r\n\r\n    function defineReactive(obj, key, val) {\r\n      var dep = new Dep();//这里给每个属性生成一个数据订阅中心，它可以存储订阅它的所有watcher,\r\n      Object.defineProperty(obj, key, {                //实现双向数据绑定\r\n        get: function () {                             //get获取数据\r\n          if (Dep.target) dep.addSub(Dep.target);//这里的Dep.target是对应的Watcher对象，这里是dep对象调用addSub\r\n          return val;\r\n        },\r\n        set: function (newVal) {                    //set设置数据\r\n          if (newVal === val) return;\r\n          console.log(\'修改了\', key)\r\n\r\n          val = newVal;\r\n          dep.notify();//数据更新了，就通知所有的观察者实例\r\n        }\r\n      })\r\n    }\r\n\r\n    function observer(obj, vm) {                         //遍历obj对象的属性\r\n      Object.keys(obj).forEach(function (key) {\r\n        defineReactive(vm, key, obj[key]);\r\n      })\r\n    }\r\n\r\n    function Watcher(vm, node, name) {\r\n      Dep.target = this;//在实例化新的watcher对象时把Dep.target赋值为this，也就是每个指令对应的那个watcher对象，这样在下面调用this.update,从而调用this.get时触发数据的get方法，从而触发dep.addSub（Dep.target）,这样这个watcher就被添加进去\r\n      this.name = name;\r\n      this.node = node;\r\n      this.vm = vm;\r\n      this.update();\r\n      Dep.target = null;  //为了保证全局只有一个，在最后需要清空，为下一个指令做准备\r\n    }\r\n    Watcher.prototype = {\r\n      update: function () {\r\n        this.get();//更新时调用get()\r\n        this.node.nodeValue = this.value;\r\n\r\n      },\r\n      get: function () {\r\n        this.value = this.vm[this.name]; //会触发vm.data中属性的get方法，进而可以添加watcher到Dep中\r\n      }\r\n    }\r\n\r\n    function Dep() {\r\n      this.subs = [];\r\n    }\r\n    Dep.prototype = {\r\n      addSub: function (sub) {\r\n        this.subs.push(sub);\r\n      },\r\n      notify: function () {\r\n        this.subs.forEach(function (sub) {\r\n          sub.update();\r\n        })\r\n      }\r\n    }\r\n\r\n    function Vue(options) {\r\n      this.data = options.data;\r\n      var id = options.el;\r\n      var data = this.data;\r\n      observer(data, this)             //遍历data对象的属性\r\n      var dom = nodeToFragment(document.getElementById(id), this);\r\n      document.getElementById(id).appendChild(dom);     \r\n    }\r\n\r\n\r\n\r\n\r\n   //简单操作\r\n    var vm = new Vue({\r\n      el: \'app\',\r\n      data: {\r\n        text: {\r\n          name: \'byk\'\r\n        },\r\n        \'name\': \'vue\',\r\n        isShow: true\r\n      }\r\n    })\r\n\r\n  </script>\r\n</body>\r\n\r\n</html>\r\n```\r\n","timestamp":1585877701769},{"name":"11-javascript-MVC.md","path":"001-前端/08-JavaScript/005-js扩展/11-javascript-MVC.md","content":"# javascript中的MVC\r\nMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：        \r\n* Model（模型）是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。\r\n* View（视图）是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。\r\n* Controller（控制器）是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\r\n\r\n\r\n### MVC的基础是观察者模式，这是实现model和view同步的关键\r\n借助观察者模式，实现在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为需要手动监听model值的改变（通过watch方法）并传入一个回调函数，在使用binding方法，绑定model和view\r\n```html\r\n<div id=\"div1\"></div>\r\n<div id=\"div2\"></div>\r\n<script>\r\n\tfunction Model(value) {\r\n\t    this._value = typeof value === \'undefined\' ? \'\' : value;\r\n\t    this._listeners = [];\r\n\t}\r\n\tModel.prototype.set = function (value) {\r\n\t    var self = this;\r\n\t    self._value = value;\r\n\t    // model中的值改变时，应通知注册过的回调函数\r\n\t    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\r\n\t    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\r\n\t    setTimeout(function () {\r\n\t        self._listeners.forEach(function (listener) {\r\n\t            listener.call(self, value);\r\n\t        });\r\n\t\t});\r\n\t};\r\n\tModel.prototype.watch = function (listener) {\r\n\t    // 注册监听的回调函数\r\n\t    this._listeners.push(listener);\r\n\t};\r\n\tModel.prototype.binding = function (node) {\r\n\t    // 将watch的逻辑和通用的回调函数放到这里\r\n\t    this.watch(function (value) {\r\n\t        node.innerHTML = value;\r\n\t    });\r\n\t};\r\n\r\n\r\n  var model = new Model();\r\n  model.binding(document.getElementById(\'div1\'));\r\n  model.binding(document.getElementById(\'div2\'));\r\n  model.set(\'this is a div\');\r\n</script>\r\n```\r\n\r\n### 实现controller，将绑定从逻辑代码中解耦\r\n```html\r\n<div id=\"div1\" bind=\"model1\"></div>\r\n<div id=\"div2\" bind=\"model1\"></div>\r\n<script type=\"text/javascript\">\r\n  function Controller(callback) {\r\n    var models = {};\r\n    // 找到所有有bind属性的元素\r\n    var views = document.querySelectorAll(\'[bind]\');\r\n    // 将views处理为普通数组\r\n    views = Array.prototype.slice.call(views, 0);\r\n    views.forEach(function (view) {\r\n        var modelName = view.getAttribute(\'bind\');\r\n        // 取出或新建该元素所绑定的model\r\n        models[modelName] = models[modelName] || new Model();\r\n        // 完成该元素和指定model的绑定\r\n        models[modelName].binding(view);\r\n    });\r\n    // 调用controller的具体逻辑，将models传入，方便业务处理\r\n    callback.call(this, models);\r\n  }\r\n  new Controller(function (models) {\r\n      var model1 = models.model1;\r\n      model1.set(\'this is a div\');\r\n  });\r\n</script>\r\n```\r\n\r\n### 整合代码\r\n```js\r\nfunction Model(value) {\r\n    this._value = typeof value === \'undefined\' ? \'\' : value;\r\n    this._listeners = [];\r\n}\r\nModel.prototype.set = function (value) {\r\n    var self = this;\r\n    self._value = value;\r\n    setTimeout(function () {\r\n        self._listeners.forEach(function (listener) {\r\n            listener.call(self, value);\r\n        });\r\n    });\r\n};\r\nModel.prototype.watch = function (listener) {\r\n    this._listeners.push(listener);\r\n};\r\nModel.prototype.binding = function (node) {\r\n    this.watch(function (value) {\r\n        node.innerHTML = value;\r\n    });\r\n};\r\nfunction Controller(callback) {\r\n    var models = {};\r\n    var views = Array.prototype.slice.call(document.querySelectorAll(\'[bind]\'), 0);\r\n    views.forEach(function (view) {\r\n        var modelName = view.getAttribute(\'bind\');\r\n        (models[modelName] = models[modelName] || new Model()).binding(view);\r\n    });\r\n    callback.call(this, models);\r\n}\r\n```\r\n\r\n#### 简单使用\r\n```HTML\r\n<span bind=\"hour\"></span> : <span bind=\"minute\"></span> : <span bind=\"second\"></span>\r\n<script type=\"text/javascript\">\r\n// controller:\r\nnew Controller(function (models) {\r\n    function setTime() {\r\n        var date = new Date();\r\n        models.hour.set(date.getHours());\r\n        models.minute.set(date.getMinutes());\r\n        models.second.set(date.getSeconds());\r\n    }\r\n    setTime();\r\n    setInterval(setTime, 1000);\r\n});\r\n</script>\r\n```\r\ncontroller中只负责更新model的逻辑，和view完全解耦；而view和model的绑定是通过view中的属性和框架中controller的初始化代码完成的，也没有出现在业务逻辑中；至于view的更新，也是通过框架中的观察者模式实现的。                 \r\n\r\n在简单的系统中应用MVC模式，会增加结构的复杂性，并且降低效率\r\n","timestamp":1585877701769},{"name":"12-javascript-SPA应用开发.md","path":"001-前端/08-JavaScript/005-js扩展/12-javascript-SPA应用开发.md","content":"# SPA\r\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。\r\n\r\n## 前端路由\r\n随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。\r\n\r\n“更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式：\r\n\r\n* 利用URL中的hash（\"#\"）\r\n* 利用History interface在 HTML5中新增的方法\r\n\r\n### Hash 模式\r\n在 2014 年之前，大家是通过 hash 来实现路由,url hash 就是类似于：\r\n```\r\nhttp://www.xxx.com/#/login\r\n```\r\n\r\n这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：\r\n```js\r\nfunction matchAndUpdate () {\r\n   // todo 匹配 hash 做 dom 更新操作\r\n}\r\n\r\nwindow.addEventListener(\'hashchange\', matchAndUpdate)\r\n```\r\n\r\n### History 模式\r\n14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。\r\n```js\r\nfunction matchAndUpdate () {\r\n   // todo 匹配路径 做 dom 更新操作\r\n}\r\n\r\nwindow.addEventListener(\'popstate\', matchAndUpdate)\r\n```\r\n\r\n## 实现Hash路由模式步骤\r\n1. 切换页面：路由的最大作用就是切换页面，以往后台的路由是直接改变了页面的url方式促使页面刷新。但是前端路由通过 # 号不能刷新页面，只能通过 window 的监听事件 hashchange 来监听hash的变化，然后捕获到具体的hash值进行操作\r\n```js\r\n//路由切换\r\nwindow.addEventListener(\'hashchange\',function(){\r\n    //do something\r\n    this.hashChange()\r\n})\r\n```\r\n2. 注册路由：我们需要把路由规则注册到页面，这样页面在切换的时候才会有不同的效果。\r\n```js\r\n//注册函数\r\n map:function(path,callback){\r\n   path = path.replace(/\\s*/g,\"\");//过滤空格\r\n   //在有回调，且回调是一个正确的函数的情况下进行存储 以 /name 为key的对象 {callback:xx}\r\n   if(callback && Object.prototype.toString.call(callback) === \'[object Function]\' ){\r\n       this.routers[path] ={\r\n            callback:callback,//回调\r\n            fn:null //存储异步文件状态，用来记录异步的js文件是否下载，下文有提及\r\n        }\r\n    }else{\r\n    //打印出错的堆栈信息\r\n        console.trace(\'注册\'+path+\'地址需要提供正确的的注册回调\')\r\n    }\r\n }\r\n //调用方式\r\n map(\'/detail\',function(transition){\r\n})\r\n```\r\n3. 异步加载js：一般单页面应用为了性能优化，都会把各个页面的文件拆分开，按需加载，所以路由里面要加入异步加载js文件的功能。异步加载我们就采用最简单的原生方法，创建script标签，动态引入js。\r\n```js\r\nvar _body= document.getElementsByTagName(\'body\')[0],\r\n    scriptEle= document.createElement(\'script\');\r\nscriptEle.type= \'text/javascript\';\r\nscriptEle.src= xxx.js;\r\nscriptEle.async = true;\r\nscriptEle.onload= function(callback){\r\n    //为了避免重复引入js，我们需要在这里记录一下已经加载过的文件，对应的 fn需要赋值处理\r\n    callback()\r\n}\r\n_body.appendChild(scriptEle);   \r\n```\r\n4. 参数传递：在我们动态引入单独模块的js之后，我们可能需要给这个模块传递一些单独的参数。这里借鉴了一下jsonp的处理方式，我们把单独模块的js包装成一个函数，提供一个全局的回调方法，加载完成时候再调用回调函数。\r\n```js\r\nSPA_RESOLVE_INIT = function(transition) {\r\n    document.getElementById(\"content\").innerHTML = \'<p style=\"color:#F8C545;\">当前异步渲染列表页\'+ JSON.stringify(transition) +\'</p>\'\r\n    console.log(\"首页回调\" + JSON.stringify(transition))\r\n}\r\n```\r\n5. 以上我们已经完成了基本功能，我们再对齐进行扩展，在页面切换之前beforeEach和切换完成afterEach的时候增加2个方法进行处理。思路是，注册了这2个方法之后，在切换之前就调用beforeEach，切换之后，需要等待下载js完成，在onload里面进行调用 afterEach\r\n```js\r\n//切换之前一些处理\r\nbeforeEach:function(callback){\r\n   if(Object.prototype.toString.call(callback) === \'[object Function]\'){\r\n       this.beforeFun = callback;\r\n   }else{\r\n       console.trace(\'路由切换前钩子函数不正确\')\r\n   }\r\n},\r\n//切换成功之后\r\nafterEach:function(callback){\r\n   if(Object.prototype.toString.call(callback) === \'[object Function]\'){\r\n       this.afterFun = callback;\r\n   }else{\r\n       console.trace(\'路由切换后回调函数不正确\')\r\n   }\r\n}\r\n```\r\n\r\n\r\n## 完整\r\n```js\r\n/*\r\n**使用方法\r\n*       1：注册路由 : spaRouters.map(\'/name\',function(transition){\r\n                        //异步加载js\r\n                        spaRouters.asyncFun(\'name.js\',transition)\r\n                        //或者同步执行回调\r\n                        spaRouters.syncFun(function(transition){},transition)\r\n                    })\r\n        2：初始化      spaRouters.init()\r\n        3：跳转  href = \'#/name\'           \r\n*/\r\nvar util = {\r\n    //获取路由的路径和详细参数\r\n    getParamsUrl:function(){\r\n        var hashDeatail = location.hash.split(\"?\"),\r\n            hashName = hashDeatail[0].split(\"#\")[1],//路由地址\r\n            params = hashDeatail[1] ? hashDeatail[1].split(\"&\") : [],//参数内容\r\n            query = {};\r\n        for(var i = 0;i<params.length ; i++){\r\n            var item = params[i].split(\"=\");\r\n            query[item[0]] = item[1]\r\n        }       \r\n        return  {\r\n            path:hashName,\r\n            query:query\r\n        }\r\n    }\r\n}\r\nfunction spaRouters(){\r\n    this.routers = {};//保存注册的所有路由\r\n    this.beforeFun = null;//切换前\r\n    this.afterFun = null;\r\n}\r\nspaRouters.prototype={\r\n    init:function(){\r\n        var self = this;\r\n        //页面加载匹配路由\r\n        window.addEventListener(\'load\',function(){\r\n            self.urlChange()\r\n        })\r\n        //路由切换\r\n        window.addEventListener(\'hashchange\',function(){\r\n            self.urlChange()\r\n        })\r\n        //异步引入js通过回调传递参数\r\n        window.SPA_RESOLVE_INIT = null;\r\n    },\r\n    refresh:function(currentHash){\r\n        var self = this;\r\n        if(self.beforeFun){\r\n            self.beforeFun({\r\n                to:{\r\n                    path:currentHash.path,\r\n                    query:currentHash.query\r\n                },\r\n                next:function(){\r\n                    self.routers[currentHash.path].callback.call(self,currentHash)\r\n                }\r\n            })\r\n        }else{\r\n            self.routers[currentHash.path].callback.call(self,currentHash)\r\n        }\r\n    },\r\n    //路由处理\r\n    urlChange:function(){\r\n        var currentHash = util.getParamsUrl();\r\n        if(this.routers[currentHash.path]){\r\n            this.refresh(currentHash)\r\n        }else{\r\n            //不存在的地址重定向到首页\r\n            location.hash = \'/index\'\r\n        }\r\n    },\r\n    //单层路由注册\r\n    map:function(path,callback){\r\n        path = path.replace(/\\s*/g,\"\");//过滤空格\r\n        if(callback && Object.prototype.toString.call(callback) === \'[object Function]\' ){\r\n            this.routers[path] ={\r\n                callback:callback,//回调\r\n                fn:null //存储异步文件状态\r\n            }\r\n        }else{\r\n            console.trace(\'注册\'+path+\'地址需要提供正确的的注册回调\')\r\n        }\r\n    },\r\n    //切换之前一些处理\r\n    beforeEach:function(callback){\r\n        if(Object.prototype.toString.call(callback) === \'[object Function]\'){\r\n            this.beforeFun = callback;\r\n        }else{\r\n            console.trace(\'路由切换前钩子函数不正确\')\r\n        }\r\n    },\r\n    //切换成功之后\r\n    afterEach:function(callback){\r\n        if(Object.prototype.toString.call(callback) === \'[object Function]\'){\r\n            this.afterFun = callback;\r\n        }else{\r\n            console.trace(\'路由切换后回调函数不正确\')\r\n        }\r\n    },\r\n    //路由异步懒加载js文件\r\n    asyncFun:function(file,transition){\r\n       var self = this;\r\n       if(self.routers[transition.path].fn){\r\n            self.afterFun && self.afterFun(transition)  \r\n            self.routers[transition.path].fn(transition)\r\n       }else{\r\n           console.log(\"开始异步下载js文件\"+file)\r\n           var _body= document.getElementsByTagName(\'body\')[0];\r\n           var scriptEle= document.createElement(\'script\');\r\n           scriptEle.type= \'text/javascript\';\r\n           scriptEle.src= file;\r\n           scriptEle.async = true;\r\n           SPA_RESOLVE_INIT = null;\r\n           scriptEle.onload= function(){\r\n               console.log(\'下载\'+file+\'完成\')\r\n               self.afterFun && self.afterFun(transition)   \r\n               self.routers[transition.path].fn = SPA_RESOLVE_INIT;\r\n               self.routers[transition.path].fn(transition)\r\n           }\r\n           _body.appendChild(scriptEle);        \r\n       }        \r\n    },\r\n    //同步操作\r\n    syncFun:function(callback,transition){\r\n        this.afterFun && this.afterFun(transition)\r\n        callback &&　callback(transition)\r\n    }\r\n}\r\n//注册到window全局\r\nwindow.spaRouters = new spaRouters();\r\n```\r\n","timestamp":1585877701769},{"name":"13-算法.md","path":"001-前端/08-JavaScript/005-js扩展/13-算法.md","content":"算法+数据结构=程序                    \r\n数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作\r\n# 算法\r\n算法是规则的有限集合，是为解决特定问题而规定的一系列操作\r\n\r\n## 算法的特性\r\n1. 有限性：有限步骤之内正常结束，不能形成无穷循环\r\n2. 确定性：算法中的每一个步骤必须有明确的含义，无二义性\r\n3. 可行性：原则上能精确进行，操作可通过已实现的基本运算执行有限次而完成\r\n4. 输入：有多个或者0个输出\r\n5. 输出：有至少一个输出\r\n\r\n## 算法的设计要求\r\n正确性、可读性、健壮性(鲁棒性)、高效率和低储存量                      \r\n\r\n## 算法的复杂度\r\n算法的时间复杂度和空间复杂度合称为算法的复杂度。                         \r\n一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。     \r\n\r\n### 时间复杂度\r\n时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。                      \r\n\r\n\r\n常见的算法时间复杂度以及他们在效率上的高低顺序记录：                  \r\nO(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) < O(n^2) 平方阶 < O(n^3) < { O(2^n) < O(n!) < O(n^n) }      \r\n\r\n设计的算法推导出的“大O阶”是大括号中的这几位，就需要重新研究新的算法出来，因为大括号中的这几位即便是在 n 的规模比较小的情况下仍然要耗费大量的时间，算法的时间复杂度大的离谱，基本上就是“不可用状态”。             \r\n\r\n大O推导法：\r\n1. 用常数1取代运行时间中的所有加法常数。\r\n2. 在修改后的运行次数函数中，只保留最髙阶项。\r\n3. 如果最高阶项存在且不是1,则去除与这个项相乘的常数。\r\n\r\n```js\r\nvar i=j=x=0, sum = 0, n = 100;      //执行1次\r\nfor( i = 1; i <= n; i++){\r\n    sum = sum + i;\r\n    for( j = 1; j <= n; j++){       \r\n        x++;                // 执行n*n次\r\n        sum = sum + x;\r\n    }\r\n}\r\nconsole.log(\'时间复杂度\');            //执行1次\r\n\r\n//执行总次数 = 1 + (n + 1) + n*(n + 1) + n*n + (n + 1) + 1 = 2n2 + 3n + 3\r\n/*\r\n通过大O推导法得出：\r\n1. 执行总次数 = 2n^2 + 3n + 1\r\n2. 执行总次数 = 2n^2\r\n3. 执行总次数 = n^2\r\n*/\r\n//算法时间复杂度表示为： O( n^2 )\r\n```\r\n\r\n```js\r\nfunction fun(n){\r\n  for (int i = 0; i < n; i++) {                   //执行n次\r\n        for (int j = i; j < n; j++) {            //执行次数逐渐递减 (n - 1) + (n - 2)……\r\n            printf(\"Hello World\\n\");\r\n        }\r\n    }\r\n}\r\n//执行次数= n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2\r\n/*\r\n通过大O推导法得出：\r\n1. 执行总次数 = n^2 / 2 + n / 2\r\n2. 执行总次数 = n^2 / 2\r\n3. 执行总次数 = n^2\r\n*/\r\n//算法时间复杂度表示为： O( n^2 )\r\n```\r\n\r\n算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。                 \r\n\r\n### 空间复杂度\r\n在写代码时，完全可以用空间来换去时间。             \r\n\r\n一个程序的空间复杂度是指运行完一个程序所需内存的大小。算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。                                 \r\n\r\n算法执行时所需的存储空间包括以下两部分:                 \r\n1. 固定部分。这部分空间的大小与输入/输出的数据的个数、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。\r\n2. 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。               \r\n\r\n空间复杂度计算方法:                  \r\n* 忽略常数，用O(1)表示\r\n* 递归算法的空间复杂度=递归深度N*每次递归所要的辅助空间\r\n* 对于单线程来说，递归有运行时堆栈，求的是递归最深的那一次压栈所耗费的空间的个数，因为递归最深的那一次所耗费的空间足以容纳它所有递归过程。                         \r\n\r\n当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。\r\n\r\n\r\n```js\r\nvar a=1;\r\nvar b=2;\r\nconsole.log(a,b);\r\n//空间复杂度O（n）=O（1）；\r\n```\r\n```js\r\nfunction fun(n){\r\n  k = 10\r\n  if n == k{\r\n    return n\r\n  }else{\r\n    return fun(++n)\r\n  }  \r\n}\r\n//调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O（n*1）=O（n)。\r\n```\r\n```js\r\nfor(var i=0;i<n;i++){\r\n  var temp = i;\r\n}\r\n//变量的内存分配发生在定义的时候，因为temp的定义是循环里边，所以是n*O(1)\r\n\r\n\r\ntemp=0;\r\nfor(i=0;i<n;i++){\r\n  temp = i\r\n}\r\n//temp定义在循环外边，所以是1*O(1)\r\n```\r\n\r\n\r\n## 算法性能选择\r\n要节约算法的执行时间往往要以牺牲更多的空间为代价，而为了节省空间可能要消耗更多的计算时间        \r\n1. 若程序使用次数较少，则力求算法简明易懂\r\n2. 对于反复使用的程序，应尽可能选择快速的算法\r\n3. 若待解决的问题数据量极大，计算机的存储空间较小，则相应算法主要考虑如何节省空间\r\n\r\n\r\n## 排序算法\r\n- 十大排序算法总结   \r\n![排序算法复杂度](amWiki/images/排序算法复杂度.jpg)\r\nhttps://www.cnblogs.com/jztan/p/5878630.html\r\n- 用HTML5实现的各种排序算法的动画比较   \r\nhttp://www.webhek.com/post/comparison-sort.html\r\n\r\n## 查找算法\r\n线性查找效率最慢，可对无序列表进行查找、               \r\n二分查找效率最快，只能针对有序列表进行查找          \r\n\r\n\r\n\r\n### 基于线性表的查找法\r\n- 二分查找(折半查找)        \r\n二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。\r\n```js\r\nfunction binarySearch(data, dest, start, end){\r\n    var end = end || data.length - 1,\r\n        start = start || 0,\r\n        m = Math.floor((start + end) / 2);\r\n    if(data[m] == dest){\r\n        return m;\r\n    }\r\n    if(dest < data[m]){\r\n        return binarySearch(data, dest, 0, m-1);\r\n    }else{\r\n        return binarySearch(data, dest, m+1, end);\r\n    }\r\n\r\n    return false;\r\n}\r\nvar arr = [-34, 1, 3, 4, 5, 8, 34, 45, 65, 87];\r\nbinarySearch(arr,4);          //3\r\n```\r\n\r\n#### 分块查找法(索引顺序查找)\r\n分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。\r\n\r\n\r\n### 基于树的查找法\r\n#### 二叉排序树(二叉查找树、二叉搜索树)\r\n二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：\r\n   1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\r\n   2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\r\n   3. 左、右子树也分别为二叉排序树；\r\n   4. 没有键值相等的节点。\r\n\r\n##### 创建二叉搜索树\r\n\r\n```js\r\nfunction BinaryTree(){\r\n    var Node=function(key){         //节点函数\r\n        this.key=key;\r\n        this.left=null;\r\n        this.right=null;\r\n    }\r\n    var root=null;                  //根元素\r\n    this.insert=function(key){      //对外提供访问函数内部的接口\r\n        var newNode=new Node(key);\r\n        if(root==null){\r\n            root=newNode\r\n        }else{\r\n            insertNode(root,newNode);\r\n        }\r\n    }\r\n    var insertNode=function(node,newNode){//创建相互关系的根实体\r\n        if(node.key>newNode.key){\r\n            if(node.left==null){\r\n                node.left=newNode;\r\n            }else{\r\n                insertNode(node.left,newNode)\r\n            }\r\n        }else{\r\n            if(node.right==null){\r\n                node.right=newNode\r\n            }else{\r\n                insertNode(node.right,newNode)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n>二叉树是每个结点最多有两个子树的有序树。\r\n\r\n##### 二叉树的排序\r\n1. 中序遍历\r\n>先左后根最后右\r\n\r\n```js\r\nvar inOrderTraverseNode=function(node,callback){\r\n    if(node!=null){\r\n        inOrderTraverseNode(node.left,callback)\r\n        callback(node.key)\r\n        inOrderTraverseNode(node.right,callback)\r\n    }\r\n}\r\n\r\nthis.inOrderTraverse=function(callback){\r\n    inOrderTraverseNode(root,callback);\r\n}\r\n```\r\n\r\n\r\n2. 前序遍历    可以很有效率的复制一个二叉树对象\r\n>根节点排最先，然后同级先左后右\r\n\r\n```js\r\nvar proOrderTraverseNode=function(node,callback){\r\n    if(node!=null){\r\n        callback(node.key)\r\n        proOrderTraverseNode(node.left,callback)\r\n        proOrderTraverseNode(node.right,callback)\r\n    }\r\n}\r\n//前序遍历  复制   效率高得多\r\nthis.proOrderTraverse=function(callback){\r\n    proOrderTraverseNode(root,callback);\r\n}\r\n```\r\n\r\n3. 后序遍历      选查找子集的特性可以运用在文件系统遍历当中\r\n>先左后右最后根\r\n\r\n```js\r\nvar postOrderTraverseNode=function(node,callback){\r\n    if(node!=null){\r\n        postOrderTraverseNode(node.left,callback)\r\n        postOrderTraverseNode(node.right,callback)\r\n        callback(node.key)\r\n    }\r\n}\r\n//后续遍历  文件系统遍历\r\nthis.postOrderTraverse=function(callback){\r\n    postOrderTraverseNode(root,callback);\r\n}\r\n```\r\n\r\n4. 测试：\r\n```js\r\n// 前序遍历\r\nvar nodes=[8,3,10,1,6,14,4,7,13];\r\nvar binaryTree=new BinaryTree();\r\nnodes.forEach(function(key){\r\n    binaryTree.insert(key);\r\n})\r\nvar callback=function(key){\r\n    console.log(key)\r\n}\r\nbinaryTree.inOrderTraverse(callback)\r\n```\r\n\r\n\r\n##### 查找\r\n1. 查找指定值\r\n```js\r\nvar searchNode=function(node,key){\r\n    if(node==null){\r\n        return false\r\n    }\r\n    if(node.key>key){  //小于当前node往左找\r\n        searchNode(node.left,key)\r\n    }else if(node.key<key){ //大于当前node往右找\r\n        searchNode(node.right,key)\r\n    }else{ // 找到\r\n        return true;\r\n    }\r\n}\r\nthis.search=function(key){\r\n    return searchNode(root,key)\r\n}\r\n```\r\n2. 查找最值\r\n```js\r\n// 最大值\r\nvar maxNode=function(node){\r\n    if(node){\r\n        while(node&&node.right!=null){\r\n            node=node.left\r\n        }\r\n        return node.key;\r\n    }\r\n}\r\nthis.max=function(){\r\n    return maxNode(root)\r\n}\r\n// 最小值\r\nvar minNode=function(node){\r\n    if(node){\r\n        while(node&&node.left!=null){\r\n            node=node.left\r\n        }\r\n\r\n        return node.key;\r\n    }\r\n}\r\nthis.min=function(){\r\n    return minNode(root)\r\n}\r\n```\r\n\r\n### 计算式查找法————哈希法\r\n根据关键字（key)而直接访问在内存储存位置\r\n\r\n\r\n## 简单算法题\r\n* 给定一个包含非负整数的mxn网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。        \r\n说明：每次只能向下或者向右移动一步。   \r\n输入:\r\n[\r\n  [1,3,1],\r\n  [1,5,1],\r\n  [4,2,1]\r\n]\r\n输出: 7\r\n解释: 因为路径 1→3→1→1→1 的总和最小。\r\n```js\r\nvar minPathSum = function(grid) {  \r\n    var n = grid.length\r\n    if(n == 0) return 0\r\n    for(let i = 0; i < n; i++){\r\n        for(let j = 0; j < grid[i].length; j++){              \r\n            if(!i && !j) continue\r\n            grid[i][j] = Math.min((i ? grid[i - 1][j] : Number.MAX_VALUE),(j ? grid[i][j - 1] : Number.MAX_VALUE)) + grid[i][j]\r\n        }\r\n    }\r\n    return grid[n - 1][grid[0].length - 1]\r\n};\r\n```\r\n\r\n* 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。           \r\n最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。         \r\n你可以假设除了整数 0 之外，这个整数不会以零开头。             \r\n* 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\r\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\r\n注意：给定 n 是一个正整数。\r\n\r\n```\r\n示例 1：\r\n\r\n输入： 2\r\n输出： 2\r\n解释： 有两种方法可以爬到楼顶。\r\n1.  1 阶 + 1 阶\r\n2.  2 阶\r\n示例 2：\r\n\r\n输入： 3\r\n输出： 3\r\n解释： 有三种方法可以爬到楼顶。\r\n1.  1 阶 + 1 阶 + 1 阶\r\n2.  1 阶 + 2 阶\r\n3.  2 阶 + 1 阶\r\n```\r\n\r\n* 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。\r\n```\r\n输入:\r\n[\r\n  [1,1,1],\r\n  [1,0,1],\r\n  [1,1,1]\r\n]\r\n输出:\r\n[\r\n  [1,0,1],\r\n  [0,0,0],\r\n  [1,0,1]\r\n]\r\n```\r\n```js\r\nvar setZeroes = function(matrix) {\r\n    const cached = [];\r\n    const a = matrix.length;\r\n    const b = matrix[0].length;\r\n\r\n    for (const i of matrix.keys()) {\r\n        for (const j of matrix[i].keys()) {\r\n            if(matrix[i][j] === 0) {\r\n                cached.push(\r\n                        ...Array(b).fill().map((_, k) => [i, k]),\r\n                        ...Array(a).fill().map((_, k) => [k, j]),\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const [x, y] of cached) {\r\n        matrix[x][y] = 0;\r\n    }\r\n\r\n    return matrix;\r\n};\r\n```\r\n\r\n* 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\r\n```\r\n输入: n = 4, k = 2\r\n输出:\r\n[\r\n  [2,4],\r\n  [3,4],\r\n  [2,3],\r\n  [1,2],\r\n  [1,3],\r\n  [1,4],\r\n]\r\n```\r\n```js\r\nvar combine = function(n, k) {\r\n    const arr = Array(n).fill().map((_,index) => index + 1);\r\n    const buffer = [];\r\n    const result = [];\r\n\r\n    const backTrace = (index, target) => {\r\n        if(target == 0) {\r\n            return result.push(buffer.slice());\r\n        }\r\n\r\n        if(index === arr.length) return;\r\n\r\n        buffer.push(arr[index]);\r\n        backTrace(index + 1, target - 1);\r\n        buffer.pop();\r\n\r\n        backTrace(index + 1, target);\r\n    }\r\n    backTrace(0, k);\r\n\r\n    return result;\r\n};\r\n```\r\n\r\n* 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。\r\n```\r\n例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.\r\n与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).\r\n```\r\n```js\r\nvar threeSumClosest = function(nums, target) {\r\n    nums.sort(function(a, b) {\r\n        return a - b\r\n    })\r\n    let res = nums[0] + nums[1] + nums[2]\r\n    let cur = 0\r\n    let diff = Math.abs(nums[0] + nums[1] + nums[2] -target)\r\n    for(let i=0;i<nums.length - 2; i++) {\r\n        let j = i + 1\r\n        let k = nums.length - 1\r\n        while(j<k) {\r\n\t    cur = nums[i] + nums[j] + nums[k]\r\n            if(Math.abs(cur - target) < diff) {\r\n                diff = Math.abs(cur - target)\r\n                res = cur\r\n            }\r\n            if(cur < target) {\r\n                j++\r\n            } else {\r\n                k--\r\n            }\r\n        }\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n\r\n* 给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\r\n```\r\n输入:\r\n[\r\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\r\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\r\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\r\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\r\n]\r\n输出: 6\r\n```\r\n\r\n\r\n* 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。                \r\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\r\n```\r\n输入: [3,4,5,1,3,null,1]\r\n     3\r\n    / \\\r\n   4   5\r\n  / \\   \\\r\n 1   3   1\r\n输出: 9\r\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\r\n输入: [3,2,3,null,3,null,1]\r\n     3\r\n    / \\\r\n   2   3\r\n    \\   \\\r\n     3   1\r\n输出: 7\r\n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\r\n```\r\n\r\n\r\n* 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。            \r\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)\r\n```\r\n你可以假设两个字符串均只含有小写字母。\r\ncanConstruct(\"a\", \"b\") -> false\r\ncanConstruct(\"aa\", \"ab\") -> false\r\ncanConstruct(\"aa\", \"aab\") -> true\r\n```\r\n\r\n* 使用栈实现队列的下列操作：        \r\npush(x) -- 将一个元素放入队列的尾部。        \r\npop() -- 从队列首部移除元素。           \r\npeek() -- 返回队列首部的元素。         \r\nempty() -- 返回队列是否为空。\r\n\r\n```\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);  \r\nqueue.peek();  // 返回 1\r\nqueue.pop();   // 返回 1\r\nqueue.empty(); // 返回 false\r\n```\r\n\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.input = []\r\n    this.output = []\r\n    this.size = 0\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.input.push(x)\r\n    this.size += 1\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.output.length === 0) {\r\n      for(var i = 0; i < this.size; i++) {\r\n        this.output[this.size-i-1] = this.input[i]\r\n      }   \r\n      this.size = 0\r\n      this.input = []\r\n    }\r\n    return this.output.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.output.length === 0) {\r\n      for(var i = 0; i < this.size; i++) {\r\n        this.output[this.size-i-1] = this.input[i]\r\n      }   \r\n      this.size = 0\r\n      this.input = []\r\n    }\r\n    return this.output[this.output.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return (this.output.length===0&&this.size===0)\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = Object.create(MyQueue).createNew()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n* 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。           \r\n在杨辉三角中，每个数是它左上方和右上方的数的和。\r\n```\r\n输入: 3\r\n输出: [1,3,3,1]\r\n```\r\n\r\n```js\r\nvar getRow = function(numRows) {\r\n    if (numRows === 0) return [1];\r\n\r\n    const result = [[1]];\r\n\r\n    for (let index = 1; index < numRows + 1; index++) {\r\n        const last = result[result.length - 1];\r\n        result.push(Array(index + 1).fill(1).map((_, ind) => (last[ind] || 0) + (last[ind - 1] || 0)))\r\n    }\r\n\r\n    return result[numRows];\r\n};\r\n```\r\n\r\n* 优势洗牌      (田忌赛马)\r\n给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] > B[i]的索引i的数目来描述。          \r\n返回 A 的任意排列，使其相对于 B 的优势最大化。\r\n\r\n```\r\n输入：A = [2,7,11,15], B = [1,10,4,11]\r\n输出：[2,11,7,15]  \r\n\r\n输入：A = [12,24,8,32], B = [13,25,32,11]\r\n输出：[24,32,8,12]\r\n```\r\n\r\n\r\n\r\n```js\r\nvar advantageCount = function(A, B) {\r\n    var arr = [];\r\n    A.sort(function(a, b) {\r\n        return a - b;\r\n              });\r\n    B.forEach(function(item) {\r\n        var index = A.findIndex(function(_item) {\r\n            return _item > item;\r\n        });\r\n    if (index > -1) {\r\n        arr.push(A.splice(index, 1)[0]);\r\n        } else  {\r\n            arr.push(A.splice(0, 1)[0]);\r\n        } });\r\n    return arr;\r\n};\r\n```\r\n\r\n* 给定两个二叉树，编写一个函数来检验它们是否相同。\r\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\r\n\r\n```\r\n输入:       1         1\r\n          / \\       / \\\r\n         2   3     2   3\r\n\r\n        [1,2,3],   [1,2,3]\r\n\r\n输出: true\r\n\r\n输入:      1          1\r\n          /           \\\r\n         2             2\r\n\r\n        [1,2],     [1,null,2]\r\n\r\n输出: false\r\n\r\n输入:       1         1\r\n          / \\       / \\\r\n         2   1     1   2\r\n\r\n        [1,2,1],   [1,1,2]\r\n\r\n输出: false\r\n```\r\n```js\r\nvar isSameTree = function(p, q) {\r\n    const queue = [[p, q]];\r\n    while(queue.length) {\r\n        const [cp, cq] = queue.shift();\r\n        if(!cp && !cq) continue;\r\n        if(!cp && cq || cp && !cq) {\r\n            return false;\r\n        }\r\n        if(cp.val !== cq.val) {\r\n            return false;\r\n        }\r\n        queue.push([cp.left, cq.left], [cp.right, cq.right])\r\n    }\r\n    return true;\r\n};\r\n```\r\n\r\n* 给定一个二叉树，判断其是否是一个有效的二叉搜索树。             \r\n假设一个二叉搜索树具有如下特征：                  \r\n节点的左子树只包含小于当前节点的数。                   \r\n节点的右子树只包含大于当前节点的数。                 \r\n所有左子树和右子树自身必须也是二叉搜索树。\r\n\r\n```\r\n输入:\r\n    2\r\n   / \\\r\n  1   3\r\n输出: true\r\n\r\n输入:\r\n    5\r\n   / \\\r\n  1   4\r\n     / \\\r\n    3   6\r\n输出: false\r\n解释: 输入为: [5,1,4,null,null,3,6]。\r\n     根节点的值为 5 ，但是其右子节点值为 4 。\r\n```\r\n\r\n```js\r\nvar inorderTraversal = function(root) {\r\n    const result = [];\r\n    const inorder = node => {\r\n        if(!node) return;\r\n        inorder(node.left);\r\n        result.push(node.val);\r\n        inorder(node.right);\r\n    }\r\n    inorder(root);\r\n    return result;\r\n};\r\n\r\nvar isValidBST = function(root) {\r\n    const arr = inorderTraversal(root);\r\n    return arr.every((item, index) => item > (index > 0 ? arr[index - 1] : -Infinity));\r\n};\r\n```\r\n\r\n* 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\r\n```\r\n输入: 3\r\n输出: 5\r\n解释:\r\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n```\r\n","timestamp":1585877701769},{"name":"14-WebSocket.md","path":"001-前端/08-JavaScript/005-js扩展/14-WebSocket.md","content":"# WebSocket\r\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。        \r\n\r\nWebsocket 其实是一个新协议，跟 HTTP 协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。          \r\n\r\n## WebSocket兼容性\r\n<iframe style=\"width:100%; min-height: 300px;\" src=\"caniuse/1.html?style=es5\" frameborder=\"0\"></iframe>\r\n\r\n## 解决的问题\r\nHTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。\r\n\r\n这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。\r\n\r\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步JavaScript和XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。        \r\n\r\nWebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\r\n\r\n## WebSocket 如何工作\r\nWeb浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的HTTP连接不同，对服务器有重要的影响。\r\n\r\n基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。\r\n\r\n## WebSocket在客户端实现\r\n在客户端，没有必要为 WebSockets 使用 JavaScript 库。实现 WebSockets 的 Web 浏览器将通过 WebSockets 对象公开所有必需的客户端功能（主要指支持 Html5 的浏览器）。         \r\n\r\n### 客户端\r\n创建 WebSocket 对象\r\n```js\r\nvar Socket = new WebSocket(url, [protocol] );\r\n```        \r\n第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。\r\n#### WebSocket 属性\r\n| 属性 | 描述 |\r\n| ---- | ---- |\r\n| readyState | 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。  |\r\n|  bufferedAmount  |  只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 |\r\n\r\n#### WebSocket 方法\r\n| 方法名 | 描述 |\r\n| ---- | ---- |\r\n| send | 使用连接发送数据 |\r\n|  close |  关闭连接  |\r\n\r\n#### WebSocket 事件\r\n| 事件名称 | 描述 |\r\n|---- | ---- |\r\n|  open  | 连接建立时触发  |  \r\n| message  |  客户端接收服务端数据时触发 |\r\n|  error | 通信发生错误时触发  |\r\n|  close | 连接关闭时触发  |\r\n\r\n```js\r\n// 初始化一个 WebSocket 对象\r\nvar ws = new WebSocket(\"ws://localhost:9998/echo\");\r\n\r\n// 建立 web socket 连接成功触发事件\r\nws.onopen = function () {\r\n  // 使用 send() 方法发送数据\r\n  ws.send(\"发送数据\");\r\n  alert(\"数据发送中...\");\r\n};\r\n\r\n// 接收服务端数据时触发事件\r\nws.onmessage = function (evt) {\r\n  var received_msg = evt.data;\r\n  alert(\"数据已接收...\");\r\n};\r\n\r\n// 断开 web socket 连接成功触发事件\r\nws.onclose = function () {\r\n  alert(\"连接已关闭...\");\r\n};\r\n```\r\n\r\n## WebSocket在服务器端实现\r\nWebSocket服务端的实现不受平台和开发语言的限制，只需要遵从WebSocket规范即可                   \r\n\r\n### Nodejs\r\n1. 安装ws模块   ws是nodejs的一个WebSocket库，可以用来创建服务。                    \r\n`npm install ws`\r\n2. 在项目里面新建一个server.js，创建服务，指定8181端口，将收到的消息log出来。\r\n```js\r\nvar WebSocketServer = require(\'ws\').Server,\r\nwss = new WebSocketServer({ port: 8181 });\r\nwss.on(\'connection\', function (ws) {\r\n    console.log(\'index connected\');\r\n    ws.on(\'message\', function (message) {\r\n        console.log(message);\r\n    });\r\n});\r\n```\r\n3. 建立一个index.html在页面上建立一个WebSocket的连接。用send方法发送消息。\r\n```js\r\nvar ws = new WebSocket(\"ws://localhost:8181\");\r\n    ws.onopen = function (e) {\r\n        console.log(\'Connection to server opened\');\r\n    }\r\n    function sendMessage() {\r\n        ws.send($(\'#message\').val());\r\n    }\r\n```\r\n\r\n\r\n## 案例\r\n实现一个即时通讯，多人聊天室\r\n","timestamp":1585877701769},{"name":"001-jQuery简介.md","path":"001-前端/08-JavaScript/006-jQuery/001-jQuery基础/001-jQuery简介.md","content":"#  jQuery原理\r\n> jQuery是一个快速的、小型化的包含丰富内容的javascript函数库， 它通过一些方便使用的API让我们对于文档遍历和操作、事件处理、动画和Ajax更易操作，并且很好的处理了浏览器兼容性， 通过通用性和可扩展性的相结合，jQuery已经改变了数以百万计的人写JavaScript代码的方式。\r\n\r\n  [下载地址](http://jquery.com/download/)\r\n  \r\n## jQuery版本\r\n\r\n * jQuery1.x.x  \r\n  > 1 表示这个版本的jQuery是支持ie6 7 8的，后面两个分别代表大的版本号的小的版本号。\r\n\r\n * jQuery2.x.x\r\n  >2 表示这个版本的jQuery是不支持ie 6 7 8的，后面两个分别代表大的版本号的小的版本号。  \r\n\r\n * jQuery3.x.x\r\n  >3是最新版本的jQuery，包含了一些重大的改进。不支持ie 6 7 8,后面两个分别代表大的版本号的小的版本号。   \r\n\r\n  [文档下载]（http://jquery.cuishifeng.cn/）\r\n\r\n## jQuery特点\r\n\r\n* 查询\r\n* 隐式循环\r\n* 链式调用\r\n\r\n## cdn\r\n  * http://www.bootcdn.cn/jquery/\r\n  * https://code.jquery.com/\r\n  * http://cdn.code.baidu.com/\r\n","timestamp":1585877701769},{"name":"002-jQuery基本操作和核心.md","path":"001-前端/08-JavaScript/006-jQuery/001-jQuery基础/002-jQuery基本操作和核心.md","content":"# jQuery基本操作和核心\r\n\r\n## 核心\r\n * 重点理解方法\r\n   * $(selector[,context])\r\n   * $(html[,ownerdoc])\r\n   * $(callback)\r\n   * each()\r\n   * get()\r\n   * index()\r\n   * data()\r\n   * queue()\r\n   * extend()\r\n   * noConflict()\r\n## 筛选\r\n * 重点理解方法\r\n    * eq()\r\n    * map()\r\n    * filter()\r\n    * find()\r\n    * siblings()\r\n    * end()\r\n\r\n## 属性\r\n * 重点理解方法\r\n  * attr()\r\n  * addClass()\r\n  * removeClass()\r\n  * html()\r\n\r\n## css\r\n * 重点理解方法\r\n   * css\r\n   * offset()\r\n   * scrollTop()\r\n   * width()\r\n   * height()\r\n\r\n## 效果\r\n * 重点理解方法\r\n   * animate()\r\n   * stop()\r\n   * delay()\r\n   * finish()\r\n\r\n## 文档处理\r\n* 重点理解方法\r\n  * append()\r\n  * insertBefore()\r\n  * wrap()\r\n  * empty()\r\n  * remove()\r\n\r\n## 事件\r\n* 重点理解方法\r\n * on()\r\n * trigger()\r\n * ready()\r\n\r\n## ajax\r\n* 重点理解方法\r\n * $.ajax()\r\n * $.get()  \r\n\r\n## 工具\r\n*  重点理解方法   \r\n  * $.each()\r\n  * $.map()\r\n  * $.toArray()\r\n\r\n## 练习\r\n   * 选项卡\r\n   * 轮播图\r\n   * 双下标轮播图\r\n   * 楼层跳转\r\n   * 按需加载\r\n   * 下拉导航\r\n","timestamp":1585877701769},{"name":"003-jQuery综合应用.md","path":"001-前端/08-JavaScript/006-jQuery/001-jQuery基础/003-jQuery综合应用.md","content":"# jQuery综合应用\r\n  * 扫雷游戏\r\n  * 扑克牌游戏\r\n  * 贪吃蛇游戏\r\n  * 打字游戏\r\n","timestamp":1585877701769},{"name":"001-jQuery插件原理.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/001-jQuery插件原理.md","content":"# jQuery插件原理\r\n\r\n## $.extend()和$.fn.extend()\r\n   * $.extend(obj) 是将obj身上的属性和方法扩展到jQuery函数身上的方法。\r\n   * $.fn.extend(obj) 是将obj身上的属性和方法扩展到每一jquery对象上的方法。\r\n\r\n```javascript\r\n  $.fn.extend({play:function(){alert(\'play\')}})\r\n  $(\"div\").play()；//play\r\n  $.extend({play:function(){alert(\'play\')}})\r\n  $.play();//play\r\n```   \r\n\r\n## 自定义插件\r\n* 利用`$.extend()`和`$.fn.extend()`可以自己编写一些自己需要的插件\r\n* 注意插件函数末尾return返回原jQuery对象保持链式调用\r\n\r\n```js\r\n/*------------------------------------------------------------/\r\n功能：设置列表中表项获取鼠标焦点时的背景色\r\n参数：li_col【可选】 鼠标所在表项行的背景色\r\n返回：原调用对象\r\n示例：$(\"ul\").focusColor(\"red\");\r\n/------------------------------------------------------------*/\r\n;(function($) {\r\n    $.fn.extend({\r\n    \"focusColor\": function(li_col) {\r\n        var def_col = \"#ccc\"; //默认获取焦点的色值\r\n        var lst_col = \"#fff\"; //默认丢失焦点的色值\r\n\r\n        //如果设置的颜色不为空，使用设置的颜色，否则为默认色\r\n        li_col = (li_col == undefined) ? def_col : li_col;\r\n\r\n        $(this).find(\"li\").each(function() { //遍历表项<li>中的全部元素\r\n            $(this).mouseover(function() { //获取鼠标焦点事件\r\n                $(this).css(\"background-color\", li_col); //使用设置的颜色\r\n            }).mouseout(function() { //鼠标焦点移出事件\r\n                $(this).css(\"background-color\", \"#fff\"); //恢复原来的颜色\r\n            })\r\n        })\r\n        return $(this); //返回jQuery对象，保持链式操作\r\n    }\r\n});\r\n```\r\n\r\n## 一些插件网站\r\n  * http://www.jq22.com/\r\n  * http://www.5iweb.com.cn/\r\n  * http://www.htmleaf.com/\r\n","timestamp":1585877701769},{"name":"002-jquery.validate.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/002-jquery.validate.js.md","content":"# jquery.validate.js\r\n> jQuery Validate 插件为表单提供了强大的验证功能，让客户端表单验证变得更简单，同时提供了大量的定制选项，满足应用程序各种需求。该插件捆绑了一套有用的验证方法，包括 URL 和电子邮件验证，同时提供了一个用来编写用户自定义方法的 API。所有的捆绑方法默认使用英语作为错误信息，且已翻译成其他 37 种语言。\r\n\r\n* [下载地址](https://jqueryvalidation.org/)\r\n\r\n## 使用方法\r\n### 1. 引入所需要的文件\r\n1. jquery.js\r\n2. jquery.validate.js\r\n3. messages_zh.js   (默认中文提示)\r\n```html\r\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\r\n<script src=\"https://cdn.bootcss.com/jquery-validate/1.19.0/jquery.validate.min.js\"></script>\r\n<script src=\"https://cdn.bootcss.com/jquery-validate/1.19.0/localization/messages_zh.min.js\"></script>\r\n```\r\n### 2. 定义校验规则\r\n* **在标签中定义校验规则**，此时会采用默认的提示文字，提示文字内容可到`messages_zh.js`文件中修改\r\n```html\r\n<form id=\"form1\">\r\n    <input type=\"text\" name=\"user\"/>\r\n    <input type=\"password\" name=\"pwd\" />\r\n    <textarea name=\"text\" required ></textarea>\r\n</form>\r\n<script>\r\n    $(\"#form\").validate()\r\n</script>\r\n```    \r\n* **在js中定义校验规则**\r\n    * 在validate方法中传入一个json对象，其中规定`rules`和`messages`\r\n    * `rules`字段: 对应表单元素需要验证的规则列表，其属性名为表单元素中的`name`属性。验证规则详见下方表格。\r\n    * `messages`字段:  对应`name`的表单元素验证规则失败的提示文字，每条验证规则都可对应一条提示文字。\r\n```javascript\r\n$(\"#form\").validate({\r\n    // rules字段： 需要验证的表单元素的规则，属性名为input的name值\r\n    rules:{\r\n        user:{\r\n            required:true,\r\n        },\r\n        pwd:{\r\n            minlength: 20\r\n            required:\"#one:checked\"\r\n        }\r\n    },\r\n    // messages字段：对应表单元素验证失败时的提示文字，\r\n    messages:{\r\n        user:{\r\n            required:\"请输入用户名\",\r\n        },\r\n        pwd:{\r\n            minlength:\"请输入不少于20字的内容\"\r\n        }\r\n    }\r\n})\r\n```\r\n\r\n> 当然，不管是在标签中定义还是在js中定义校验规则，都需要在js中执行初始化操作。$(\"myform\").validate()\r\n\r\n## 校验规则\r\n\r\n|规则|含义|\r\n|:----:|:----:|\r\n|required:true |必须输入的字段|\r\n|remote:\"check.php\" |使用 ajax 方法调用 check.php 验证输入值。|\r\n|email:true|必须输入正确格式的电子邮件。|\r\n|url:true |必须输入正确格式的网址。|\r\n|dateISO:true |必须输入正确格式的日期（ISO）|\r\n|number:true |必须输入合法的数字|\r\n|digits:true |必须输入整数|\r\n|equalTo:\"#field\"|输入值必须和 #field 相同。|\r\n|accept: |输入拥有合法后缀名的字符串（上传文件的后缀）。|\r\n|maxlength:5 |输入长度最多是 5 的字符串（汉字算一个字符）。|\r\n|minlength:10|输入长度最小是 10 的字符串（汉字算一个字符）|\r\n|rangelength:[5,10]| 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符）|\r\n|range:[5,10] |输入值必须介于 5 和 10 之间|\r\n|max:5 |输入值不能大于 5|\r\n|min:10 |输入值不能小于 10|\r\n\r\n* 自定义提示文字可以修改 `messages_zh.js` 中的内容\r\n* 自定义校验规则  \r\n```javascript\r\n  $.validator.addMethod(name,function(ele,val,attr){},\"message\")\r\n```  \r\n### 其他功能\r\n* `debug:true` 定义表单只验证不提交,可以方便调试 \r\n```js\r\n$(\"form\").validate({\r\n    debug:true\r\n})\r\n```\r\n\r\n* **更改错误信息显示的样式。** 通过插件内部生成的类名(`.error`)可以直接修改错误信息的样式\r\n```css\r\n/* 例：为错误信息添加图标  */\r\nlabel.error {\r\n  background:url(\"../images/icon.jpg\") no-repeat 0px 0px;\r\n  padding-left: 16px;\r\n}\r\n```\r\n\r\n* **异步验证。** 使用 ajax 方式进行验证，默认会提交当前验证的值到远程地址\r\n    ```js\r\n    // 案例： post方式异步验证用户名是否已经存在\r\n    $(\"#form\").validate({\r\n        rules:{\r\n            user:{\r\n                required: true,\r\n                remote: {\r\n                    url: \"../user/validateUserName\",\r\n                    type: \"post\",\r\n                    data: {\r\n                        user: function() {\r\n                            return $(\"#form input[name=\'user\']\").val();\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            messages:{\r\n                required: \"请填写用户名\"，\r\n                remote: \"用户名已存在\"\r\n            }\r\n        }\r\n    })\r\n    ```\r\n    > **注意： 远程地址只能返回 `true` 或 `false`，不能有其他返回。**","timestamp":1585877701769},{"name":"003-jquery.transit.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/003-jquery.transit.js.md","content":"# jquery.transit.js\r\n> `jquery.transit.js`使用 CSS3 的新特性来实现过渡效果，比jQuery默认的`.animate`方法要顺畅得多。但因为使用 CSS3 进行过渡效果，所以对不支持 CSS3 的浏览器效果有所下降。语法和`.animate`方法相同，因此很好上手。\r\n\r\n* [下载地址](https://github.com/rstacruz/jquery.transit)\r\n\r\n## 使用方法\r\n### 1. 引入所需文件\r\n```html\r\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\r\n<script src=\"https://cdn.bootcss.com/jquery.transit/0.9.12/jquery.transit.min.js\"></script>\r\n```  \r\n### 2. 可在jquery的css方法中快速操作css3 transform属性\r\n```javascript\r\n$(\"#box\").css({ x: \'30px\' });       // 向右移动30px\r\n$(\"#box\").css({ y: \'60px\' });       // 向下移动60px\r\n$(\"#box\").css({ translate: [60,30] });    // 向右移动60px, 向下移动30px\r\n$(\"#box\").css({ rotate: \'30deg\' });     // 顺时针旋转30度\r\n$(\"#box\").css({ scale: 2 });          // 放大2倍\r\n$(\"#box\").css({ scale: [2, 1.5] });     // 宽放大2倍，高放大1.5倍\r\n$(\"#box\").css({ skewX: \'30deg\' });      // 水平斜切\r\n$(\"#box\").css({ skewY: \'30deg\' });      // 垂直斜切\r\n$(\"#box\").css({ perspective: 100, rotateX: 30 });     // 3d旋转\r\n$(\"#box\").css({ rotate3d: [1, 1, 0, 45] });\r\n```    \r\n* 支持相对值的写法\r\n```javascript\r\n$(\"#box\").css({ rotate: \'+=30\' });      // 旋转增加30度\r\n$(\"#box\").css({ rotate: \'-=30\' });      // 旋转减少30度\r\n```\r\n* 单位都是可缺省的\r\n```javascript\r\n$(\"#box\").css({ x: \'30px\' });\r\n$(\"#box\").css({ x: 30 });\r\n```\r\n* 多个参数的传递方式\r\n  多个参数可以写为数组或字符串用逗号隔开\r\n```javascript\r\n$(\"#box\").css({ translate: [60,30] });\r\n$(\"#box\").css({ translate: [\'60px\',\'30px\'] });\r\n$(\"#box\").css({ translate: \'60px,30px\' });\r\n```\r\n* 可以用于获取属性（若属性有多个值，则返回数组）\r\n```javascript\r\n$(\"#box\").css(\'rotate\');       // \'30px\'\r\n$(\"#box\").css(\'translate\');   // [\'60px\', \'30px\']\r\n```\r\n\r\n### 3. 用`transition()`实现动画    \r\n你可以使用`$.fn.transition()`来进行 css3 动画效果。和`$.fn.animate()`的效果一样，只是他使用了 css3 过渡。\r\n\r\n```javascript\r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 });\r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 }, 500);    \r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 }, \'fast\');                    \r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 }, 500, \'in\');              \r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 }, function() {..});         \r\n$(\"#box\").transition({ opacity: 0.1, scale: 0.3 }, 500, \'in\', function() {..});\r\n\r\n$(\"#box\").transition({\r\n  opacity: 0.1, scale: 0.3,\r\n  duration: 500,\r\n  easing: \'in\',\r\n  complete: function() { /* ... */ }\r\n});\r\n```\r\n","timestamp":1585877701769},{"name":"004-jquery.lazyload.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/004-jquery.lazyload.js.md","content":"# jquery.lazyload.js\r\n> Lazy Load 是一款基于 jQuery 的图片延迟加载插件，它可以让浏览器可视区域外的图片不加载，当滚动到它们的位置时才加载。延迟加载可以使页面加载更快，减少服务器的负担，甚至是节约带宽。\r\n\r\n * [下载地址](http://www.jq22.com/jquery-info390)\r\n## 使用方法\r\n### 1. 引入所需要的文件\r\n```html\r\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\r\n<script src=\"https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js\"></script>\r\n```   \r\n### 2. 在html中对于img做对应的处理\r\n为图片加入样式类名`lazy`  图片路径引用方法用`data-original`\r\n\r\n```html\r\n<img class=\"lazy\" data-original=\"demo.jpg\"  />\r\n```  \r\n### 3. 在js中lazyload配置\r\n```javascript\r\n   $(\"img.lazy\").lazyload({effect: \"fadeIn\"});\r\n```  \r\n\r\n* `lazyload()`参数设置:\r\n\r\n|参数|含义|\r\n|:----:|:----:|\r\n|placeholder:\"img/grey.gif\"|用图片提前占位|\r\n|effect|载入使用何种效果值有show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn|\r\n|threshold: 200|代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉|\r\n|event: \'click\'|值有click(点击),mouseover(鼠标划过)可以实现鼠标莫过或点击图片才开始加载|\r\n|container|值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片|\r\n| failurelimit : 10 |值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题|\r\n","timestamp":1585877701769},{"name":"005-fullpage.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/005-fullpage.js.md","content":"#  jquery.fullpage.js\r\n>如今我们经常能见到全屏网站，尤其是国外网站。这些网站用几幅很大的图片或色块做背景，再添加一些简单的内容，显得格外的高端大气上档次。\r\n\r\n* [文档地址](https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs)\r\n\r\n* 特点\r\n    * 支持鼠标滚动\r\n    * 支持前进后退和键盘控制\r\n    * 多个回调函数\r\n    * 支持手机、平板触摸事件\r\n    * 支持 CSS3 动画\r\n    * 支持窗口缩放\r\n    * 窗口缩放时自动调整　\r\n    * 可设置滚动宽度、背景颜色、滚动速度、循环选项、回调、文本对齐方式等等　\r\n\r\n* 兼容性\r\n\r\n![兼容性](https://camo.githubusercontent.com/1939c9bed726b887a303a6d06de7c9e77fba3a06/68747470733a2f2f7261772e6769746875622e636f6d2f616c7661726f747269676f2f66756c6c506167652e6a732f6d61737465722f6578616d706c65732f696d67732f636f6d70617469626c652e6769663f763d32)\r\n\r\n## 使用方法\r\n### 1. 引入需要的文件\r\n```html\r\n<link href=\"https://cdn.bootcss.com/fullPage.js/3.0.4/fullpage.min.css\" rel=\"stylesheet\">\r\n\r\n<!-- 以下行是可选的。 只有在使用选项css3:false，并且您希望使用其他缓动效果，而非“linear”、“swing”或“easeInOutCubic”时才有必要。 -->\r\n<script src=\"https://cdn.bootcss.com/fullPage.js/3.0.4/vendors/easings.min.js\"></script>\r\n<!-- 以下行仅在使用选项scrollOverflow:true的情况下是必需的 -->\r\n<script src=\"https://cdn.bootcss.com/fullPage.js/3.0.4/vendors/scrolloverflow.min.js\"></script>\r\n\r\n<script src=\"https://cdn.bootcss.com/fullPage.js/3.0.4/fullpage.min.js\"></script>\r\n```     \r\n### 2. html部分布局\r\n```html\r\n<div id=\"fullpage\">\r\n   <div class=\"section\">第一屏</div>\r\n   <div class=\"section\">第二屏</div>\r\n   <div class=\"section\">第三屏</div>\r\n   <div class=\"section\">第四屏</div>\r\n</div>\r\n```\r\n> 每个 `section` 代表一屏，默认显示“第一屏”，如果要指定加载页面时显示的“屏幕”，可以在对应的 section 加上 `class=\"active\"`\r\n\r\n### 3. js部分\r\n```javascript\r\nnew fullpage(\'#fullpage\', options);\r\n```   \r\n#### `fullpage()` options配置参数\r\n\r\n|选项|类型|默认值|说明|\r\n|:----:|:----:|:----:|:----:|\r\n|verticalCentered\t|布尔值|true\t|内容是否垂直居中|\r\n|resize|布尔值|false|字体是否随着窗口缩放而缩放|\r\n|slidesColor|\t函数|\t无\t|设置背景颜色|\r\n|anchors|\t数组\t|无\t|定义锚链接|\r\n|scrollingSpeed|\t整数|\t700|\t滚动速度，单位为毫秒|\r\n|easing\t|字符串|\teaseInQuart|\t滚动动画方式|\r\n|menu|\t布尔值\t|false|\t绑定菜单，设定的相关属性与 anchors 的值对应后，菜单可以控制滚动|\r\n|navigation|\t布尔值|\tfalse\t|是否显示项目导航|\r\n|navigationPosition|\t字符串\t|right|\t项目导航的位置，可选 left 或 right|\r\n|navigationColor|\t字符串\t|#000\t|项目导航的颜色|\r\n|navigationTooltips\t|数组\t|空|\t项目导航的 tip|\r\n|slidesNavigation\t|布尔值|\tfalse\t|是否显示左右滑块的项目导航|\r\n|slidesNavPosition|\t字符串\t|bottom\t|左右滑块的项目导航的位置，可选 top 或 bottom|\r\n|controlArrowColor|\t字符串|\t#fff|\t左右滑块的箭头的背景颜色|\r\n|loopBottom\t|布尔值|\tfalse|\t滚动到最底部后是否滚回顶部|\r\n|loopTop|\t布尔值|\tfalse|\t滚动到最顶部后是否滚底部|\r\n|loopHorizontal\t|布尔值|true|\t左右滑块是否循环滑动|\r\n|autoScrolling|\t布尔值\t|true\t|是否使用插件的滚动方式，如果选择 false，则会出现浏览器自带的滚动条|\r\n|scrollOverflow\t|布尔值\t|false|\t内容超过满屏后是否显示滚动条|\r\n|css3\t|布尔值\t|false|\t是否使用 CSS3 transforms 滚动|\r\n|paddingTop\t|字符串|\t0\t|与顶部的距离|\r\n|paddingBottom\t|字符串|\t0\t|与底部距离|\r\n|fixedElements|\t字符串\t|无|定义的某个元素是否在网页的固定位置|\r\n|normalScrollElements|字符串|无|避免自动滚动的元素|\r\n|keyboardScrolling|\t布尔值|\ttrue\t|是否使用键盘方向键导航|\r\n|touchSensitivity\t|整数|5|定义了浏览器窗口的宽度/高度的百分比，多远的触摸滑动可以跳转到下一个section / slide。|\r\n|continuousVertical\t|布尔值|\tfalse\t|是否循环滚动，与 loopTop 及 loopBottom 不兼容|\r\n|animateAnchor|\t布尔值|\ttrue|定义当网页的URL中有锚文本的时候，是否帮用户定位到对应的section或者slide。|\r\n\r\n* `options`回调函数\r\n\r\n|名称|说明|\r\n|:----:|:----:|\r\n|afterLoad|\t滚动到某一屏后的回调函数，接收 anchorLink 和 index 两个参数，anchorLink 是锚链接的名称，index 是序号，从1开始计算|\r\n|onLeave\t|滚动前的回调函数，接收 index、nextIndex 和 direction 3个参数：index 是离开的“页面”的序号，从1开始计算；|\r\n|nextIndex |是滚动到的“页面”的序号，从1开始计算；|\r\n|direction |判断往上滚动还是往下滚动，值是 up 或 down。|\r\n|afterRender\t|页面结构生成后的回调函数，或者说页面初始化完成后的回调函数|\r\n|afterSlideLoad\t|滚动到某一水平滑块后的回调函数，与 afterLoad 类似，接收 anchorLink、index、slideIndex、direction 4个参数|\r\n|onSlideLeave|\t某一水平滑块滚动前的回调函数，与 onLeave 类似，接收 anchorLink、index、slideIndex、direction 4个参数 |\r\n\r\n#### fullpage对象方法\r\n\r\n|名称|说明|\r\n|:----:|:----:|\r\n|moveSectionUp()|向上滚动|\r\n|moveSectionDown()|向下滚动|\r\n|moveTo(section, slide)|\t滚动到|\r\n|moveSlideRight()\t|slide 向右滚动|\r\n|moveSlideLeft()|\tslide 向左滚动|\r\n|setAutoScrolling()\t|设置页面滚动方式，设置为 true 时自动滚动|\r\n|setAllowScrolling()|\t添加或删除鼠标滚轮/触控板控制|\r\n|setKeyboardScrolling()|\t添加或删除键盘方向键控制|\r\n|setScrollingSpeed()|\t定义以毫秒为单位的滚动速度|\r\n\r\n\r\n## jQuery全屏滚动插件jquery-fullPage.js\r\n`jquery-fullPage.js`是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站，使用方法与fullpage基本相同，可兼容到ie6。\r\n\r\n* 兼容性\r\n![兼容性](http://www.jq22.com/img/6.png)\r\n\r\n* [文档地址](http://www.jq22.com/jquery-info1124)\r\n\r\n### 使用方法\r\n1. 引入文件\r\n    ```html\r\n    <link rel=\"stylesheet\" href=\"css/jquery.fullPage.css\">\r\n    <script src=\"js/jquery.min.js\"></script>\r\n    \r\n    <!-- jquery.easings.min.js 是必须的，用于 easing 参数，也可以使用完整的 jQuery UI 代替 -->\r\n    <script src=\"js/jquery.easings.min.js\"></script>\r\n    \r\n    <!-- 如果 scrollOverflow 设置为 true，则需要引入 jquery.slimscroll.min.js，一般情况下不需要 -->\r\n    <script src=\"js/jquery.slimscroll.min.js\"></script>\r\n    \r\n    <script src=\"js/jquery.fullPage.js\"></script>\r\n    ```\r\n\r\n2. 布局结构\r\n    ```html\r\n    <div id=\"fullpage\">\r\n        <div class=\"section\">第一屏</div>\r\n        <div class=\"section\">第二屏</div>\r\n        <div class=\"section\">\r\n            <div class=\"slide\">第三屏的第一屏</div>\r\n            <div class=\"slide\">第三屏的第二屏</div>\r\n            <div class=\"slide\">第三屏的第三屏</div>\r\n            <div class=\"slide\">第三屏的第四屏</div>\r\n        </div>\r\n        <div class=\"section\">第四屏</div>\r\n    </div>\r\n    ```\r\n\r\n3. js\r\n    ```js\r\n    $(function(){\r\n        $(\'#fullpage\').fullpage(options);\r\n    });\r\n    ```\r\n    > `options`中的配置项和回调函数、方法与上文相同\r\n\r\n## 案例：\r\n[百度舆情](example/publicSentiment/index.html)\r\n\r\n\r\n","timestamp":1585877701769},{"name":"006-swiper.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/006-swiper.js.md","content":"#  jquery.swiper.js\r\n> Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！\r\n\r\n* [swiper中文官网](http://www.swiper.com.cn/)\r\n\r\n|swiper版本|兼容性|\r\n|---|---|\r\n|swiper4.x|移动端浏览器、部分PC端浏览器、IE10+|\r\n|swiper3.x|移动端浏览器、部分PC端浏览器|\r\n|swiper2.x|PC端浏览器，IE7+，部分移动端浏览器，支持IE7需引入JQuery|\r\n\r\n\r\n## 使用方法\r\n### 1. 引入文件\r\n```html\r\n<link href=\"https://cdn.bootcss.com/Swiper/4.4.6/css/swiper.min.css\" rel=\"stylesheet\">\r\n<script src=\"https://cdn.bootcss.com/Swiper/4.4.6/js/swiper.min.js\"></script>\r\n```\r\n### 2. html部分布局\r\n```html\r\n<div class=\"swiper-container\">\r\n    <div class=\"swiper-wrapper\">\r\n        <div class=\"swiper-slide\">Slide 1</div>\r\n        <div class=\"swiper-slide\">Slide 2</div>\r\n        <div class=\"swiper-slide\">Slide 3</div>\r\n    </div>\r\n    <!-- 如果需要分页器 -->\r\n    <div class=\"swiper-pagination\"></div>\r\n    \r\n    <!-- 如果需要导航按钮 -->\r\n    <div class=\"swiper-button-prev\"></div>\r\n    <div class=\"swiper-button-next\"></div>\r\n    \r\n    <!-- 如果需要滚动条 -->\r\n    <div class=\"swiper-scrollbar\"></div>\r\n</div>\r\n导航等组件可以放在container之外\r\n```  \r\n### 3. 设置Swiper大小 (可选)\r\n控制swiper大小可通过`swiper-container`容器\r\n```css\r\n.swiper-container {\r\n    width: 600px;\r\n    height: 300px;\r\n}  \r\n```\r\n\r\n### 4. js初始化Swiper\r\n初始化Swiper必须放到页面加载完成之后， 例如放到`<body>`末尾，或者`window.onload`事件中，或者jQuery`$(document).ready()`方法中，否则无法获取到元素。\r\n\r\n```javascript\r\nvar mySwiper = new Swiper (\'.swiper-container\', {\r\n    direction: \'vertical\', // 垂直切换选项\r\n    loop: true, // 循环模式选项\r\n    \r\n    // 如果需要分页器\r\n    pagination: {\r\n      el: \'.swiper-pagination\',\r\n    },\r\n    \r\n    // 如果需要前进后退按钮\r\n    navigation: {\r\n      nextEl: \'.swiper-button-next\',\r\n      prevEl: \'.swiper-button-prev\',\r\n    },\r\n    \r\n    // 如果需要滚动条\r\n    scrollbar: {\r\n      el: \'.swiper-scrollbar\',\r\n    },\r\n  })          \r\n```\r\n\r\n**注意：**当页面中有多个swiper轮播时，需要用不同类名或id进行区分，否则会发生冲突，但必须要保留默认的类名`swiper-container`。\r\n```html\r\n<!-- 轮播1 -->\r\n<div class=\"swiper-container\" id=\"mySwiper1\"></div>\r\n<!-- 轮播2 -->\r\n<div class=\"swiper-container\" id=\"mySwiper2\"></div>\r\n\r\n<script>\r\n  var swiper1 = new Swiper (\'#mySwiper1\', {})\r\n  var swiper2 = new Swiper (\'#mySwiper2\', {})\r\n</script>\r\n```\r\n\r\n#### 常用配置项\r\n\r\n[官方完整配置选项](https://www.swiper.com.cn/api/start/new.html)\r\n\r\n| 常用配置 | 类型 | 默认值 | 功能 |\r\n|:----:|:----:|:----:|:----:|\r\n| initialSlide | number | `0` | 初始化时默认选中的slide的索引 |\r\n| direction | string | `horizontal` | 设置轮播的滑动方向，水平(`horizontal`)或垂直(`vertical`) |\r\n| speed | number | `200` | 切换速度，即slider自动滑动开始到结束的时间，单位ms |\r\n| width / height | number | `500` | 强制设置Swiper的宽高(px)，当Swiper在隐藏状态下初始化时可以使用。这个参数会使自适应失效 |\r\n| autoHeight | boolean | `false` | 自动高度。设置为`true`时，wrapper和container会随着当前slide的高度而发生动态变化 |\r\n| uniqueNavElements | boolean | `true` | 独立分页元素。设置为`true`时，只有swiper内部的分页器生效 |\r\n| centeredSlides | boolean | `false` | slide位置。设定为true时，active slide会居中，而不是默认状态下的居左 |\r\n| slidesPerView | number  | `1` | slide宽度。设置slider容器能够同时显示的slides数量 |\r\n| slidesPerGroup | number  | `1` | 定义slides的数量多少为一组，即一次切换多少个slides |\r\n| spaceBetween | number  | `0` | 在slide之间设置距离（单位px） |\r\n| loop | boolean  | `false` | swiper循环切换 |\r\n| autoplay | object/boolean  | `false` | 设置为`true`启动自动切换，并使用默认的切换设置 |\r\n\r\n\r\n| effect | string  | `slide` | 切换效果。可设置为`slide`（普通切换）,`fade`（淡入）`cube`（方块）`coverflow`（3d流）`flip`（3d翻转） |\r\n| effect | string  | `slide` | 切换效果。可设置为\'slide\'（普通切换、默认）,\"fade\"（淡入）\"cube\"（方块）\"coverflow\"（3d流）\"flip\"（3d翻转） |\r\n\r\n","timestamp":1585877701769},{"name":"007-hammer.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/007-hammer.js.md","content":"# hammer.js\r\n> 是一个多点触摸手势库，实际上是对touchstart touchmove和touchend进行了封装，能够为网页加入Tap、Double Tap、Swipe、Hold、Pinch等多点触摸事件，免去自己监听底层touchstart、touchmove、touchend事件并且写一大堆判断逻辑的痛苦。\r\n\r\n* [官方网站](http://hammerjs.github.io/)\r\n\r\n## 使用方法\r\n### 1. 引入需要的文件\r\n```html\r\n<script src=\"https://cdn.bootcss.com/hammer.js/2.0.8/hammer.min.js\"></script>\r\n```\r\n### 2. 原生js中使用\r\nHammerJS的使用方式非常简单，只要将库引入到文件中，并创建一个新的实例即可：\r\n```js\r\nvar hammertime = new Hammer( document.querySelector(\'tag\') );\r\n\r\nhammertime.on(\'tap\'，function(e){ \r\n  console.log(e); \r\n})\r\n```\r\n\r\n它会默认为这个对象添加一系列事件，包括点击、双击、长按、平移、快速滑动等操作：\r\n\r\n| 点击操作 | 功能 |\r\n|:----:|:----:|\r\n| tap | 单击 |\r\n| doubletap | 双击 | \r\n| press | 长按251ms触发 |\r\n| pressup | 长按抬起时触发 |\r\n\r\n| 滑动操作 | 功能 |\r\n|:----:|:----:|\r\n| swipe | 快速滑动 |\r\n| swipeleft | 快速向左滑动 |\r\n| swiperight | 快速向右滑动 |\r\n| swipeup | 快速向上滑动 （默认不识别垂直手势） |\r\n| swipedown | 快速向下滑动 （默认不识别垂直手势） |\r\n| pan | 平移 |\r\n| panstart | 平移开始 |\r\n| panmove | 平移移动过程中 |\r\n| panend | 平移结束 |\r\n| panleft | 向左平移 |\r\n| panright | 向右平移 |\r\n| panup | 向上平移 （默认不识别垂直手势）|\r\n| pandown | 向下平移 （默认不识别垂直手势）|\r\n\r\n* 默认情况下禁用垂直方向的`pan` 和 `swipe`，因为会和页面滚动条冲突，若要允许识别器识别垂直方位需声明：\r\n```\r\nhammertime.get(\'pan\').set({ direction: Hammer.DIRECTION_ALL });\r\nhammertime.get(\'swipe\').set({ direction: Hammer.DIRECTION_VERTICAL });\r\n```\r\n\r\n| 多指缩放操作 | 功能 |\r\n|:----:|:----:|\r\n| pinch | 多点触摸捏放 |\r\n| rotate | 旋转 |\r\n\r\n* 默认情况下禁用`pinch`和`rotate`，因为它们可能会导致元素被卡住,通过以下方式可以启用：\r\n```js\r\nhammertime.get(\'pinch\').set({ enable: true });\r\nhammertime.get(\'rotate\').set({ enable: true });\r\n```\r\n\r\n#### 事件对象\r\n每一个Hammer触发的事件都会收到一个包含了如下属性的事件对象：\r\n\r\n| name | value |\r\n|:----:|:----:|\r\n| **type** | 事件名称，如`swipe` |\r\n| **deltaX** | X坐标轴上的移动距离 |\r\n| **deltaY** | Y坐标轴上的移动距离 |\r\n| deltaTime | 交互过程的总时长( 毫秒) |\r\n| **distance** | 移动距离 |\r\n| **angle** | 移动角度 |\r\n| velocityX | 在X坐标轴上的移动速率，单位为`px/ms` |\r\n| velocityY | 在Y坐标轴上的移动速率，单位为`px/ms` |\r\n| velocity | X/Y轴上最高的速率值 |\r\n| direction | 移动方向 |\r\n| scale  | 多点触摸结束时的缩放比例，若为单点触摸则为1|\r\n| rotation | 多点触摸结束时的旋转数值，若为单点触摸则为0 |\r\n| center | 多点触摸的中心位置，或者单点的坐标 |\r\n| target | 事件的目标 |\r\n\r\n\r\n\r\n\r\n\r\n## jquery.hammer.js —— jQuery插件形式使用hammerjs\r\n[文档及下载地址](https://github.com/hammerjs/jquery.hammer.js)\r\n\r\n```html\r\n<script src = \"http://eightmedia.github.com/hammer.js/jquery.hammer.js\" > </script>\r\n```\r\n```Javascript\r\n$(\"#element\").hammer().bind(\"tap\",function(e){\r\n      console.log(e);\r\n  });\r\n```  \r\n事件、事件对象等与`hammerjs`用法相同，\r\n\r\n\r\n\r\n\r\n## 案例：\r\n[移动端轮播图](example/banner-with-hammer/index.html)\r\n","timestamp":1585877701769},{"name":"008-zepto.js.md","path":"001-前端/08-JavaScript/006-jQuery/002-常用插件/008-zepto.js.md","content":"# zepto.js\r\n> Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。\r\n\r\n* [中文官网](https://www.css88.com/doc/zeptojs_api/)\r\n\r\n## zepro的使用\r\n\r\n### 下载\r\n[zepto.js下载地址](https://www.css88.com/doc/zeptojs_api/#download)\r\n\r\n或直接使用CDN：\r\n```html\r\n<script src=\"https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js\"></script>\r\n```\r\n### zepto语法\r\nZepto有着与 jQuery 类似的API，所以语法与jQuery相同。\r\n```js\r\n$(\'.btn\').on(\'click\',function(){\r\n    $(this).toggleClass(\'active)\r\n})\r\n```\r\n### 兼容性\r\n* Safari 6+\r\n* Chrome 30+    对谷歌较为友好\r\n* Firefox 24+\r\n* iOS 5+ Safarii  ios的支持版本也比较早\r\n* Android 2.3+ Browser,注意支持Android的版本比较早\r\n* Internet Explorer 10+   对ie不太友好\r\n\r\n### zepto与jquery的不同点\r\n* 文件更精简，不在支持ie10以下，移除了很多在移动端不适用的api\r\n* jQuery的底层是通过DOM来实现效果的，zepto.js 是用css3来实现的；\r\n* 增加了对于css3 转换属性的支持\r\n  > 诸如 translateX rotate 都可以在 动画中设置\r\n\r\n  ```Javascript\r\n  $(\"div\").animate({rotate:\'45deg\',translateX:\'100px\'})\r\n  ```\r\n* 增加了对于移动端事件的支持\r\n  > 增加了 `tap` `singleTap`  `doubleTap` `loneTap` `swipe`  `swipeLeft` `swipeRight` `swipeUp` `swipeDown`的支持，也可以通过`on`的形式添加。\r\n\r\n  ```Javascript\r\n  $(\"div\").swipe(function(){\r\n    alert(\"this is a swipe event\")   \r\n  })\r\n  $(\"div\").on(\'tap\',function(){\r\n    alert(\"this is a tap event\")  \r\n  })\r\n  ```\r\n* **zepto默认只带有部分功能，扩展功能需要额外引入模块文件。** 例如`animate()`、`tap`事件、更多选择器等功能。\r\n  * [fx模块下载(支持animate)](example/zepto/fx.js)  \r\n  * [fx_methods模块下载(支持faed等动画)](example/zepto/fx_methods.js)  \r\n  * [selector模块下载(支持实验性的选择器)](example/zepto/selector.js)  \r\n  * [touch模块下载(支持移动端手势tap、swipe等)](example/zepto/touch.js)  \r\n\r\n  ![zepto模块](assets/006/002/008-1546584875000.png)\r\n","timestamp":1585877701769},{"name":"001-less安装.md","path":"001-前端/08-JavaScript/006-jQuery/003-预编译语言/001-less安装.md","content":"# LESS\r\n\r\n## 原理及使用方式\r\n>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。\r\n\r\n## 安装\r\n\r\n### 服务器端使用\r\n\r\n#### 安装步骤\r\n\r\n  1. 在服务器端最容易的安装方式就是通过 npm （node.js 的包管理器），方法如下：\r\n  ```\r\n  $ npm install -g less\r\n  ```\r\n  2. 安装 Less 后，就可以在命令行上调用 Less 编译器了，如下：\r\n  ```\r\n  $ lessc styles.less\r\n  ```\r\n  3. 这将输出编译之后的 CSS 代码到 stdout，你可以将输出重定向到一个文件：\r\n  ```\r\n  $ lessc styles.less > styles.css\r\n  ```\r\n  4. 若要输出压缩过的 CSS，只需添加 -x 选项\r\n  5. 如果你想下载最新稳定版本的 LESS，可以尝试像下面这样操作:\r\n  ```\r\n  $ npm install less@latest\r\n  ```\r\n\r\n### 客户端使用\r\n\r\n#### 使用步骤\r\n\r\n  1. 在页面中加入 .less 样式表的链接，并将 rel 属性设置为 \"stylesheet/less\"：\r\n  ```html\r\n  <link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" />\r\n  ```\r\n\r\n  2. 接下来，下载 less.js 并通过 <script></script> 标签将其引入，放置于页面的 <head> 元素内：\r\n  ```html\r\n  <script src=\"less.js\" type=\"text/javascript\"></script>\r\n  ```\r\n\r\n  3. 注意你的less样式文件一定要在引入less.js前先引入。\r\n","timestamp":1585877701769},{"name":"002-less使用.md","path":"001-前端/08-JavaScript/006-jQuery/003-预编译语言/002-less使用.md","content":"# LESS\r\n\r\n## LESS 语法\r\n\r\n### 变量\r\n\r\n* 使用@符号声明赋值变量:\r\n  ```less\r\n  @nice-blue: #5B83AD;\r\n  @light-blue: @nice-blue + #111;\r\n\r\n  #header { color: @light-blue; }\r\n\r\n  /*输出:*/\r\n  #header { color: #6c94be; }\r\n  ```\r\n\r\n* 可以用变量名定义为变量:\r\n  ```less\r\n  @fnord: \"I am fnord.\";\r\n  @var: \'fnord\';\r\n  content: @@var;\r\n\r\n  /*解析后:*/\r\n  content: \"I am fnord.\";\r\n  ```\r\n  **注意：** LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.\r\n\r\n\r\n### 混合\r\n\r\n1. 在 LESS 中我们可以定义一些通用的属性集为一个class:\r\n  ```less\r\n  .bordered {\r\n    border-top: 1px dotted black;\r\n    border-bottom: 2px solid black;\r\n  }\r\n  ```\r\n\r\n2. 需要在其他样式表中引入那些通用的属性集，只需要在样式表中像下面这样调用就可以:\r\n  ```less\r\n  #menu a {\r\n    color: #111;\r\n    .bordered;\r\n  }\r\n  .post a {\r\n    color: red;\r\n    .bordered;\r\n  }\r\n  ```\r\n\r\n3. .bordered class里面的属性样式都会在 #menu a 和 .post a中体现出来:\r\n  ```less\r\n  #menu a {\r\n    color: #111;\r\n    border-top: 1px dotted black;\r\n    border-bottom: 2px solid black;\r\n  }\r\n  .post a {\r\n    color: red;\r\n    border-top: 1px dotted black;\r\n    border-bottom: 2px solid black;\r\n  }\r\n  ```\r\n\r\n4. 任何 CSS class, id 或者 元素 属性集都可以以同样的方式引入。\r\n\r\n\r\n### 带参数混合\r\n\r\n* 在 LESS 中，可以像函数一样定义一个带参数的属性集合:\r\n  ```less\r\n  .border-radius (@radius) {\r\n    border-radius: @radius;\r\n    -moz-border-radius: @radius;\r\n    -webkit-border-radius: @radius;\r\n  }\r\n\r\n  //在其他样式表中调用:\r\n  #header {\r\n    .border-radius(4px);\r\n  }\r\n  .button {\r\n    .border-radius(6px);  \r\n  }\r\n  ```\r\n\r\n* 可以给参数设置默认值:\r\n  ```less\r\n  .border-radius (@radius: 5px) {\r\n    border-radius: @radius;\r\n    -moz-border-radius: @radius;\r\n    -webkit-border-radius: @radius;\r\n  }\r\n  // 所以现在如果我们像这样调用它的话:\r\n  #header {\r\n    .border-radius;  \r\n  }\r\n  // radius的值就会是5px.\r\n  ```\r\n\r\n* 可以定义不带参数属性集合，如果想隐藏这个属性集合，不让它暴露到CSS中去，但是还想在其他的属性集合中引用，这个方法就非常的好用:\r\n  ```less\r\n  .wrap () {\r\n    text-wrap: wrap;\r\n    white-space: pre-wrap;\r\n    white-space: -moz-pre-wrap;\r\n    word-wrap: break-word;\r\n  }\r\n\r\n  pre {\r\n    .wrap\r\n  }\r\n  // 输出:\r\n\r\n  pre {\r\n    text-wrap: wrap;\r\n    white-space: pre-wrap;\r\n    white-space: -moz-pre-wrap;\r\n    word-wrap: break-word;\r\n  }\r\n  ```\r\n\r\n* @arguments 变量\r\n\r\n  @arguments包含了所有传递进来的参数。 如果不想单独处理每一个参数的话可以这样写:\r\n\r\n  ```less\r\n  .box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {\r\n    box-shadow: @arguments;\r\n    -moz-box-shadow: @arguments;\r\n    -webkit-box-shadow: @arguments;\r\n  }\r\n  .box-shadow(2px, 5px);\r\n\r\n  // 将会输出:\r\n  box-shadow: 2px 5px 1px #000;\r\n  -moz-box-shadow: 2px 5px 1px #000;\r\n  -webkit-box-shadow: 2px 5px 1px #000;\r\n  ```\r\n\r\n### 模式匹配和导引表达式\r\n\r\n* 有些情况下，想根据传入的参数来改变混合的默认呈现，如下：\r\n\r\n  ```less\r\n  .mixin (@s, @color) { ... }\r\n\r\n  .class {\r\n    .mixin(@switch, #888);\r\n  }\r\n  ```\r\n  如果想让 .mixin 根据不同的 @switch值而表现各异，设置如下：\r\n  ```less\r\n  .mixin (dark, @color) {\r\n    color: darken(@color, 10%);\r\n  }\r\n  .mixin (light, @color) {\r\n    color: lighten(@color, 10%);\r\n  }\r\n  .mixin (@_, @color) {\r\n    display: block;\r\n  }\r\n  ```\r\n  现在，如果运行:\r\n  ```less\r\n  @switch: light;\r\n\r\n  .class {\r\n    .mixin(@switch, #888);\r\n  }\r\n  ```\r\n  就会得到下列CSS:\r\n  ```less\r\n  .class {\r\n    color: #a2a2a2;\r\n    display: block;\r\n  }\r\n  ```\r\n  如上，.mixin就会得到传入颜色的浅色。如果 @switch设为dark，就会得到深色。\r\n\r\n  ```\r\n  具体实现如下：\r\n  第一个混合定义并未被匹配，因为它只接受dark做为首参\r\n  第二个混合定义被成功匹配，因为它只接受light\r\n  第三个混合定义被成功匹配，因为它接受任意值\r\n  只有被匹配的混合才会被使用。变量可以匹配任意的传入值，而变量以外的固定值就仅仅匹配与其相等的传入值。\r\n  ```\r\n\r\n* 我们也可以匹配多个参数：\r\n\r\n  ```less\r\n  .mixin (@a) {\r\n    color: @a;\r\n  }\r\n  .mixin (@a, @b) {\r\n    color: fade(@a, @b);\r\n  }\r\n\r\n  //当传入一个参数时，第一个混合定义将成功匹配\r\n  //当传入两个参数时，第二个混合定义将成功匹配\r\n  ```\r\n\r\n\r\n* 引导\r\n  >当我们想根据表达式进行匹配，而非根据值和参数匹配时，导引就显得非常有用。如果你对函数式编程非常熟悉，那么你很可能已经使用过导引。\r\n\r\n  >为了尽可能地保留CSS的可声明性，LESS通过导引混合而非if/else语句来实现条件判断，因为前者已在@media query特性中被定义。\r\n\r\n  * 以此例做为开始：\r\n    ```less\r\n    .mixin (@a) when (lightness(@a) >= 50%) {\r\n      background-color: black;\r\n    }\r\n    .mixin (@a) when (lightness(@a) < 50%) {\r\n      background-color: white;\r\n    }\r\n    .mixin (@a) {\r\n      color: @a;\r\n    }\r\n    ```\r\n    when关键字用以定义一个导引序列(此例只有一个导引)。接下来我们运行下列代码：\r\n    ```less\r\n    .class1 {\r\n      .mixin(#ddd)\r\n    }\r\n    .class2 {\r\n      .mixin(#555)\r\n    }\r\n    ```\r\n    就会得到：\r\n    ```css\r\n    .class1 {\r\n      background-color: black;\r\n      color: #ddd;\r\n    }\r\n    .class2 {\r\n      background-color: white;\r\n      color: #555;\r\n    }\r\n    ```\r\n\r\n  * 导引中可用的全部比较运算有： > >= = =< <。此外，关键字true只表示布尔真值，下面两个混合是相同的：\r\n    ```less\r\n    .truth (@a) when (@a) { ... }\r\n    .truth (@a) when (@a = true) { ... }\r\n    ```\r\n\r\n  * 除去关键字true以外的值都被视示布尔假：\r\n    ```less\r\n    .class {\r\n      .truth(40); // Will not match any of the above definitions.\r\n    }\r\n    ```\r\n\r\n  * 导引序列使用逗号‘,’分割，当且仅当所有条件都符合时，才会被视为匹配成功。\r\n    ```less\r\n    .mixin (@a) when (@a > 10), (@a < -10) { ... }\r\n    ```\r\n\r\n  * 导引可以无参数，也可以对参数进行比较运算：\r\n    ```less\r\n    @media: mobile;\r\n\r\n    .mixin (@a) when (@media = mobile) { ... }\r\n    .mixin (@a) when (@media = desktop) { ... }\r\n\r\n    .max (@a, @b) when (@a > @b) { width: @a }\r\n    .max (@a, @b) when (@a < @b) { width: @b }\r\n    ```\r\n\r\n  * 如果想基于值的类型进行匹配，我们就可以使用is*函式：\r\n    ```less\r\n    .mixin (@a, @b: 0) when (isnumber(@b)) { ... }\r\n    .mixin (@a, @b: black) when (iscolor(@b)) { ... }\r\n    ```\r\n    * 下面就是常见的检测函式：\r\n      * iscolor\r\n      * isnumber\r\n      * isstring\r\n      * iskeyword\r\n      * isurl\r\n    * 如果你想判断一个值是纯数字，还是某个单位量，可以使用下列函式：\r\n      * ispixel\r\n      * ispercentage\r\n      * isem\r\n\r\n  * 在导引序列中可以使用and关键字实现与条件：\r\n    ```less\r\n    .mixin (@a) when (isnumber(@a)) and (@a > 0) { ... }\r\n    ```\r\n\r\n  * 使用not关键字实现或条件\r\n    ```less\r\n    .mixin (@b) when not (@b > 0) { ... }\r\n    ```\r\n\r\n\r\n### 嵌套规则\r\n>LESS 可以让我们以嵌套的方式编写层叠样式:\r\n\r\n  ```css\r\n  #header {\r\n    color: black;\r\n  }\r\n  #header .navigation {\r\n    font-size: 12px;\r\n  }\r\n  #header .logo {\r\n    width: 300px;\r\n  }\r\n  #header .logo:hover {\r\n    text-decoration: none;\r\n  }\r\n  ```\r\n  在 LESS 中, 我们就可以这样写:\r\n  ```LESS\r\n  #header {\r\n    color: black;\r\n    .navigation {\r\n      font-size: 12px;\r\n    }\r\n    .logo {\r\n      width: 300px;\r\n      &:hover {\r\n        text-decoration: none;\r\n      }\r\n    }\r\n  }\r\n  ```\r\n  或者这样写:\r\n  ```less\r\n  #header        { color: black;\r\n    .navigation  { font-size: 12px }\r\n    .logo        { width: 300px;\r\n      &:hover    { text-decoration: none }\r\n    }\r\n  }\r\n  ```\r\n  代码更简洁了，而且感觉跟DOM结构格式有点像.\r\n\r\n  **注意** & 符号的使用，如果你想写串联选择器，而不是写后代选择器，就可以用到&了。这点对伪类尤其有用如 :hover 和 :focus.\r\n  ```less\r\n  .bordered {\r\n    &.float {\r\n      float: left;\r\n    }\r\n    .top {\r\n      margin: 5px;\r\n    }\r\n  }\r\n  ```\r\n  会输出:\r\n  ```css\r\n  .bordered.float {\r\n    float: left;  \r\n  }\r\n  .bordered .top {\r\n    margin: 5px;\r\n  }\r\n  ```\r\n\r\n### 运算\r\n>任何数字、颜色或者变量都可以参与运算。\r\n\r\n* 常规例子：\r\n  ```less\r\n  @base: 5%;\r\n  @filler: @base * 2;\r\n  @other: @base + @filler;\r\n\r\n  color: #888 / 4;\r\n  background-color: @base-color + #111;\r\n  height: 100% / 2 + @filler;\r\n  ```\r\n\r\n* LESS 的运算能够分辨出颜色和单位。\r\n  ```\r\n  @var: 1px + 5;\r\n  LESS 会输出 6px.\r\n\r\n  括号也同样允许使用:\r\n\r\n  width: (@var + 5) * 2;\r\n  并且可以在复合属性中进行运算:\r\n\r\n  border: (@width * 2) solid black;\r\n  ```\r\n\r\n### Color 函数\r\n>LESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作。\r\n\r\n* 示例：\r\n  ```less\r\n  lighten(@color, 10%);     // return a color which is 10% *lighter* than @color\r\n  darken(@color, 10%);      // return a color which is 10% *darker* than @color\r\n\r\n  saturate(@color, 10%);    // return a color 10% *more* saturated than @color\r\n  desaturate(@color, 10%);  // return a color 10% *less* saturated than @color\r\n\r\n  fadein(@color, 10%);      // return a color 10% *less* transparent than @color\r\n  fadeout(@color, 10%);     // return a color 10% *more* transparent than @color\r\n  fade(@color, 50%);        // return @color with 50% transparency\r\n\r\n  spin(@color, 10);         // return a color with a 10 degree larger in hue than @color\r\n  spin(@color, -10);        // return a color with a 10 degree smaller hue than @color\r\n\r\n  mix(@color1, @color2);    // return a mix of @color1 and @color2\r\n  ```\r\n\r\n* 使用\r\n  ```less\r\n  @base: #f04615;\r\n\r\n  .class {\r\n    color: saturate(@base, 5%);\r\n    background-color: lighten(spin(@base, 8), 25%);\r\n  }\r\n  ```\r\n\r\n* 还可以提取颜色信息:\r\n  ```less\r\n  hue(@color);        // returns the `hue` channel of @color\r\n  saturation(@color); // returns the `saturation` channel of @color\r\n  lightness(@color);  // returns the \'lightness\' channel of @color\r\n  ```\r\n\r\n* 在一种颜色的通道上创建另一种颜色，例如:\r\n  ```less\r\n  @new: hsl(hue(@old), 45%, 90%);\r\n  @new 将会保持 @old的 色调, 但是具有不同的饱和度和亮度.\r\n  ```\r\n\r\n### Math 函数\r\n* LESS提供了一组方便的数学函数，可以处理一些数字类型的值:\r\n  ```\r\n  round(1.67); // returns `2`\r\n  ceil(2.4);   // returns `3`\r\n  floor(2.6);  // returns `2`\r\n  ```\r\n* 如果你想将一个值转化为百分比，你可以使用percentage 函数:\r\n  ```\r\n  percentage(0.5); // returns `50%`\r\n  ```\r\n\r\n### 命名空间\r\n>为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 可以定义一些属性集之后可以重复使用。\r\n\r\n  ```less\r\n  #bundle {\r\n    .button () {\r\n      display: block;\r\n      border: 1px solid black;\r\n      background-color: grey;\r\n      &:hover { background-color: white }\r\n    }\r\n    .tab { ... }\r\n    .citation { ... }\r\n  }\r\n  ```\r\n  你只需要在 #header a中像这样引入 .button:\r\n  ```less\r\n  #header a {\r\n    color: orange;\r\n    #bundle > .button;\r\n  }\r\n  ```\r\n\r\n### 作用域\r\n>LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。\r\n\r\n```less\r\n@var: red;\r\n\r\n#page {\r\n  @var: white;\r\n  #header {\r\n    color: @var; // white\r\n  }\r\n}\r\n\r\n#footer {\r\n  color: @var; // red  \r\n}\r\n```\r\n\r\n### 注释\r\n\r\nCSS 形式的注释在 LESS 中是依然保留的:\r\n\r\n```less\r\n/* 这是一个样式表 */\r\n.class {\r\n  color: black;\r\n}\r\n\r\n// LESS 同样也支持双斜线的注释, 但是编译成 CSS 的时候自动过滤掉:\r\n// 这也是一个样式表\r\n.class {\r\n  color: white;\r\n}\r\n```\r\n\r\n### Importing\r\n\r\n  你可以在main文件中通过下面的形势引入 .less 文件, .less 后缀可带可不带:\r\n  ```css\r\n  @import \"lib.less\";\r\n  @import \"lib\";\r\n  ```\r\n  如果你想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以:\r\n  ```css\r\n  @import \"lib.css\";\r\n  ```\r\n  这样LESS就会跳过它不去处理它.\r\n\r\n### 字符串插值\r\n\r\n  变量可以用类似ruby和php的方式嵌入到字符串中，像@{name}这样的结构:\r\n  ```less\r\n  @base-url: \"http://assets.fnord.com\";\r\n  .class{\r\n    background-image: url(\"@{base-url}/images/bg.png\");\r\n  }\r\n  ```\r\n\r\n### 避免编译\r\n>  有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法.\r\n\r\n  要输出这样的值我们可以在字符串前加上一个 ~, 例如:\r\n  ```less\r\n  .class {\r\n    filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";\r\n  }\r\n  ```\r\n  我们可以将要避免编译的值用 \"\"包含起来，输出结果为:\r\n  ```css\r\n  .class {\r\n    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();\r\n  }\r\n  ```\r\n\r\n### JavaScript 表达式\r\n>JavaScript 表达式也可以在.less 文件中使用.\r\n\r\n* 可以通过反引号的方式使用:\r\n  ```less\r\n  @var: `\"hello\".toUpperCase() + \'!\'`;\r\n  ```\r\n  输出:\r\n  ```less\r\n  @var: \"HELLO!\";\r\n  ```\r\n\r\n* 注意你也可以同时使用字符串插值和避免编译:\r\n  ```less\r\n  @str: \"hello\";\r\n  @var: ~`\"@{str}\".toUpperCase() + \'!\'`;\r\n  ```\r\n  输出:\r\n  ```less\r\n  @var: HELLO!;\r\n  ```\r\n\r\n* 它也可以访问JavaScript环境:\r\n  ```less\r\n  @height: `document.body.clientHeight`;\r\n  ```\r\n\r\n* 如果你想将一个JavaScript字符串解析成16进制的颜色值, 你可以使用 color 函数:\r\n  ```less\r\n  @color: color(`window.colors.baseColor`);\r\n  @darkcolor: darken(@color, 10%);\r\n  ```\r\n","timestamp":1585877701769},{"name":"003-sass安装与编译.md","path":"001-前端/08-JavaScript/006-jQuery/003-预编译语言/003-sass安装与编译.md","content":"# sass(Syntactically Awesome Stylesheets)\r\nsass是css的一个扩展开发工具，它允许你使用变量、条件语句等，使开发更简单可维护     \r\n\r\n## 安装(使用编辑器不需要安装)          \r\n### 安装ruby\r\n因为sass是基于ruby编写的，所以需要安装ruby后才能下载sass，才可以用。              \r\nruby下载地址： https://rubyinstaller.org/downloads/              \r\n安装时请勾选Add Ruby executables to your PATH这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到ruby环境                \r\n完成后运行cmd进入命令符，输入ruby -v查看版本号，如果能正确显示版本号，则说明ruby安装成功。    \r\n![ruby -v查看版本号](amWiki/images/ruby.jpg)\r\n\r\n### 安装sass\r\n运行cmd进入命令行输入`gem install sass`进行安装\r\n\r\n## 编译Sass\r\nSass文件后缀为 .scss或者.sass，要编译成 .css 文件\r\n### 命令行编译\r\n```\r\nsass test.scss test.css\r\n```\r\nSass 提供4种编译风格 :                     \r\n    * nested：嵌套缩进的css代码，它是默认值。\r\n    * expanded：没有缩进的、扩展的css代码。\r\n    * compact：简洁格式的css代码。\r\n    * compressed：压缩后的css代码。\r\n```\r\nsass --style compressed test.scss test.css\r\n```\r\n可以监听某个文件或目录，一旦文件发生改变，就自动生成编译后文件          \r\n```\r\n# 单文件监听命令\r\nsass --watch input.scss output.css\r\n# 文件夹监听命令\r\nsass --watch app/sass public/css\r\n```\r\ncss文件转成sass/scss文件\r\n```\r\nsass-convert style.css style.scss\r\n```\r\n\r\n### node编译\r\n前提是你已经安装了node          \r\n#### Node-SASS安装\r\n全局安装node-sass\r\n```\r\nnpm install node-sass -g\r\n```\r\n\r\n#### 编译命令\r\nnode-sass的编译命令与上面的命令行编译相似，也支持文件夹编译和监听编译\r\n```\r\nnode-sass test.scss test.css\r\n```\r\n![node-sass](amWiki/images/node-scss.jpg)\r\n\r\n\r\n\r\n### koala编译\r\n一个优秀的免费编译器，界面清晰简洁，操作起来也非常简单\r\n### 编辑器编译(不需要安装ruby和sass)\r\n现在很多编辑器中都内置了sass编译,例如在vsCode中，商店搜索easysass，然后安装，在编写好sass代码之后，保存，vsCode就会为你自动转化成两个css文件，一个是未压缩，一个是压缩版的。\r\n\r\n## scss和sass的区别\r\nSCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。另外，SCSS 还能识别大部分 CSS hacks（一些 CSS 小技巧）和特定于浏览器的语法，可以理解scss是sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力。                            \r\n\r\n1. SCSS 需要使用分号和花括号而不是换行和缩进：\r\n```css\r\n/* sass语法 */\r\n#sidebar\r\n  width: 30%\r\n  background-color: #faa\r\n/* scss语法 */\r\n#sidebar {\r\n  width: 30%;\r\n  background-color: #faa;\r\n}\r\n```\r\nscss语法更符合我们写css的规范，更好理解              \r\n2. 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名\r\n3. `@import`SCSS中的指令与Sass中的指令一样，只是它需要引用一个带引号的字符串。\r\n\r\n```css\r\n/* sass语法 */\r\n@import themes/dark\r\n@import font.sass\r\n/* scss语法 */\r\n@import \"themes/dark\";\r\n@import \"font.sass\";\r\n```\r\n","timestamp":1585877701769},{"name":"004-sass使用.md","path":"001-前端/08-JavaScript/006-jQuery/003-预编译语言/004-sass使用.md","content":"# sass\r\n## 使用\r\nsass的使用与less的使用很相似\r\n### 变量\r\nsass使用$符号来标识变量,变量可以在css规则块定义之外存在。当变量定义在css规则块内，那么该变量只能在此规则块内使用。\r\n```scss\r\n/* 编译前 */\r\n$b-color:#451aaa;\r\n.box{\r\n  $b-width:100px;\r\n  width:$b-width;\r\n  color:$b-color;\r\n}\r\n/* .box1{\r\n  width:$b-width;\r\n}    会报错，不能编译 */\r\n\r\n/* 编译后 */\r\n.box {\r\n  width: 100px;\r\n  color: #451aaa;\r\n}\r\n```\r\n\r\n#### 数据类型\r\n支持6种主要的数据类型：\r\n* 数字，1, 2, 13, 10px\r\n* 字符串，有引号字符串与无引号字符串，\"foo\", \'bar\', baz\r\n* 颜色，blue, #04a3f9, rgba(255,0,0,0.5)\r\n* 布尔型，true, false\r\n* 空值，null\r\n* 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif\r\n* maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)\r\n\r\n### 嵌套CSS 规则\r\n在css中，我们需要重复写选择器，在sass中可以只写一遍，sass在输出css时会把这些嵌套规则处理好，避免重复书写。       \r\n```scss\r\n/* 编译前 */\r\n$b-color:#451aaa;\r\n.box{\r\n  $b-width:100px;\r\n  width:$b-width;\r\n  color:$b-color;\r\n  p{\r\n    font-size: 18px;\r\n    .box1{border:1px solid #ddd}\r\n  }\r\n  a{font-size: 19px}\r\n}\r\n/* 编译后 */\r\n.box {\r\n  width: 100px;\r\n  color: #451aaa;\r\n}\r\n.box p {\r\n  font-size: 18px;\r\n}\r\n.box p .box1 {\r\n  border: 1px solid #ddd;\r\n}\r\n```\r\n#### 父选择器的标识符&\r\n用法与less中一样，这里就不再赘述，直接上例子\r\n```scss\r\n/* 编译前 */\r\narticle a {\r\n  color: blue;\r\n  &:hover { color: red }\r\n}\r\n/* 编译后 */\r\narticle a {\r\n  color: blue;\r\n}\r\narticle a:hover {\r\n  color: red;\r\n}\r\n```\r\n#### 嵌套属性\r\n嵌套属性的规则：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。         \r\n```scss\r\n/* 编译前 */\r\n.box {\r\n  border: {\r\n  style: solid;\r\n  width: 1px;\r\n  color: #ddd;\r\n  }\r\n}\r\n/* 编译后 */\r\n.box {\r\n  border-style: solid;\r\n  border-width: 1px;\r\n  border-color: #ddd;\r\n}\r\n```\r\n```scss\r\n/* 编译前 */\r\n.box {\r\n  border: 1px solid #ccc {\r\n    left: 0px;\r\n    right: 0px;\r\n  }\r\n}\r\n/* 编译后 */\r\n.box {\r\n  border: 1px solid #ccc;\r\n  border-left: 0px;\r\n  border-right: 0px;\r\n}\r\n```\r\n\r\n### 导入SASS文件\r\ncss中的`@import`允许在一个css文件中导入其他css文件，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。                      \r\nsass中的`@import`在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。\r\n\r\n- 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。\r\n将文件命名为 `_colors.scss`，便不会编译 `_colours.css` 文件。\r\n```scss\r\n@import \"colors\";\r\n/* 导入的其实是 _colors.scss 文件 */\r\n```\r\n>不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。\r\n\r\n\r\n#### 默认变量值`!default`\r\n`!default`用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。      \r\n```scss\r\n$b-width: 400px !default;\r\n.box {\r\n  width: $b-width;\r\n}\r\n```\r\n如果导入文件对$b-width进行了赋值，则400px的赋值是无效的，没有的话则$b-width被赋值为400px\r\n#### 嵌套导入\r\nsass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。   \r\n```scss\r\n/* test1.scss文件的内容 */\r\np{\r\n  color:red;\r\n  a{\r\n    color:yellow;\r\n  }\r\n}\r\n/* test.scss文件的内容 */\r\n.box{\r\n  @import \"test1.scss\"\r\n}\r\n/* 编译test.scss文件后生成 */\r\n.box{\r\n  p{\r\n    color:red;\r\n    a{\r\n      color:yellow;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### 插值语句`#{}`\r\n通过 `#{}` 插值语句可以在选择器或属性名中使用变量\r\n```scss\r\n/* 编译前 */\r\n$b:100px;\r\n.box#{$b}{\r\n  height: $b;\r\n}\r\n/* 编译后 */\r\n.box100px {\r\n  height: 100px;\r\n}\r\n```\r\n\r\n### 静默注释\r\nsass另外提供了一种不同于css标准注释格式`/* ... */`的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟JavaScriptJava等类C的语言中单行注释的语法相同，它们以//开头，注释内容直到行末。\r\n\r\n### 混合器\r\n混合器使用@mixin标识符定义,这个标识符给一大段样式赋予一个名字，这样就可以通过引用这个名字重用这段样式。                     \r\n然后就可以在样式表中通过@include来使用这个混合器，放在任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。\r\n```scss\r\n/* 编译前 */\r\n@mixin rounded-box{\r\n  border-radius: 5px;\r\n  background: blue;\r\n  font-size: 20px;\r\n  a{\r\n    font-weight: 800;\r\n    font-size: 21px;\r\n    margin-left: 0px;\r\n  }\r\n}\r\n.box{\r\n  border:1px solid #aaa;\r\n  @include rounded-box;\r\n}\r\n/* 编译后 */\r\n.box {\r\n  border: 1px solid #aaa;\r\n  border-radius: 5px;\r\n  background: blue;\r\n  font-size: 20px;\r\n}\r\n.box a {\r\n  font-weight: 800;\r\n  font-size: 21px;\r\n  margin-left: 0px;\r\n}\r\n```\r\n\r\n\r\n#### 给混合器传参\r\n混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。跟JavaScript的function很像。                     \r\n```scss\r\n/* 编译前 */\r\n@mixin rounded-box($a,$b,$c){\r\n  border-radius: $a;\r\n  background: blue;\r\n  font-size: $b;\r\n  a{\r\n    font-weight: 800;\r\n    font-size: $c;\r\n    margin-left: 0px;\r\n  }\r\n}\r\n.box{\r\n  border:1px solid #aaa;\r\n  @include rounded-box(5px,20px,21px);\r\n}\r\n/* 编译后 */\r\n.box {\r\n  border: 1px solid #aaa;\r\n  border-radius: 5px;\r\n  background: blue;\r\n  font-size: 20px;\r\n}\r\n.box a {\r\n  font-weight: 800;\r\n  font-size: 21px;\r\n  margin-left: 0px;\r\n}\r\n```\r\n##### 默认参数值\r\n可以给参数指定一个默认值。参数默认值使用$name: value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用。\r\n```scss\r\n@mixin rounded-box($a:18px,$b:20px,$c:$a){\r\n  border-radius: $a;\r\n  background: blue;\r\n  font-size: $b;\r\n  a{\r\n    font-weight: 800;\r\n    font-size: $c;\r\n    margin-left: 0px;\r\n  }\r\n}\r\n.box{\r\n  border:1px solid #aaa;\r\n  @include rounded-box;\r\n}\r\n```\r\n\r\n### 使用选择器继承\r\n选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过`@extend`语法实现         \r\n```scss\r\n/* 编译前 */\r\n.box{\r\n  width:200px;\r\n  height:200px;\r\n  background:red;\r\n  a{color:blue}\r\n}\r\n.footer{\r\n  @extend .box;\r\n  border:1px solid #999;\r\n}\r\n/* 编译后 */\r\n.box, .footer {\r\n  width: 200px;\r\n  height: 200px;\r\n  background: red;\r\n}\r\n.box a, .footer a {\r\n  color: blue;\r\n}\r\n.footer {\r\n  border: 1px solid #999;\r\n}\r\n```\r\n* 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。\r\n* 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。\r\n\r\n### 计算功能\r\n#### 数字计算\r\nsass变量的计算能力 (+, -, 乘, /, %)\r\n```scss\r\n/* 编译前 */\r\n$a:200px;\r\n.box{\r\n  width:$a+200*2;\r\n}\r\n/* 编译后 */\r\n.box {\r\n  width: 600px;\r\n}\r\n```\r\n`/` 在 CSS 中通常起到分隔数字的用途，scss 作为 CSS 语言的拓展也支持这个功能，同时也赋予了 `/` 除法运算的功能。也就是说，如果 `/` 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。                 \r\n\r\n以下三种情况 / 将被视为除法运算符号\r\n1. 如果值，或值的一部分，是变量或者函数的返回值\r\n2. 如果值被圆括号包裹\r\n3. 如果值是算数表达式的一部分  \r\n\r\n如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。    \r\n```scss\r\n/* 编译前 */\r\np {\r\n  $font-size: 12px;\r\n  $line-height: 30px;\r\n  font: #{$font-size}/#{$line-height};\r\n}\r\n/* 编译后 */\r\np {font: 12px/30px; }\r\n```\r\n#### 字符串运算\r\n+ 可用于连接字符串           \r\n有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。\r\n```scss\r\n/* 编译前 */\r\np:before {\r\n  content: \"Foo \" + Bar;\r\n  font-family: sans- + \"serif\";\r\n}\r\n/* 编译后 */\r\np:before {\r\n  content: \"Foo Bar\";\r\n  font-family: sans-serif;\r\n}\r\n```\r\n#### 圆括号\r\n圆括号可以用来影响运算的顺序\r\n\r\n### 控制指令\r\nscss提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能。\r\n#### @if、@else、@else if\r\n`@if` 声明后面可以跟多个 `@else if` 声明，或者一个 `@else` 声明。如果 `@if` 声明失败，Sass 将逐条执行 `@else if` 声明，如果全部失败，最后执行 `@else` 声明\r\n```scss\r\n/* 编译前 */\r\n$type: monster;\r\np {\r\n  @if $type == ocean {\r\n    color: blue;\r\n  } @else if $type == matador {\r\n    color: red;\r\n  } @else if $type == monster {\r\n    color: green;\r\n  } @else {\r\n    color: black;\r\n  }\r\n}\r\n/* 编译后 */\r\np {\r\n  color: green;\r\n}\r\n```\r\n#### @for、\r\n`@for` 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：`@for $var from <start> through <end>`，或者 `@for $var from <start> to <end>`，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 `<start>` 与 `<end>` 的值，而使用 to 时条件范围只包含 `<start>` 的值不包含 `<end>` 的值。`<start>` 和 `<end>` 必须是整数值。                 \r\n```scss\r\n/* 编译前 */\r\n@for $i from 1 through 3 {\r\n  .item-#{$i} { width: 2em * $i; }\r\n}\r\n/* 编译后 */\r\n.item-1 {\r\n  width: 2em;\r\n}\r\n.item-2 {\r\n  width: 4em;\r\n}\r\n.item-3 {\r\n  width: 6em;\r\n}\r\n```\r\n#### @each，与@for相似，@for用来遍历数字，@each用来遍历数组类型的值\r\n`@each` 指令的格式是`@each $var in <list>`  `<list>` 是一连串的值，也就是值列表。               \r\n`@each` 将变量 $var 作用于值列表中的每一个项目，然后输出结果    \r\n```scss\r\n/* 编译前 */\r\n@each $animal in puma, sea-slug, egret, salamander {\r\n  .#{$animal}-icon {\r\n    background-image: url(\'/images/#{$animal}.png\');\r\n  }\r\n}\r\n/* 编译后 */\r\n.puma-icon {\r\n  background-image: url(\'/images/puma.png\'); }\r\n.sea-slug-icon {\r\n  background-image: url(\'/images/sea-slug.png\'); }\r\n.egret-icon {\r\n  background-image: url(\'/images/egret.png\'); }\r\n.salamander-icon {\r\n  background-image: url(\'/images/salamander.png\'); }\r\n```\r\n#### `@while`\r\n`@while` 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 `@for` 更复杂的循环       \r\n```scss\r\n/* 编译前 */\r\n$i: 6;\r\n@while $i > 0 {\r\n  .item-#{$i} { width: 2em * $i; }\r\n  $i: $i - 2;\r\n}\r\n/* 编译后 */\r\n.item-6 {\r\n  width: 12em; }\r\n.item-4 {\r\n  width: 8em; }\r\n.item-2 {\r\n  width: 4em; }\r\n```\r\n\r\n### 函数指令\r\nSass 支持自定义函数，格式为`@function name($a){@return} `                   \r\n与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 `@return` 输出结果。\r\n```scss\r\n/* 编译前 */\r\n$a:55px;\r\n$b:100px;\r\n@function fun($c){\r\n  @return $a*$c;\r\n}\r\n.box{\r\n  width:fun(2);\r\n  height: $b;\r\n}\r\n/* 编译后 */\r\n.box {\r\n  width: 110px;\r\n  height: 100px;\r\n}\r\n```\r\n","timestamp":1585877701769},{"name":"001-bootstrap.md","path":"001-前端/08-JavaScript/006-jQuery/004-框架及综合练习/001-bootstrap.md","content":"# bootstrap\r\n\r\n## bootstrap概述\r\n* **简介**\r\n>Bootstrap是Twitter推出的一个开源的用于前端开发的工具包。它由Twitter的设计师合作开发，是一个CSS/HTML框架。Bootstrap提供了优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。\r\n\r\n* **特点**\r\n>Bootstrap是基于jQuery框架开发的，它在jQuery框架的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件\r\n\r\n* **功能**\r\n  * 多样的布局\r\n    >从网格布局到流式布局再到响应式布局\r\n\r\n  * 美观的排版\r\n    >几乎重新定义了html中所有的样式，包括标题,列表,表单,表格等等。\r\n\r\n  * 丰富的组件\r\n    >Bootstrap中包含了丰富的Web组件，根据这些组件，可以快速的搭建一个\r\n漂亮、功能完备的网站。包括以下组件：<br/>\r\n    >下拉菜单、按钮组、按钮下拉菜单、导航、导航条、面包屑、分页、排版、\r\n缩略图、警告对话框、进度条、媒体对象等\r\n\r\n  * 灵活的jQuery插件\r\n    >Bootstrap自带了13个jQuery插件，这些插件为Bootstrap中的组件赋予了“生命”。其中包括：<br/>\r\n    >模式对话框、标签页、滚动条、弹出框等\r\n\r\n## bootstrap兼容性以及环境搭建\r\n\r\n* 浏览器支持\r\n>Bootstrap的目标是在最新的桌面和移动浏览器上有最佳的表现，也就是说，在较老旧的浏览器上可能会导致某些组件表现出的样式有些不同，但是功能是完整的。\r\n\r\n  ```\r\n  被支持的浏览器\r\n    Chrome (Mac、Windows、iOS和Android)\r\n    Safari (只支持Mac和iOS版)\r\n    Firefox (Mac、Windows)\r\n    Internet Explorer\r\n    Opera (Mac、Windows)\r\n    Internet Explorer 8 和 9\r\n  ```\r\nInternet Explorer 8 和 9 是被支持的，然而很多CSS3属性和HTML5元素是肯定不被支持的。另外，Internet Explorer 8 需要Respond.js配合才能实现对媒体查询（media query）的支持。注:respond.js只支出 max-width min-width。\r\n\r\n* respond.js问题\r\n  * Respond.js 和 file://\r\n  >由于浏览器的安全规则问题，Respond.js 不能通过 file:// 协议（打开本地\r\nHTML文件所用的协议）访问的页面上发挥正常的功能。如果需要测试IE8下\r\n面的响应式特性，必须用http服务器（例如apache、nginx）托管HTML页面才\r\n可以。请参考 Respond.js 文档 获取更多信息。\r\n\r\n  * Respond.js 和@import\r\n  >Respond.js 不支持通过 @import 引入的CSS文件。例如，Drupal 一般被配置\r\n为通过 @import 引入CSS文件，Respond.js对其将无法起到作用。 请参考\r\nRespond.js 文档获取更多信息\r\n\r\n* IE10问题\r\n  >Internet Explorer 10并没有将屏幕的宽度和视口（viewport）的宽度区别开，这就导致Bootstrap中的媒体查询并不能很好的发挥作用。\r\n\r\n  * 为了解决这个问题，可以引入下面列出的这段CSS暂时修复此问题：\r\n    ```CSS\r\n    @-webkit-viewport {\r\n      width: device-width;\r\n    }\r\n    @-moz-viewport {\r\n      width: device-width;\r\n    }\r\n    @-ms-viewport {\r\n      width: device-width;\r\n    }\r\n    @-o-viewport {\r\n      width: device-width;\r\n    }\r\n    @viewport {\r\n      width: device-width;\r\n    }\r\n    ```\r\n    ```javascript\r\n    if (navigator.userAgent.match(/IEMobile\\/10\\.0/)) {\r\n      var msViewportStyle = document.createElement(\"style\")\r\n      msViewportStyle.appendChild(\r\n        document.createTextNode(\r\n          \"@-ms-viewport{width:auto!important}\"\r\n        )\r\n      )\r\n      document.getElementsByTagName(\"head\")[0].appendChild(msViewportStyle)\r\n    }\r\n    ```\r\n  * IE兼容模式\r\n  >Bootstrap不支持IE的兼容模式。为了让IE浏览器运行最新的渲染模式，建议将此 <meta> 标签加入到你的页面中：\r\n\r\n    ```HTML\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    ```\r\n\r\n* 页面基本模板\r\n\r\n  ```html\r\n  <!DOCTYPE html>\r\n  <html>\r\n    <head>\r\n      <title>Bootstrap 101 Template</title>\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n      <!-- Bootstrap -->\r\n      <link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/twitter-bootstrap/3.0.3/css/bootstrap.min.css\">\r\n      <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and mediaqueries -->\r\n      <!-- WARNING: Respond.js doesn\'t work if you view the page via file:// -->\r\n      <!--[if lt IE 9]>\r\n        <script src=\"http://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js\"></script>\r\n        <script src=\"http://cdn.bootcss.com/respond.js/1.3.0/respond.min.js\"></script>\r\n      <![endif]-->\r\n    </head>\r\n    <body>\r\n      <h1>Hello, world!</h1>\r\n      <!-- jQuery (necessary for Bootstrap\'s JavaScript plugins) -->\r\n      <script src=\"http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js\"></script>\r\n      <!-- Include all compiled plugins (below), or include individual files as needed -->\r\n      <script src=\"http://cdn.bootcss.com/twitter-ootstrap/3.0.3/js/bootstrap.min.js\"></script>\r\n    </body>\r\n  </html>\r\n  ```\r\n\r\n* Safari对百分比数字凑整的问题\r\n  >从OS X版Safari v6.1和iOS v7.0.1版Safari开始，Safari浏览器所包含的绘制引擎对于处理.col-* -1所对应的很长的百分比小数存在bug。也就是说，如果你在一行（row）之中定义了12个单独的列（.col-* -1），你就会看到这一行比其他行要短一些。我们目前解决不了这个问题(see #9282)，但是你可以避免：\r\n    * 为最后一列添加.pull-right，将其暴力向右对齐\r\n    * 手动调整百分比数字，让其针对Safari表现更好（这比第一种方式更困难）<br/>\r\n\r\n    >我们将会继续跟踪此问题，如果有更简易的解决方案，我们会更新代码。\r\n\r\n* 模态框和移动设备\r\n\r\n  * 超出范围和滚动\r\n    ><body>元素在iOS和Android上对overflow: hidden的支持很有限。结果就是，在这两种设备上的浏览器中，当你滚动屏幕超过模态框的顶部或底部时， <body>中的内容将开始随着滚动。\r\n\r\n  * 虚拟键盘\r\n    >还有，如果你正在模态框上面输入内容 -- iOS还有一个绘制上的bug，当触发虚拟键盘之后，其不会更新fixed元素的位置。这里有几种解决方案，包括将fixed元素转变为position: absolute或启动一个定时器手工修正其位置。<br/>\r\n    这些没有加入Bootstrap中，因此，需要由你自己选择最好的解决方案并加入到你的应用中。\r\n\r\n* 浏览器缩放\r\n  >页面缩放功能不可避免的会将某些组件搞得乱七八糟，不光是Bootstrap，整个互联网上的所有网站都是这样。针对具体问题，我们或许可以修复它（如果有必要的话，请先搜索一下你的问题，看看是否已有解决方案，然后在向我们提交issue）。<br/>\r\n  然而，我们更倾向于忽略这些问题，由于这些问题除了一些hack手段，一般没有直接的解决方案。\r\n\r\n## bootstrap栅格系统\r\n\r\n* 栅格系统\r\n  >Bootstrap内置了一套响应式、移动设备优先的流式栅格系统，随着屏幕设备或视口（viewport）尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义classe，还有强大的mixin用于生成更具语义的布局。\r\n\r\n* Bootstrap栅格系统的工作原理：\r\n  * “行（row）”必须包含在.container中，以便为其赋予合适的排列（aligment）和内补（padding）。\r\n  * 使用“行（row）”在水平方向创建一组“列（column）”。\r\n  * 你的内容应当放置于“列（column）”内，而且，只有“列（column）”可以作为行（row）”的直接子元素。\r\n  * 类似Predefined grid classes like .row and .col-xs-4 这些预定义的栅格class可以用来快速创建栅格布局。Bootstrap源码中定义的mixin也可以用来创建语义化的布局。\r\n  * 通过设置padding从而创建“列（column）”之间的间隔（gutter）。然后通过为第一和最后一样设置负值的margin从而抵消掉padding的影响。\r\n  * 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个.col-xs-4来创建。\r\n\r\n* bootstrap栅格选项\r\n\r\n|  | 超小屏幕设备 手机(<768px) | 小屏幕设备 平板(>=768px)| 中等屏幕设备 桌面(>=992px)| 大屏幕设备(>=1200px)|\r\n|:-----:|:-----:|:-----:|:-----:|:-----:|\r\n|栅格系统行为 | 总是水平排列 | 开始是堆叠在一起的，超过这些阈值将变为水平排列|开始是堆叠在一起的，超过这些阈值将变为水平排列|开始是堆叠在一起的，超过这些阈值将变为水平排列|\r\n| 最大.container宽度 | None(自动) | 750px | 970px | 1170px |\r\n| class前缀 | .col-xs- | .col-sm- | .col-md- | .col-lg- |\r\n| 列数 | 12 |12 |12 |12 |\r\n|最大列宽 | 自动 | 60px | 78px | 95px|\r\n|列间距 |30px (每列左右均有15px)|30px (每列左右均有15px)|30px (每列左右均有15px)|30px (每列左右均有15px)|\r\n|可嵌套 | Yes|Yes|Yes|Yes|\r\n|偏移（Offsets）|  Yes|Yes|Yes|Yes|\r\n|列排序 | Yes|Yes|Yes|Yes|\r\n栅格class在屏幕宽度大于或等于阈值的设备上起作用，如果小于阀值小屏幕设备会将class覆盖掉。所以说越小阀值的class级别越高\r\n\r\n* bootstrap栅格系统混合排列\r\n\r\n  ![移动设备和桌面](amWiki/images/1.jpg)\r\n\r\n* bootstrap栅格系统列偏移\r\n  >使用 .col-md-offset-* 可以将列偏移到右侧。这些class通过使用*选择器将所有列增加了列的左侧margin。例如，.col-md-offset-4将.col-md-4向右移动了4个列的宽度\r\n\r\n  ![列偏移](amWiki/images/2.jpg)\r\n\r\n* bootstrap栅格系统列嵌套\r\n  >为了使用内置的栅格将内容嵌套，通过添加一个新的.row和一系列 .col-md-* 列放进已经存在的 .col-md-* 列内即可实现。嵌套row所包含的列加起来应该等于12，也就是说所嵌套的row的宽度等于他的父元素\r\n\r\n  ![列嵌套](amWiki/images/3.jpg)\r\n\r\n* bootstrap栅格系统列排序\r\n  >通过使用 .col-md-push-* 和 .col-md-pull-* 就可以很容易的改变列的顺序<br/>\r\n  col-md-push-* 向右移动<br/>\r\n  col-md-pull-* 向左移动\r\n\r\n## bootstrap排版样式\r\n>bootstrap给我们预定义了一系列页面当中标签的样式，有别于原生呆板的样式，他给我们加入进了一系列设计的元素如：圆角，阴影或者是将某些标签的默认边距进行了修改，或者是加入了一些特殊的类，总之能够使我们的页面更加的人性化，更加的符合用户的浏览习惯。<br/>\r\n包括：标题 ，文本，列表，表格，表单等等\r\n\r\n* bootstrap排版-标题\r\n  * 标题 <h1-h6>\r\n\r\n    HTML中的所有标题标签，从< h1\\>到< h6\\>均可用。另外，还提供了.h1到.h6 class，为的是给inline属性的文本赋予标题的样式\r\n\r\n  * 副标题<small>\r\n\r\n    在标题内还可以包含< small\\>标签或 .small元素，可以用来标记副标题\r\n\r\n    ```html\r\n    <h1>标题<small>副标题</small></h1>\r\n    ```\r\n\r\n    当small放在标题里面时当做副标题来用，当他单独放在外面的时候样式有所变化，是小字体的意思,行内元素赋予.small以代替任何<small>标签。\r\n\r\n* bootstrap排版-段落\r\n  * 段落 < p>\r\n\r\n    通过添加.lead可以让段落突出显示\r\n\r\n  * 段落对齐\r\n\r\n  ```html\r\n  <p class=\"text-left\">左对齐</p>\r\n  <p class=\"text-center\">中对齐</p>\r\n  <p class=\"text-right\">右对齐</p>\r\n  ```\r\n\r\n* bootstrap排版-字体颜色\r\n\r\n  ```html\r\n  <p class=\"text-muted\">字体颜色 柔和的(灰色)</p>\r\n  <p class=\"text-primary\">字体颜色 突出重点(浅蓝色)</p>\r\n  <p class=\"text-success\">字体颜色 突出成功(绿色)</p>\r\n  <p class=\"text-info\">字体颜色 突出信息(蓝色)</p>\r\n  <p class=\"text-warning\">字体颜色 警告(橙色)</p>\r\n  <p class=\"text-danger\">字体颜色 危险(红色)</p>\r\n  ```\r\n\r\n* bootstrap排版-页面主体\r\n  * Bootstrap将全局font-size设置为14px，line-height为1.428。这些属性直接赋给<body>和所有段落元素。\r\n  * < p>（段落）还被设置了等于1/2行高的底部外边距（margin）（即10px）。\r\n\r\n* bootstrap排版-引用样式\r\n  * 将任何HTML裹在< blockquote>之中即可表现为引用添加< small>标签或.small class 来注明引用来源。\r\n  * 来源名称可以放在< cite>标签里面使用.pull-right可以让引用展现出向右侧移动、对齐的效果。\r\n\r\n* bootstrap排版-列表\r\n  * 在bootstrap中的列表和默认样式没有什么不同。\r\n  * 添加类名 .list-unstyled 去除列表默认样式。\r\n  * 添加类名 .list-inline 添加少量内边距，将所有的元素放在一行。\r\n  * 添加类名 .dl-horizontal 可以让<dl>内短语及其描述排在一行。开始是像<dl>默认样式堆叠在一起，随着导航条逐渐展开而排列在一行。\r\n\r\n* bootstrap排版-表格\r\n  * 在bootstrap中的table和默认样式没有什么不同。\r\n  * 添加.table可以为其赋予基本的样式—少量的内补（padding）和水平方向的分隔线。\r\n  * 利用.table-striped可以给<tbody>之内的每一样增加斑马条纹样式。<br/>\r\n    跨浏览器兼容性：条纹状表格是通过:nth-child CSS选择器实现的，而这一功能不被Internet Explorer 8支持。\r\n  * 利用.table-bordered为表格和其中的每个单元格增加边框。\r\n  * 利用.table-hover可以让<tbody>中的每一行响应鼠标悬停状态。\r\n  * 利用.table-condensed可以让表格更加紧凑，单元格中的内部（padding）均会减半。\r\n  * 通过这些状态class可以为行或单元格设置颜色\r\n\r\n|Class    | 描述    |\r\n| :------------- | :------------- |\r\n| .active      | 鼠标悬停在行或单元格上时所设置的颜色   |\r\n| .success      | 标识成功或积极的动作   |\r\n| .warning      | 标识警告或需要用户注意   |\r\n| .danger      | 标识危险或潜在的带来负面影响的动作   |\r\n\r\n  * 响应式表格\r\n    >将任何.table包裹在.table-responsive中即可创建响应式表格，其会在小屏幕设备上（小于768px）水平滚动。当屏幕大于768px宽度时，水平滚动条消失。\r\n\r\n    ```html\r\n    <div class=\"table-responsive\">\r\n    <table class=\"table\">\r\n    ...\r\n    </table>\r\n    </div>\r\n    ```\r\n\r\n## bootstrap表单样式\r\n\r\n* bootstrap表单-基本样式\r\n  * 单独的表单控件几乎和默认样式没有什么区别,仅仅有一些bootstrap的全局样式。\r\n  * 设置了 .form-control 类 的< input\\>、< textarea\\>和< select\\>元素都将被默认。\r\n  * 设置为 width: 100%; 使表单具有获得焦点的状态。\r\n  * 将label和前面提到的这些控件包裹在 .form-group中可以获得最好的排列。\r\n\r\n  ```html\r\n  <div class=\"form-group\">\r\n    <label for=\"exampleInputEmail1\">Email address</label>\r\n    <input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Enter email\">\r\n  </div>\r\n  ```\r\n\r\n* bootstrap表单-内联样式\r\n  * 内联样式\r\n    >为< form\\>元素 form-inline可使其内容左对齐并且表现为inline-block级别的控件。只适用于浏览器窗口至少在 768px 宽度时（窗口宽度再小的话就会使表单折叠）。\r\n\r\n  * 需要设置宽度\r\n    >在Bootstrap中，input、select和textarea默认被设置为100%宽度。为了使用内联表单，你需要专门为使用到的表单控件设置宽度。\r\n\r\n  * 一定要设置label\r\n    >如果你没有为每个输入控件设置label，屏幕阅读器将无法正确识读。对于这些内联表单，你可以通过为label设置.sr-only已将其隐藏。\r\n\r\n* bootstrap表单-水平排列\r\n  >通过为表单添加 form-horizontal，并使用Bootstrap预置的栅格class可以将label和控件组水平并排布局。这样做将变.form-group为栅格系统中的行（row），因此就无需再使用.row了。\r\n\r\n  ```html\r\n  <div class=\"form-group\">\r\n    <label for=\"inputEmail3\" class=\"col-sm-2 control-label\">Email</label>\r\n    <div class=\"col-sm-10\">\r\n      <input type=\"email\" class=\"form-control\" id=\"inputEmail3\" placeholder=\"Email\">\r\n    </div>\r\n  </div>\r\n  ```\r\n\r\n* bootstrap表单-支持的控件< input\\>\r\n  * 大部分表单控件、文本输入域控件。包括HTML5支持的所有类型：text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel和color。\r\n  * 必须添加类型声明\r\n  * 只有正确设置了type的input控件才能被赋予正确的样式。\r\n\r\n  ```html\r\n  <input type=\"text\" class=\"form-control\" placeholder=\"Text input\">\r\n  ```\r\n\r\n* bootstrap表单-支持的控件< textarea\\>\r\n  >支持多行文本的表单控件。可根据需要改变rows属性\r\n\r\n  ```html\r\n  <textarea class=\"form-control\" rows=\"3\"></textarea>\r\n  ```\r\n\r\n* bootstrap表单-支持的控件checkbox radio\r\n  * Checkbox用于选择列表中的一个或多个选项，而radio用于从多个选项中只选择一个。\r\n  * 默认外观(堆叠在一起)\r\n\r\n  ```html\r\n  <label>\r\n    <input type=\"checkbox\" value=\"\">\r\n    Option one is this and that&mdash;be sure to include why it\'s great\r\n  </label>\r\n  ```\r\n  通过将.checkbox-inline 或 .radio-inline应用到一系列的checkbox或radio控件上，可以使这些控件排列在一行。\r\n  ```html\r\n  <label class=\"checkbox-inline\">\r\n    <input type=\"checkbox\" id=\"inlineCheckbox1\" value=\"option1\"> 1\r\n  </label>\r\n  <label class=\"checkbox-inline\">\r\n    <input type=\"checkbox\" id=\"inlineCheckbox2\" value=\"option2\"> 2\r\n  </label>\r\n  ```\r\n\r\n* bootstrap表单-支持的控件< select\\> <br/>\r\n  >使用默认选项或添加multiple属性可以显示多个选项\r\n\r\n  ```html\r\n  <select multiple class=\"form-control\">\r\n    <option>1</option>\r\n    <option>2</option>\r\n    <option>3</option>\r\n    <option>4</option>\r\n    <option>5</option>\r\n  </select>\r\n  ```\r\n\r\n* bootstrap表单-支持的控件-静态控件\r\n  >在水平布局的表单中，如果需要将一行纯文本放置于label的同一行，为< p\\>元素添加.form-control-static即可\r\n\r\n  ```html\r\n  <div class=\"form-group\">\r\n    <label class=\"col-sm-2 control-label\">Email</label>\r\n    <div class=\"col-sm-10\">\r\n      <p class=\"form-control-static\">email@example.com</p>\r\n    </div>\r\n  </div>\r\n  ```\r\n\r\n* bootstrap表单-支持的控件-帮助控件\r\n  >用于表单控件的块级帮助文本。\r\n\r\n  ```html\r\n  <span class=\"help-block\">自己独占一行或多行的块级帮助文本。</span>\r\n  ```\r\n\r\n* bootstrap表单-控件尺寸\r\n  * 高度尺寸<br/>\r\n    添加 input-lg类 使得表单控件变高。<br/>\r\n    添加 input-sm类 使得表单控件高度变小。\r\n\r\n  * 调整列尺寸<br/>\r\n    用栅格系统中的列包裹input或其任何父元素，都可很容易的为其设置宽度。\r\n\r\n## bootstrap按钮样式\r\n\r\n* bootstrap按钮分类\r\n\r\n  ![按钮分类](amWiki/images/anniu.jpg)\r\n\r\n  ```html\r\n  <button type=\"button\" class=\"btn btn-default\">Default</button>\r\n  <button type=\"button\" class=\"btn btn-primary\">Primary</button>\r\n  <button type=\"button\" class=\"btn btn-success\">Success</button>\r\n  <button type=\"button\" class=\"btn btn-info\">Info</button>\r\n  <button type=\"button\" class=\"btn btn-warning\">Warning</button>\r\n  <button type=\"button\" class=\"btn btn-danger\">Danger</button>\r\n  <button type=\"button\" class=\"btn btn-link\">Link</button>\r\n  <!-- .btn必须和 .btn-default一起使用才能获得“默认”样式的按钮 -->\r\n  ```\r\n\r\n* bootstrap按钮尺寸\r\n  * 需要让按钮具有不同尺寸吗？使用 .btn-lg、.btn-sm、.btn-xs可以获得不同尺寸的按钮。\r\n  * 通过给按钮添加 btn-block 可以使其充满父节点100%的宽度，而且按钮也变为了块级（block）元素。\r\n\r\n* bootstrap按钮状态\r\n  * 活动状态\r\n    >由于:active是伪状态，因此 无需添加，但是在需要表现出同样外观的时候可以添加 active 类。\r\n\r\n  * 禁用状态\r\n    * < button\\><br/>\r\n      通过将按钮的背景色做50%的褪色处理就可以呈现出无法点击的效果。<br/>\r\n      按钮元素为< button\\>添加disabled属性。\r\n    * < a\\><br/>\r\n      我们把.disabled作为工具class使用，因此不需要增加前缀。链接功能不受影响,只是改变<a>的外观，不影响功能。<br/>\r\n      我们通过JavaScript代码禁用链接的默认功能。\r\n\r\n* bootstrap按钮标签\r\n  * 可作按钮使用的HTML标签\r\n  * 可以为< a\\>、< button\\>或< input\\>元素添加按钮class。\r\n\r\n    ```html\r\n    <a class=\"btn btn-default\" href=\"#\" role=\"button\">Link</a>\r\n    <button class=\"btn btn-default\" type=\"submit\">Button</button>\r\n    <input class=\"btn btn-default\" type=\"button\" value=\"Input\">\r\n    <input class=\"btn btn-default\" type=\"submit\" value=\"Submit\">\r\n    ```\r\n    尽可能使用< button>元素以确保跨浏览器的一致性样式。\r\n\r\n* bootstrap图标按钮\r\n  >bootstrap包括200个来自Glyphicon Halflings的字体图标\r\n\r\n  * 不要和其它组件混合使用\r\n  * 图标 class 不能和其它元素联合使用，因为这些图标被设计为独立的元素、独立使用。\r\n\r\n  ```html\r\n  <button type=\"button\" class=\"btn btn-default btn-lg\">\r\n    <span class=\"glyphicon glyphicon-star\"></span> Star\r\n  </button>\r\n  ```\r\n\r\n## bootstrap工具类\r\n* 关闭按钮\r\n  >通过使用一个象征关闭的图标，可以用来让模式对话框和警告框消失\r\n\r\n  ```html\r\n  <button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>\r\n  ```\r\n\r\n* 下拉三角\r\n\r\n  ```html\r\n  <span class=\"caret\"></span>\r\n  ```\r\n\r\n* 快速浮动\r\n\r\n  ```html\r\n  <div class=\"pull-left\">...</div>\r\n  <div class=\"pull-right\">...</div>\r\n  ```\r\n\r\n* 内容区域居中\r\n\r\n  ```html\r\n  <div class=\"center-block\">...</div>\r\n  ```\r\n\r\n* 清除浮动\r\n\r\n  ```html\r\n  <div class=\"clearfix\">...</div>\r\n  ```\r\n\r\n* 显示或隐藏\r\n\r\n  ```html\r\n  <div class=\"show\">...</div>\r\n  <div class=\"hidden\">...</div>\r\n  ```\r\n\r\n* 隐藏元素\r\n  >使用.sr-only可以针对除了屏幕阅读器之外的所有设备隐藏一个元素\r\n\r\n* 图片替换\r\n  >使用.text-hide 可以将页面元素所包含的文本内容替换为背景图。也就是隐藏\r\n  文字但是标签所在的区域大小不变\r\n\r\n  ```html\r\n  <h1 class=\"text-hide\">Custom heading</h1>\r\n  ```\r\n\r\n## bootstrap响应式设计\r\n\r\n### bootstrap响应式添加标签\r\n\r\n* Bootstrap是移动设备优先的。针对移动设备的样式融合进了框架的每个角落，而不是一个单一的文件。\r\n* 为了确保适当的绘制和触屏缩放，需要在< head>之中添加viewport元数据标签。\r\n\r\n  ```html\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  ```\r\n\r\n* 在移动设备浏览器上，通过为viewport meta标签添加user-scalable=no可以禁用其缩放（zooming）功能。这样禁用缩放功能后，用户只能滚动屏幕，就能让你的网站看上去更像原生应用的感觉。**注意** 这种方式我们并不推荐所有网站使用，还是要看你自己的情况而定！\r\n\r\n  ```html\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\r\n  ```\r\n\r\n* **响应式图片:** 通过添加.img-responsive class可以让Bootstrap 3中的图片对响应式布局的支持更友好。其实质是为图片赋予了max-width: 100%; 和height: auto;属性，可以让图片按比例缩放，不超过其父元素的尺寸。\r\n\r\n  ```html\r\n  <img src=\"...\" class=\"img-responsive\" alt=\"Responsive image\">\r\n  ```\r\n\r\n### bootstrap响应式类\r\n\r\n| | 超小屏幕 手机(<768px) |小屏幕 平板(≥768px)|中等屏幕 桌面(≥992px)|大屏幕 桌面(≥1200px)|\r\n| :------------- | :------------: | :------------: | :------------: | :------------: |\r\n| .visible-xs      | 可见      | 隐藏      | 隐藏      | 隐藏      |\r\n|.visible-sm | 隐藏 | 可见 | 隐藏 | 隐藏|\r\n|.visible-md | 隐藏 | 隐藏 | 可见 | 隐藏|\r\n|.visible-lg | 隐藏 | 隐藏 | 隐藏 | 可见|\r\n|.hidden-xs | 隐藏 | 可见 | 可见 | 可见|\r\n|.hidden-sm |可见 | 隐藏 | 可见 | 可见|\r\n|.hidden-md |可见 | 可见 | 隐藏 | 可见|\r\n|.hidden-lg | 可见 | 可见 | 可见 | 隐藏|\r\n\r\n\r\n\r\n### bootstrap禁用响应式步骤\r\n\r\n1. 移除（或者不要添加）viewport <meta>。\r\n\r\n2. 通过为.container设置一个width值从而覆盖框架的默认width设置，例如width: 970px !important;。确保这些设置全部放在默认的Bootstrap CSS后面。可以略去!important 。\r\n\r\n3. 如果使用了导航条，需要移除所有导航条的折叠和展开行为。对于栅格布局，额外增加.col-xs-* classe或替换掉.col-md-* 和.col-lg-* 。不要担心，针对超小屏幕设备的栅格系统能够在所有分辨率的环境下展开。\r\n\r\n4. 针对IE8需要额外引入Respond.js文件 （由于仍然有媒体查询代码，因此还需要做处理）。这样就禁用了Bootstrap对小屏幕设备的响应式支持。\r\n","timestamp":1585877701769},{"name":"002-综合练习.md","path":"001-前端/08-JavaScript/006-jQuery/004-框架及综合练习/002-综合练习.md","content":"1. 移动端音乐APP\r\n2. 完成自己设计的电商网站页面\r\n3. 完成在线聊天室\r\n","timestamp":1585877701769},{"name":"01-Layui.md","path":"001-前端/08-JavaScript/007-插件、库/01-PC端UI框架/01-Layui.md","content":"# Layui\r\nLayui是一个模块化白那些的前端UI框架，兼容人类正在使用的全部浏览器（IE6/7除外）。可作为 PC 端后台系统与前台界面的速成开发方案，也可单独使用其中某一模块方便开发特定功能。\r\n\r\n[Layui官网及下载](https://www.layui.com/)\r\n[Layui官方文档](https://www.layui.com/doc/)\r\n[W3C文档](http://www.dosrun.com/layui/)\r\n\r\n## 下载\r\n* 直接下载\r\n[Layui下载地址](https://res.layui.com/static/download/layui/layui-v2.4.5.zip)\r\n\r\n文件结构：\r\n```\r\n├─css      //css目录\r\n│  │─modules       //模块css目录（一般如果模块相对较大，我们会单独提取，比如下面三个：）\r\n│  │  ├─laydate\r\n│  │  ├─layer\r\n│  │  └─layim\r\n│  └─layui.css     //核心样式文件\r\n├─font         //字体图标目录\r\n├─images       //图片资源目录（目前只有layim和编辑器用到的GIF表情）\r\n│─lay      //模块核心目录\r\n│  └─modules       //各模块组件\r\n│─layui.js     //基础核心库\r\n└─layui.all.js     //包含layui.js和所有模块的合并文件\r\n```\r\n\r\n* npm安装\r\n```js\r\nnpm install layui-src\r\n```\r\n\r\n## 使用\r\n### 按需模块化引入\r\n需要什么功能，引入什么模块，更加节省资源\r\n```html\r\n<head>\r\n    <!-- 引入核心样式文件 layui.css -->\r\n  <link rel=\"stylesheet\" href=\"layui/css/layui.css\">\r\n</head>\r\n<body>\r\n    <!-- 引入基础核心库 layui.js -->\r\n    <script src=\"layui/layui.js\"></script>\r\n    <script>\r\n        // 引入 \'layer\'、\'form\'模块\r\n        layui.use([\'layer\', \'form\'], function(){\r\n            var layer = layui.layer, form = layui.form;\r\n            \r\n            layer.msg(\'Hello World\');\r\n        });\r\n    </script> \r\n</body>\r\n```\r\n\r\n\r\n### 全部引入\r\n非模块化引入，即所有模块一次性加载\r\n```html\r\n<head>\r\n    <!-- 引入核心样式文件 layui.css -->\r\n    <link rel=\"stylesheet\" href=\"layui/css/layui.css\">\r\n</head>\r\n<body>\r\n    <!-- 引入基础核心库 layui.js -->\r\n    <script src=\"layui/layui.all.js\"></script>\r\n    <script>\r\n        // 由于模块都一次性加载，因此不用执行 layui.use() 来加载对应模块，直接使用即可\r\n        \r\n        var layer = layui.layer, form = layui.form;\r\n        \r\n        layer.msg(\'Hello World\');\r\n        \r\n    </script> \r\n</body>\r\n```\r\n\r\n## 模块\r\n\r\n模块名 | 功能\r\n---|---\r\n**layer** | **弹出框**\r\n**table**| **表格**\r\n**form** | **表单**\r\n**upload** | **文件上传**\r\n**element**| **元素操作(选项卡、导航、面包屑等)**\r\nlaydate | 日期时间选择\r\nlaypage | 分页\r\nlaytpl | 前端模板引擎 (数据渲染)\r\nlayim | 即时通讯\r\ncolorpicker | 颜色选择\r\nslider | 滑块\r\nrate | 评分\r\ncarousel | 轮播图\r\nflow | 流加载 (信息、图片懒加载)\r\nutil | 工具集 (倒计时，回到顶部固定块)\r\ncode | 代码修饰器 (修改pre标签样式用以展示代码)\r\n\r\n\r\nLayui常用来制作后台页面，常用内容包含： 栅格系统、Layer弹出模块、table表格模块、form表单模块、upload文件上传模块、element元素操作模块。\r\n\r\n[Layui简单后台实现](https://www.layui.com/demo/layuiAdmin.html)\r\n[官方提供后台模板解决方案](https://www.layui.com/admin/pro/#/)\r\n\r\n\r\n## Layer 弹出层的独立使用\r\n弹出层`Layer`是Layui中最著名的一个模块，用来实现Web弹层。前台页面经常使用的弹框提示(例如登录、退出、警告提示等)，都可以借助Layer来实现。\r\n\r\n[Layer官网](http://layer.layui.com/)\r\n[独立版本Layer下载](http://res.layui.com/static/download/layer/layer-v3.1.1.zip)\r\n\r\n![后台模板](assets/007/01/01-1545470121000.png)\r\n\r\n\r\n\r\n### 使用\r\n\r\n**需要引入jQuery 1.8+**\r\n\r\n```html\r\n<head>\r\n    <script src=\"http://cdn.bootcss.com/jquery/1.12.3/jquery.min.js\"></script>\r\n</head>\r\n<body>\r\n    <!-- 引入基础核心库 layer.js -->\r\n    <script src=\"layer/layer.js\"></script>\r\n    <script>\r\n        // 事件需自己绑定，以下只展现调用代码\r\n\r\n        layer.alert(\'内容\');\r\n    </script> \r\n</body>\r\n```\r\n","timestamp":1585877701769},{"name":"01-Amaze UI.md","path":"001-前端/08-JavaScript/007-插件、库/02-移动端端UI框架/01-Amaze UI.md","content":"# Amaze UI\r\nAmaze UI 是一个针对 HTML5 开发的轻量级、模块化、移动优先的跨屏前端框架，通过拆分、封装了一些常用的网页组件，比如轮播图框、文字框等等组件。\r\n\r\n[AmazeUI官网及下载](http://amazeui.org/)\r\n[AmazeUI官方文档](http://amazeui.org/widgets/accordion)\r\n[W3C文档](https://www.w3cschool.cn/amazeui/)\r\n\r\n兼容性：\r\n由于Amaze UI 面向现代浏览器开发，因此，Amaze UI 对 IE 8/9 等浏览器只提供有限的支持。\r\n\r\n## 下载\r\n\r\n文件结构：\r\n```\r\n|-- assets\r\n|   |-- css\r\n|   |   |-- amazeui.css             // Amaze UI 所有样式文件\r\n|   |   |-- amazeui.min.css           // 约 42 kB (gzipped)\r\n|   |   |-- amazeui.flat.css        // 圆角版 Amaze UI CSS\r\n|   |   `-- app.css\r\n|   |-- i                           // 图片文件夹\r\n|   |   |-- favicon.png\r\n|   `-- js\r\n|       |-- amazeui.js                //  Amaze UI 所有js\r\n|       |-- amazeui.min.js                // 约 56 kB (gzipped)\r\n|       |-- amazeui.ie8polyfill.js        // IE8 polyfill\r\n|       |-- amazeui.widgets.helper.js\r\n|       |-- amazeui.widgets.helper.min.js\r\n|       |-- app.js\r\n|       `-- handlebars.min.js\r\n|-- blog.html      // 博客页面模板\r\n|-- index.html      // 空白 HTML 模板；\r\n|-- landing.html    //  Landing Page 模板\r\n|-- login.html      // 登录界面模板\r\n|-- sidebar.html    // 带边栏的文章模板\r\n`-- admin-*.html     // 简单的管理后台界面\r\n```\r\n\r\n## 使用\r\n框架使用方法详见各个功能的html模板，如登录、文件上传、博客页面、后台管理等模板。\r\n\r\n|页面| CSS组件说明 |js插件组件说明|\r\n|展示页面| 网格 图标 按钮 表单 文章页 导航条 辅助类|下拉组件 滚动侦测|\r\n|登录页面| 网格 图标 按钮 按钮组 表单| |\r\n|博客页面| 网格 等宽布局 图标 按钮 面板 列表 分页|下拉组件 |\r\n|博客侧栏页面| 网格 文章页 评论列表 按钮 图标 列表 辅助类 |侧边栏组件 |\r\n\r\n引入相关依赖文件时也可采用官方CDN：\r\n```\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/css/amazeui.css\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/css/amazeui.min.css\r\n\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.js\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.min.js\r\n\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.ie8polyfill.js\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.ie8polyfill.min.js\r\n\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.widgets.helper.js\r\nhttp://cdn.amazeui.org/amazeui/2.7.2/js/amazeui.widgets.helper.min.js\r\n```\r\n\r\n\r\n### 使用方法\r\n1. 在[组件库](http://amazeui.org/widgets/accordion)中找到自己需要的布局结构，拷贝演示中的代码，粘贴到 Amaze UI HTML 模板 (即下载的amaze压缩包html文件) `<body>` 区域；\r\n2. 引入 Handlebars 库(`handlebars.min.js`)及 `amui.widget.helper.js`\r\n3. 渲染数据 （以下以折叠面板accordion 举例）\r\n    1. 将组件调用代码写在模板中：\r\n    ```html\r\n    <script type=\"text/x-handlebars-template\" id=\"my-tpl\">\r\n        {{>accordion accordionData}}\r\n    </script>\r\n    ```\r\n    2. 获取模板内容，传入数据渲染并插入到页面中。其中`data`字段中的`accordionData`即为渲染折叠面板所需要的数据\r\n    ```js\r\n    $(function() {\r\n        var $tpl = $(\'#my-tpl\'),\r\n            tpl = $tpl.text(),\r\n            template = Handlebars.compile(tpl),\r\n            data = {\r\n                accordionData: {\r\n                    \"theme\": \"basic\",     // 主题\r\n                    // 内容（*为必备项）\r\n                    \"content\": [  \r\n                        {\r\n                            \"title\": \"标题一\",   // 标题，支持 html\r\n                            \"content\": \"内容一\",  // 内容，支持 html\r\n                            \"active\": true,      // 是否激活当前面板，如果需要激活则设置为 true，否则可不用设置此项\r\n                            \"disabled\": null // 是否禁用当前面板，如果需要禁用则设置为 true，否则不用设置此项，禁用以后此面板将保持默认状态，不响应用户操作\r\n                        },\r\n                        {\r\n                            \"title\": \"标题二\",\r\n                            \"content\": \"内容二\"\r\n                        },\r\n                        {\r\n                            \"title\": \"标题三\",\r\n                            \"content\": \"内容三\"\r\n                        }\r\n                    ]\r\n                }\r\n            },\r\n            html = template(data);\r\n\r\n        $tpl.before(html);\r\n    });\r\n    ```\r\n4. 其他模板使用方法与上文折叠面板相同，只需要改变`data`中的渲染数据即可。可参考 Amaze UI HTML 模板 里的 `widget.html` 文件    \r\n\r\n\r\n","timestamp":1585877701769},{"name":"01-数据可视化.md","path":"001-前端/08-JavaScript/007-插件、库/03-数据可视化/01-数据可视化.md","content":"# 数据可视化\r\n数据可视化主要旨在借助于图形化手段，清晰有效地传达与沟通信息。简单来说，数据可视化就是将数据以图表、动画等形式展现出来，供人们方便的查看数据。\r\n\r\n## 为什么要数据可视化(优点)\r\n1. 传递速度快，人脑对视觉信息的处理要比书面信息块10倍。使用图表来总结复杂的数据，可以确保对关系的理解要比那些混乱的报告或电子表格更快。\r\n2. 数据显示的多维性，在可视化的分析下，数据将每一维的值分类、排序、组合和显示，这样就可以看到表示对象或事件的数据的多个属性或变量。\r\n3. 更直观的展示信息，大数据可视化报告使我们能够用一些简短的图形就能体现那些复杂信息，甚至单个图形也能做到。\r\n\r\n## 前端数据可视化框架\r\n前端数据可视化的框架有很多，每个框架都有自己优缺点，这里我们主要介绍下面三个。使用的时候根据项目的要求进行选择。\r\n\r\n### Echarts\r\nEcharts 完全免费，代码开源。        \r\nEcharts 基于Canvas，(ECharts v3.8 发布了 SVG 渲染器)适用于数据量比较大的情况。   \r\nEcharts 兼容 IE6 及以上的所有主流浏览器，同样支持移动端的缩放和手势操作。\r\necharts 百度的良心库，echarts入手简单，文档清晰，效果绚丽，主要是国产，文档也很容易看。          \r\necharts 支持按需求打包,可以在线构建项目时，选择项目所需要使用到的模块，从而达到减小JS文件的体积\r\necharts 的体积较大。echarts的可定制性差，hightcharts也是如此，如果出现了要绘制配置中不支持的图表，那么就只能放弃，尝试着使用其他的框架。\r\n\r\n### Highcharts\r\nHighcharts 非商业免费，商业需授权，代码开源。    \r\nHighcharts 基于SVG，方便自己定制，但图表类型有限。         \r\nHighcharts 兼容 IE6 及以上的所有主流浏览器，完美支持移动端缩放、手势操作。\r\n\r\n### D3\r\nD3 完全免费，代码开源。       \r\nD3.v3 基于SVG，方便自己定制；D3.v4支持Canvas+SVG，如果计算比较密集，也可以选择用Canvas。除此之外，D3图表类型非常丰富，几乎可以满足所有开发需求，但代码相对于以上两个插件来说，会稍微难一点。    \r\nD3 兼容IE9 及以上的所有主流浏览器，对于移动端的兼容性也同上。                  \r\nD3.js 入门略麻烦，但效果繁多，组建灵活，而且还有专门的书来讲解怎么做，可以说发展到现在已经是全世界公认的第一可视化框架     \r\n\r\n### 选择\r\n* 这三个插件都兼容IE9及以上的所有主流浏览器，但如果开发需求中包括IE7/IE8，那么就只能选择Highcharts或者Echarts了。                 \r\n* 三个插件中只有Highcharts用于商业用途中时需要授权，其他两个都不需要。                                             \r\n* D3相对于其他两个来说比较难，如果数据量比较大，可以考虑Echarts；如果只是一些简单的数据，且客户对界面定制较多，则可以考虑使用highcharts；如果前两者都不能满足需求，那么就只能用D3来一点一点做了。       \r\n","timestamp":1585877701769},{"name":"02-ECharts.md","path":"001-前端/08-JavaScript/007-插件、库/03-数据可视化/02-ECharts.md","content":"# Echarts\r\n这里主要介绍Echarts的使用。echarts.js得到了百度团队的重视，在git上面的更新也是比较的频繁，所以不会出现一些比较严重的bug之类的。同时官网中有大量的实例，提供给我们进行参考\r\n\r\n## 下载\r\n1. 官网下载界面：http://echarts.baidu.com/download.html    \r\n    * 可自由选择下载不同版本、不同主题、所需地图数据，根据需求进行个性化定制。              \r\n    * 刚开始学习和开发环境建议下载源代码版本，因为该版本包含了常见的警告和错误提示。          \r\n    * 在线定制可以选择需要的图表、坐标系、组件、以及是否压缩等一些其他选项。    \r\n\r\n2. 在 ECharts 的 GitHub 上下载最新的 release 版本，解压出来的文件夹里的 dist 目录里可以找到最新版本的 echarts 库。 https://github.com/apache/incubator-echarts\r\n\r\n3. 使用如下命令通过 npm 安装 ECharts `npm install echarts --save` 然后直接在项目代码中 require(\'echarts\') 。得到的是已经加载了所有图表和组件的 ECharts 包，因此体积会比较大，如果在项目中对体积要求比较苛刻，也可以只按需引入需要的模块。   按需引入的列表：https://github.com/apache/incubator-echarts/blob/master/index.js\r\n\r\n4. 也可以通过cdn引入，国内bootcdn：https://www.bootcdn.cn/echarts/          \r\n```html\r\n<script src=\"https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.common.js\"></script>\r\n```\r\n\r\n\r\n\r\n## 使用  \r\nEcharts这个框架的配置内容很是多，所以不要尝试着把这个框架中的方法都给记住，这是不太可能的事，Echarts的官方文档介绍十分详细，所以使用的时候查看官方文档就可以 http://echarts.baidu.com/\r\n\r\n### 基本使用步骤\r\n1. 首先将echarts.js引入`<script src=\"echarts.js\"></script>`,然后为echarts提供一个DOM容器（具有宽高）`<div id=\"chart\" style=\"width: 800px;height:400px;\"></div>`\r\n```html\r\n<script src=\"echarts.js\"></script>\r\n<div id=\"chart\" style=\"width: 800px;height:400px;\"></div>\r\n```\r\n2. 为echarts配置参数\r\n      1. 初始化DOM容器，用echarts.init()函数          \r\n      `var myChart = echarts.init(document.getElementById(\'chart\'));`\r\n      2. 配置数据选项\r\n      ```js          \r\n          var options={  \r\n\t\t\t\t\t\t\ttitle:{},//图表的标题\r\n              、、、、、、、、、、\r\n\t\t\t     }\r\n      ```\r\n3. myChart.setOption(options);将数据选项更新(就可以实现一个简单的图例)                  \r\necharts的图形化呈现主要是通过配置方法来实现的(setOption),然后是对图形标签进行初始化，最后把配置方法(setOption)赋值到初始化图形中。\r\n4. 按照上面的流程就可以实现一个简单的图表，完整代码如下\r\n>简单实现了一个饼图，请在后面查看具体的配置项介绍。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"UTF-8\">\r\n\t<title>ECharts展示</title>\r\n\t<script src=\"echarts.js\"></script>\r\n</head>\r\n<body>\r\n\t<div id=\"chart\" style=\"width: 800px;height:400px;\"></div>\r\n</body>\r\n<script>\r\n\tvar myChart = echarts.init(document.getElementById(\'chart\'));\r\n\tvar options={  \r\n        series:[{\r\n\t            type:\'pie\',\r\n\t            data:[\r\n\t                {value:335, name:\'直接访问\'},\r\n\t                {value:310, name:\'邮件营销\'},\r\n\t                {value:274, name:\'联盟广告\'},\r\n\t                {value:235, name:\'视频广告\'},\r\n\t                {value:400, name:\'搜索引擎\'}\r\n\t            ]\r\n        }]\r\n    }\r\n    myChart.setOption(options);\r\n</script>\r\n</html>\r\n```\r\n![简单案例](amWiki/images/简单实现.jpg)\r\n","timestamp":1585877701769},{"name":"03-ECharts中的配置.md","path":"001-前端/08-JavaScript/007-插件、库/03-数据可视化/03-ECharts中的配置.md","content":"### 配置项\r\noptions中的配置项非常之多，记住所有的并不太现实，在这里列一些重要的做介绍\r\n\r\n| 配置项 | 描述 |\r\n| ---- | ---- |\r\n| title | 标题组件，包含主标题和副标题。可以对这些标题设置样式 |\r\n| legend | 图例组件，图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。 |\r\n| grid | 直角坐标系内绘图网格，可以在网格上绘制折线图，柱状图，散点图（气泡图） |\r\n| xAxis | 直角坐标系 grid 中的 x 轴 |\r\n| yAxis | 直角坐标系 grid 中的 y 轴 |\r\n| polar | 极坐标系，可以用于散点图和折线图。每个极坐标系拥有一个角度轴和一个半径轴。 |\r\n| radar | 雷达图坐标系组件，只适用于雷达图。 |\r\n| tooltip | 提示框组件。 |\r\n| axisPointer | 这是坐标轴指示器（axisPointer）的全局公用设置。 |\r\n| brush | 区域选择组件，用户可以选择图中一部分数据，从而便于向用户展示被选中数据 |\r\n| geo | 地理坐标系组件用于地图的绘制，支持在地理坐标系上绘制散点图，线集。 |\r\n| timeline | 提供了在多个 ECharts option 间进行切换、播放等操作的功能。 |\r\n| dataset | 数据集组件，用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。 |\r\n| series | 系列列表。每个系列通过 type 决定自己的图表类型 |\r\n| color | 调色盘颜色列表 |\r\n| backgroundColor | 背景色，默认无背景。 |\r\n\r\n#### title组件，包含主标题和副标题。(副标题的相关设置与主标题一样，在前面属性名前面加sub)\r\n| 属性名 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| id | 默认不指定。指定则可用于在 options 或者 API 中引用组件。(所有的id解释都是相同的)| string |\r\n| show | 是否显示标题 | 布尔值，默认为true |\r\n| text | 主标题文本，支持使用 \\n 换行 | 字符串 |\r\n| link | 主标题文本超链接。| 字符串。比如`link:\'http://www.echartsjs.com\'` |\r\n| target | 与a连接的target属性一样，设置打开主标题连接的方式。| \'self\' 当前窗口打开， \'blank\' 新窗口打开|\r\n| textStyle | 设置主标题的文本样式，就是字体的颜色、字号、字体、行高、阴影等等| 一个对象 |\r\n| subtext | 副标题的文本 | 字符串 |\r\n| itemGap | 主标题与副标题之间的间距，| number类型，表示像素，默认为10 |\r\n| zlevel | 用于 Canvas 分层，不同zlevel值的图形会放置在不同的 Canvas 中，Canvas 分层是一种常见的优化手段。 | number 默认为0 |\r\n| z | 设置标题的层级,z值小的图形会被z值大的图形覆盖。| number类型 |\r\n| left、right | 组件离容器左侧/右侧的距离 | number类型表示像素，string可以是\'50%\'、\'left\'、 \'center\'、\'right\' |\r\n| top、bottom | 组件离容器上侧/下侧的距离。 | number类型表示像素，string可以是\'50%\'、\'top\'、 \'middle\'、\'bottom\' |\r\n| backgroundColor | 标题背景色 | 默认透明，支持rgba格式 |\r\n| borderWidth | 标题的边框线宽 | number 表示像素 |\r\n| borderRadius | 边框的圆角半径　| number表示统一设置四个角，array可以对四个角分别设置 |\r\n| borderColor | 边框的颜色 |　默认\'#ccc\' |\r\n还可以设置标题阴影的模糊程度、偏移程度、颜色等进行设置\r\n\r\n#### legend 图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。\r\n| 属性名 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| type | 图例的类型 | \'plain\'：普通图例。缺省就是普通图例。\'scroll\'：可滚动翻页的图例。当图例数量较多时可以使用。 |\r\n| id | 默认不指定。指定则可用于在 option 或者 API 中引用组件。| string |\r\n| show | 是否显示图例 | 布尔值，默认为true |\r\n| zlevel | 同title的zlevel | number |\r\n| z | 同title的z | number默认值为2 |\r\n| top、left、right、bottom | 同title组件 | 参看title |\r\n| width、height| 图例组件的宽度、高度 | string、number，默认为auto自适应 |\r\n| orient | 图例列表的布局朝向。 | \'horizontal\':表示横排默认；\'vertical\'：表示竖排|\r\n| padding | 图例内边距 | number和array |\r\n| itemGap | 图例每项之间的间隔。横向布局时为水平间隔，纵向布局时为纵向间隔。 | number，默认为10 |\r\n| itemWidth、itemHeight | 图例标记的图形的宽度/高度 | number |\r\n| formatter | 用来格式化图例文本 | string, Function |\r\n| selectedMode | 控制是否可以通过点击图例改变系列的显示状态 | string, boolean，默认为true，可以设成 \'single\' 或者 \'multiple\' 使用单选或者多选模式。 |\r\n| inactiveColor | 图例关闭时的颜色。 | 值为颜色 |\r\n| selected | 图例选中状态表。 | 值为一个对象，{\'a\':true},表示a为选中 |\r\n| textStyle | 图例的公用文本样式。 | 值为一个对象，与title中的一样 |\r\n| tooltip | 提示框组件 | 值为一个对象详细介绍查看后面的tooltip组件 |\r\n| data | 图例的数据数组 | 数组中内容可以为字符串，也可为对象，具体查看下面例子 |\r\n|backgroundColor| 图例的背景颜色 | 同title的，默认透明 |\r\n| borderColor、borderWidth、等 | 边框和阴影的设置  | 同title中的一样 |\r\n\r\n以下的属性需要在图例组件的type值设为scroll才能生效\r\n\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- | ----|\r\n| scrollDataIndex | 决定当前图例滚动到哪里 | number |\r\n| pageButtonItemGap | 图例控制块中，按钮和页信息之间的间隔。 | number，默认值为5 |\r\n| pageButtonGap | 图例控制块和图例项之间的间隔 | number |\r\n| pageButtonPosition | 图例控制块的位置 | \'start\'：控制块在左或上。\'end\'：按钮快在右或下。默认\'end\' |\r\n| pageFormatter | 图例控制块中，页信息的显示格式。 | function、string，默认为 \'{current}/{total}\'，其中 {current} 是当前页号（从 1 开始计数），{total} 是总页数。使用函数，须返回这两个值 |\r\n| pageIcons | 图例控制块的图标 | 值为一个对象，分别设置横排和竖排的图标 |\r\n| pageIconColor | 翻页按钮的颜色 | string |\r\n| pageIconInactiveColor | 翻页按钮不激活时（即翻页到头时）的颜色。 | string |\r\n| pageIconSize | 翻页按钮的大小 | 可以是number，也可以是array表示 [宽,高]|\r\n| pageTextStyle | 图例页信息的文字样式 | 一个对象，值同textStyle|\r\n| animation | 翻页是否使用动画 |  布尔值 |\r\n| animationDurationUpdate | 翻页是的动画时长 | number 毫秒 |\r\n\r\n#### tooltip 提示框组件\r\n提示框组件设置到的地方很多，\r\n* 可以设置在全局，即 tooltip\r\n* 可以设置在坐标系中，即 grid.tooltip、polar.tooltip、single.tooltip\r\n* 可以设置在系列中，即 series.tooltip\r\n* 可以设置在系列的每个数据项中，即 series.data.tooltip\r\n\r\n| 属性 | 描述 | 值 |\r\n| ----- | ---- | ----|\r\n| show | 是否显示提示框组件 | 布尔值，默认为true |\r\n| trigger| 触发类型| \'item\'：数据项图形触发，主要在散点图，饼图等无类目轴的图表中使用。\'axis\'：坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用。\'none\'：什么都不触发。 |\r\n| axisPointer | 坐标轴指示器配置项。 | object，参看axisPointer组件 |\r\n| showContent | 是否显示提示框浮层，| 布尔值，默认显示。 |\r\n|alwaysShowContent | 是否永远显示提示框内容 | 布尔值，默认为false |\r\n| triggerOn | 提示框触发的条件 | string，\'mousemove\'：鼠标移动时触发。\'click\'：鼠标点击时触发。\'mousemove、click\'(默认)：同时鼠标移动和点击时触发。 |\r\n| showDelay | 浮层显示的延迟，单位为 ms， | number默认没有延迟 ，不建议设置，在 triggerOn 为 \'mousemove\' 时有效。|\r\n| hideDelay | 浮层隐藏的延迟，单位为 ms， | number 默认100 |\r\n| enterable | 鼠标是否可进入提示框浮层中 | 布尔值 默认为false|\r\n| renderMode |   浮层的渲染模式 | 默认以 \'html 即额外的 DOM 节点展示 tooltip；此外还可以设置为 \'richText\' 表示以富文本的形式渲染  |\r\n| confine | 是否将 tooltip 框限制在图表的区域内。 | 布尔值，默认为false |\r\n| transitionDuration| 提示框浮层的移动动画过渡时间 | number，单位为s |\r\n| position | 提示框浮层的位置，默认不设置时位置会跟随鼠标的位置。 | array：[20,20]绝对位置 [\'50%\',\'50%\']相对位置，只在 trigger 为\'item\'的时候有效。{\'inside\':鼠标所在图形的内部中心位置，\'top\':鼠标所在图形上侧,\'left\'、\'right\'、\'bottom\'} |\r\n| formatter | 提示框浮层内容格式器，支持字符串模板和回调函数两种形式。 | 查看上面legend的formatter |\r\n| backgroundColor | 提示框浮层的背景颜色 | 写一个颜色值 |\r\n| borderColor | 提示框浮层的边框颜色。 | 写一个颜色值 |\r\n| borderWidth | 提示框浮层的边框宽 | number |\r\n| padding | 提示框浮层的内边距 | number |\r\n| textStyle | 提示框浮层的文本样式 | object 同title组件的textStyle |\r\n| extraCssText | 额外附加到浮层的 css 样式 | string，就是写css样式就可以 |\r\n\r\n#### toolbox 工具栏。内置有导出图片，数据视图，动态类型切换，数据区域缩放，重置五个工具。\r\n| 属性 | 描述 | 值|\r\n| ---- | ---- | ---- |\r\n| id | 指定则可用于在 option 或者 API 中引用组件 | string |\r\n| show | 是否显示工具栏组件 | 布尔值 |\r\n| orient | 工具栏 icon 的布局朝向。 | 同legend的orient |\r\n| itemSize | 工具栏 icon 的大小。 | number，默认值为15 |\r\n| itemGap | 工具栏 icon 每项之间的间隔 | number，默认值为10  |\r\n| showTitle | 是否在鼠标 hover 的时候显示每个工具 icon 的标题。 | 布尔值 |\r\n| iconStyle | 公用的 icon 样式设置 | 值为一个对象，包含icon的颜色、边框、阴影、透明度等 |\r\n| emphasis | 鼠标 hover 时候的高亮样式。 | 值为一个对象，对象中包含一个iconStyle属性，也是对象，同上面的iconStyle |\r\n| zlevel、z | 同上 | number |\r\n| left、right、top、bottom | 同上 | string、number|\r\n| width、height | 组件容器的宽/高 | string/number |\r\n| feature | 各工具配置项 | object 查看下面的饼图的案例  |\r\n\r\n\r\n#### series系列列表。每个系列通过 type 决定自己的图表类型\r\nseries是一个数组，里面可以写很多的对象，每一个对象就是一个图表类型，每个对象上的type属性来控制图表的类型，他们有很多都一样的样式，我在前面先总结一哈\r\n\r\n| 属性  | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| type | 设置图表的类型 | string |\r\n| id | 组件 ID。指定则可用于在 option 或者 API 中引用组件 | string 默认不指定。|\r\n| name | 系列名称，用于tooltip的显示，legend 的图例筛选，在 setOption 更新数据和配置项时用于指定对应的系列。 | string |\r\n| legendHoverLink | 是否启用图例 hover 时的联动高亮。 | 布尔值，默认为true |\r\n| cursor | 鼠标悬浮时在图形元素上时鼠标的样式是什么 | string 跟css的cursor一样 |\r\n| label | 图形上的一些文本标签，可用于说明图形的一些数据信息 | object，主要控制文字颜色、字号、对齐方式、阴影、边框、宽高、描边颜色 |\r\n| itemStyle | 图形样式 | object，主要控制图形颜色、边框、阴影、透明度 |\r\n| emphasis | 高亮的图形样式和标签样式。| object，里面包换两个对象昂，分别是label和itemStyle，设置同上 |\r\n| tooltip  | 本系列提示框的设置 | object，查看tooltip组件 |\r\n| z和zlevel | 查看title组件的z和zlevel | number |\r\n| markPoint | 图表标注 | object：http://www.echartsjs.com/option.html#series-scatter.markPoint |\r\n| markLine | 图标标线 | object: http://www.echartsjs.com/option.html#series-scatter.markLine |\r\n| markArea | 图表标域，常用于标记图表中某个范围的数据，例如标出某段时间投放了广告。 | object: http://www.echartsjs.com/option.html#series-scatter.markArea |\r\n| silent | 图形是否不响应和触发鼠标事件 | 布尔值，默认为false  |\r\n| datasetIndex | 如果 series.data 没有指定，并且 dataset 存在，那么就会使用 dataset。datasetIndex 指定本系列使用那个 dataset。| number，默认为0 |\r\n| seriesLayoutBy | 系列“排布”到 dataset 的行还是列上 | \'column\'：默认，dataset 的列对应于系列，从而 dataset 中每一列是一个维度。\'row\'：dataset 的行对应于系列，从而 dataset 中每一行是一个维度|\r\n| animation | 是否开启动画 |　布尔值，默认为true |\r\n| animationThreshold | 是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画。 | number 默认值2000  |\r\n| animationDuration | 初始动画的时长 | number 默认值为1000 |\r\n| animationEasing | 初始动画的缓动效果。 | string 默认\'cubicOut \' |  \r\n| animationDelay | 初始动画的延迟，支持函数 | Function、number 默认为0|\r\n| animationDurationUpdate | 数据更新动画的时长，支持回调函数 | function、number 默认值300  |\r\n| animationEasingUpdate | 数据更新动画的缓动效果 | string 默认值为\'cubicOut\' |\r\n| animationDelayUpdate | 数据更新动画的延迟，支持回掉函数 | function、number 默认值为0 |\r\n| data | 系列中的数据内容数组 | 数组中可以包含很多对象，也可以直接写字符串数据 |\r\ndata是这里比较重要的，每种图表类型中都有，我在这里先总结了他们共有的部分，后面每种图表就只介绍他们特殊的部分。\r\n```\r\ndata:[\r\n  {\r\n    name:\'90-100\',     //数据项名称\r\n    value: 500,    //单个数据项的数值\r\n    label:{},     //每种图表的解释不同\r\n    itemStyle:{},   //折线拐点标志的样式,每种图标解释也不同\r\n    emphasis:{itemStyle:{}},    //高亮样式，对于itemStyle\r\n    tooltip:{},     //单个数据提示框的样式\r\n  },\r\n]\r\n```\r\n\r\n\r\n##### 饼图 type:\'pie\'\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- |---- |\r\n| hoverAnimation | 是否开启 hover 在扇区上的放大动画效果。 | 布尔值，默认为true |\r\n| hoverOffset | 高亮扇区的偏移距离 | number 默认为10 |\r\n| selectedMode | 选中模式，表示是否支持多个选中 | 默认关闭，支持布尔值和字符串，字符串取值可选\'single\'，\'multiple\'，分别表示单选还是多选 |\r\n| selectedOffset | 选中扇区的偏移距离 | number 默认值为10 |\r\n| clockwise | 饼图的扇区是否是顺时针排布 | 布尔值，默认为true |\r\n| startAngle | 起始角度 | number 默认为90，支持范围[0, 360] |\r\n| minAngle | 最小扇区角度，用于防止过小影响交互 | number，默认为0支持范围[0, 360] |\r\n| roseType | 是否展示成南丁格尔图，通过半径区分数据大小 | string；\'radius\' 扇区圆心角展现数据的百分比，半径展现数据的大小。\'area\' 所有扇区圆心角相同，仅通过半径展现数据大小。 |\r\n| avoidLabelOverlap | 是否启用防止标签重叠策略 | 布尔值，默认true |\r\n| stillShowZeroSum | 是否在数据和为0（一般情况下所有数据为0） 的时候不显示扇区。| 布尔值，默认为true |\r\n| labelLine | 标签的视觉引导线样式 | object 下面例子详细介绍 |\r\n| center | 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。| array [400, 300];[\'50%\', \'50%\'] |   \r\n| radius | 饼图的半径 |  number：直接指定外半径值。string:\'20%\'，表示外半径为可视区尺寸（容器高宽中较小一项）的 20% 长度。Array:[\'内半径\',\'外半径\']，内半径设大显示为圆环图 |\r\n| data | 系列中的数据内容数组。数组项可以为单个数值 | Object 结合饼图案例 |\r\n\r\n饼图简单案例\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n\t<meta charset=\"UTF-8\">\r\n\t<title>ECharts展示</title>\r\n\t<script src=\"echarts.js\"></script>\r\n</head>\r\n<body>\r\n\t<div id=\"chart\" style=\"width: 800px;height:400px;\"></div>\r\n</body>\r\n<script>\r\n\tvar myChart = echarts.init(document.getElementById(\'chart\'));\r\n\tvar options={\r\n    \ttitle:{\r\n    \t\ttext:\'学生成绩饼图\',\r\n    \t\ttextStyle:{\r\n    \t\t\tcolor:\'red\',\r\n    \t\t\tfontSize:20\r\n    \t\t},\r\n    \t\tlink:\'http://www.echartsjs.com/option.html#title.backgroundColor\',\r\n    \t\tsubtext:\'这是期末成绩分布图\',\r\n    \t\tleft:\'left\',\r\n    \t\titemGap:5,\r\n    \t\tbackgroundColor:\'blue\',\r\n    \t\tborderWidth:5,\r\n    \t},\r\n    \tlegend:{\r\n    \t\ttype:\'scroll\',\r\n    \t\tdata:[\'90-100\',\'80-90\',\'70-80\',\'60-70\',{name:\'60分以下\',icon:\'triangle\',textStyle:{color:\'green\'}}],  //ECharts 提供的标记类型包括 \'circle\', \'rect\', \'roundRect\', \'triangle\', \'diamond\', \'pin\', \'arrow\', \'none\'    也可以设置通过 \'image://url\' 设置为图片，其中 URL 为图片的链接，\r\n    \t\torient:\'horizontal\',\r\n    \t\titemWidth:20,\r\n    \t\tinactiveColor:\'red\',\r\n    \t\twidth:200,\r\n    \t\tscrollDataIndex:2,\r\n    \t\tpageButtonPosition:\'start\',\r\n    \t\tanimationDurationUpdate:1000,\r\n    \t},\r\n    \ttooltip:{\r\n    \t\tenterable:true,    //鼠标是否可进入提示框浮层中默认为false\r\n    \t\tconfine:true,   //是否将提示框限制在图表内 ，在用与移动端或者响应式的时候比较有用\r\n    \t\t//position:\'bottom\',    //提示框的位置\r\n    \t\tbackgroundColor:\'#ccc\',   //提示框的背景颜色\r\n    \t\tborderWidth:20,     //边框的大小   number\r\n    \t\tborderColor:\'red\',   //边框的颜色\r\n    \t\textraCssText:\'color:#000\',   //写提示框加css样式\r\n    \t},\r\n    \ttoolbox:{\r\n    \t\tfeature:{\r\n    \t\t\tsaveAsImage:{        //保存为图片。\r\n    \t\t\t\ttype:\'png\',      //保存图片的格式，支持 \'png\' 和 \'jpeg\'。\r\n    \t\t\t\tname:\'测试\',        //保存文件的名字，默认使用主标题\r\n    \t\t\t\t// backgroundColor:\'auto\'   保存的图片背景色，默认使用 backgroundColor，如果backgroundColor不存在的话会取白色。\r\n    \t\t\t\texcludeComponents:[\'toolbox\'] , //保存为图片时忽略的组件列表，默认忽略工具栏。\r\n    \t\t\t\tshow:true,     //是否显示该工具。\r\n    \t\t\t\t// icon:\'image://http://xxx.xxx.xxx/a/b.png\',   设置图标\r\n    \t\t\t\ticonStyle:{color:\'red\'},      //保存为图片 icon 样式设置。   \r\n    \t\t\t\temphasis:{},      //移入设置样式，同toolbox的emphasis\r\n    \t\t\t\tpixelRatio:1,    //保存图片的分辨率比例，默认跟容器相同大小   number\r\n    \t\t\t},\r\n    \t\t\trestore:{          //还原\r\n    \t\t\t\tshow:true,      //是否显示该组件\r\n    \t\t\t\ttitle:\'这是还原\',    //名称\r\n    \t\t\t\t// icon:\'\',      图标设置\r\n    \t\t\t\ticonStyle:{color:\'blue\'},    //图标样式\r\n    \t\t\t\temphasis:{iconStyle:{color:\'red\'}},     //移入显示样式，同上\r\n    \t\t\t},\r\n    \t\t\tdataView:{         //数据视图工具，可以展现当前图表所用的数据，编辑后可以动态更新。\r\n    \t\t\t\tshow:true,    //是否显示该工具      布尔值\r\n    \t\t\t\ttitle:\'数据视图\',    //移入显示的名字   string\r\n    \t\t\t\ticonStyle:{color:\'yellow\'},    //icon emphasis同上\r\n    \t\t\t\treadOnly:false,      //是否不可编辑（只读）。\r\n    \t\t\t\t//optionToContent:fun,    //自定义函数展示数据\r\n    \t\t\t\t//contentToOption:fun,   //如果支持数据编辑后的刷新，需要自行通过该函数实现组装 option 的逻辑\r\n    \t\t\t\tlang:[\'数据视图的\', \'关闭了啊\', \'刷新一哈\'],   //数据视图上有三个话术，默认是[\'数据视图\', \'关闭\', \'刷新\']。\r\n    \t\t\t},\r\n    \t\t\tdataZoom:{        //数据区域缩放。目前只支持直角坐标系的缩放。\r\n\r\n    \t\t\t},\r\n    \t\t\tmagicType:{      //动态类型切换\r\n    \t\t\t\tshow:true,    //是否显示\r\n    \t\t\t\ttype:[\'line\', \'bar\', \'stack\', \'tiled\'],   //启用的动态类型\r\n    \t\t\t\ttitle:{\r\n    \t\t\t\t\tline:\'切换为折线图\',\r\n    \t\t\t\t\tbar:\'切换为柱状图\',\r\n    \t\t\t\t\tstack:\'切换为堆叠\',\r\n    \t\t\t\t\ttiled:\'切换为平铺\',\r\n    \t\t\t\t},\r\n    \t\t\t\ticon:{\r\n    \t\t\t\t\t// line:\'image://http://xxx.xxx.xxx/a/b.png\',   配置各个icon\r\n    \t\t\t\t},\r\n    \t\t\t\ticonStyle:{color:\'pink\'},     //配置icon的样式\r\n    \t\t\t\temphasis:{iconStyle:{}},     //移入样式\r\n    \t\t\t\toption:{line:{}},      //配置每一个的样式\r\n    \t\t\t\tseriesIndex:{line:[]},    //各个类型对应的系列的列表   \r\n    \t\t\t},\r\n    \t\t\tbrush:{\r\n    \t\t\t\t\ttype:[\'rect\',\'polygon\'],\r\n    \t\t\t\t\ticon:{},     //没个按钮的icon\r\n    \t\t\t\t\ttitle:{     //标题文本。\r\n    \t\t\t\t\t\trect:\'矩形选择\',\r\n    \t\t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t},\r\n    \tseries : [\r\n        \t{\r\n            name: \'学生成绩区间\',       //数据项名称\r\n            type: \'pie\',      //饼图\r\n            radius: \'60%\',   //设置半径， [\'30%\',\'70%\']表示内圆30%，外圆70%也就是环图，只写一个值就是饼图\r\n            itemStyle:{},     //图形样式\r\n            emphasis:{},    //高亮的扇区和标签样式\r\n            hoverOffset:15,   //高亮扇区的偏移距离\r\n            roseType:false,   //是否设置为南丁格尔图\r\n            labelLine:{\r\n            \tshow:true,   //是否显示引导线\r\n            \tlength:10,   //引导线第一段的长度\r\n            \tlength2:50,   //引导线第二段的长度\r\n            \tsmooth:0.5,    //0-1 平滑程度\r\n            \tlineStyle:{    //引导线的样式\r\n            \t\tcolor:\'red\',   //引导线的颜色，支持rgba，还可以设置渐变和纹理\r\n            \t\twidth:2,     // number   线宽\r\n            \t\ttype:\'dashed\',  // 线的类型 \'solid\'\\\'dashed\'\\\'dotted\'\r\n            \t\t//还支持阴影的设置\r\n            \t\topacity:0.5,      //t透明度。同css的opacity\r\n            \t},\r\n            \temphasis:{     //高亮状态下引导线的样式\r\n            \t\tlineStyle:{color:\'blue\'}      //同上面的lineStyle\r\n            \t},     \r\n            },\r\n            data:[\r\n                {\r\n                \tvalue:235,\r\n                \tname:\'90-100\',\r\n                \tlabel:{show:true,position:\'inside\',color:\'#000\'},//position设置name值得位置，默认值为outside通过视觉引导线连到相应的扇区。\r\n                \tlabelLine:{},    // 同series.lineStyle  单独设置这一项数据的引导线样式\r\n                \temphasis:{lineStyle:{}},    // 同series.emphasis  单独设置这一项数据的高亮引导线样式\r\n                \ttooltip:{}    //单独设置这一项数据的提示框\r\n                },   \r\n                {value:274, name:\'80-90\'},\r\n                {value:310, name:\'70-80\'},\r\n                {value:335, name:\'60-70\'},\r\n                {value:400, name:\'60分以下\',selected:true}    //selected设置默认选中\r\n            \t],\r\n            center:[\'50%\', \'50%\']     //圆心的位置，可以设置为绝对值和像素两种方式\r\n        \t}\r\n\t    ]\r\n\t}\r\n    myChart.setOption(options);\r\n</script>\r\n</html>\r\n```\r\n![饼图](amWiki/images/饼图.jpg) ![数据视图](amWiki/images/数据视图.jpg) ![环图](amWiki/images/环图.jpg) ![南丁格尔图](amWiki/images/ndge.jpg)\r\n\r\n\r\n##### 折线图 type:\'line\'\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| coordinateSystem| 该系列使用的坐标系 | string \'cartesian2d\'：使用二维的直角坐标系，通过 xAxisIndex, yAxisIndex指定相应的坐标轴组件。\'polar\'：使用极坐标系，通过 polarIndex 指定相应的极坐标组件  |\r\n| xAxisIndex |  在单个图表实例中存在多个 x 轴的时候有用 | number 默认值为0  |\r\n| yAxisIndex |  在单个图表实例中存在多个 y 轴的时候有用 | number 默认值为0  |\r\n| polarIndex | 使用的极坐标系的 index，在单个图表实例中存在多个极坐标系的时候有用。 |number 默认值为0  |\r\n| symbol | 标记的图形 | ECharts 提供的标记类型包括 \'circle\', \'rect\', \'roundRect\', \'triangle\', \'diamond\', \'pin\', \'arrow\', \'none\'，可以通过 \'image://url\' 设置为图片 |\r\n| symbolSize | 标记的大小 | number, Array [8,10]表示宽8高10 |\r\n| symbolRotate | 标记旋转的角度 | number |\r\n| symbolKeepAspect | 是否在缩放时保持该图形的长宽比。 | 布尔值 默认为false |\r\n| symbolOffset  | 标记相对于原本位置的偏移。 | array [string,number] [\'50%\',20] |\r\n| showSymbol | 是否显示标记的图形  | 布尔值 默认为true |\r\n| showAllSymbol | 是否显示所有的标记 |  布尔值，默认为auto：如果有足够空间则显示标志图形，否则随主轴标签间隔隐藏策略。true：显示所有图形。false：随主轴标签间隔隐藏策略。 |\r\n| hoverAnimation | 是否开启 hover 在拐点标志上的提示动画效果 | 布尔值，默认为true |\r\n| stack | 数据堆叠，同个类目轴上系列配置相同的stack值后，后一个系列的值会在前一个系列的值上相加。 | string  不太好理解，结合下面的折线案例比较好理解 |\r\n| connectNulls | 是否连接空数据 | 布尔值，默认为false |\r\n| clipOverflow | 是否对超出部分裁剪| 布尔值，默认为true裁剪 |\r\n| step | 是否是阶梯线图  |布尔值 默认为false 也支持设置成 \'start\', \'middle\', \'end\' 分别配置在当前点，当前点与下个点的中间点，下个点拐弯。 |\r\n| areaStyle | 区域填充样式 | object 查看折线图表的案例  |\r\n| smooth | 是否平滑曲线显示 | 布尔值、number(0-1) 越小表示越接近折线段 |\r\n| sampling | 数据量远大于像素点时候的降采样策略 | string 默认关闭 \'average\' 取过滤点的平均值 \'max\' 取过滤点的最大值 \'min\' 取过滤点的最小值 \'sum\' 取过滤点的和 |\r\n| encode | 可以定义 data 的哪个维度被编码成什么 | object 不好理解，请结合下面的案例去学习 |\r\n| data | 放置数据的地方， | object 里面的属性值同外面的属性值，只是给单个的设置 symbol、symbolSize、symbolRotate、symbolKeepAspect、symbolOffset |\r\n\r\n我们还需要结合其他组件才能画出折线图，\r\n\r\n#### grid 直角坐标系内绘图网格\r\n>ECharts 3 中可以存在任意个 grid 组件\r\n\r\n| 属性 | 描述 | 值 |\r\n| ---- |---- | ---- |\r\n|id | 默认不指定。指定则可用于在 option 或者 API 中引用组件 | string |\r\n| show | 是否显示直角坐标系 | 布尔值，默认为false |\r\n| zlevel、z | 图形的层级 | number 同上面组件的解释 |\r\n| left、top、right、bottom | grid组件距离容器上下左右的距离 | 值得设置同上面组件的解释 |\r\n| width、height | 组件的宽高 | string、number 默认为auto |\r\n| containLabel | grid 区域是否包含坐标轴的刻度标签 |布尔值 默认为false |\r\n| backgroundColor | 网格背景颜色 | 颜色值，默认为透明 |\r\n| borderColor、borderWidth | 设置网格的边框 | 值得解释同上面组件 |\r\n|shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY | 阴影的设置 | 值得解释同上面组件 |\r\n| tooltip | grid组件中的提示框 | 详细设置查看tooltip组件 |\r\n\r\n#### xAxis、yAxis   直角坐标系 grid 中的x轴和y 轴\r\n>x轴和y轴这两个组件的属性值一样，所以我把他们两放到一起，注意他们是两个组件。\r\n\r\n|属性 | 描述| 值 |\r\n| ---- |----|----|\r\n| id | 所有的id  |  string|\r\n| show | 是否显示x轴、y轴 |布尔值 默认为true |\r\n| gridIndex| x轴、y轴所在的grid中的索引 | number，默认位于第一个grid中 |\r\n| position | x轴、y轴的位置 | string x轴的可选值为top、bottom；y轴的可选值为left、right |\r\n|offset | x轴、y轴的偏移位置，相对于默认位置 | number 多个轴时用到 |\r\n| type | 坐标轴的类型 | \'value\'：数值轴，适用于连续数据。\'category\'：类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。\'time\'：时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。\'log\'：对数轴。适用于对数数据。 |\r\n|name | 坐标轴的名字 | string |\r\n|nameLocation | 坐标轴名字显示的位置 | 可选值 \'start\'、\'middle\'、\'center\'、\'end\' |\r\n| nameTextStyle | 坐标轴名字的样式 | object，具体是设置同title组件中的textStyle |\r\n| nameGap | 坐标轴名字与轴线之间的距离 | number 默认为15 |\r\n| nameRotate | 坐标轴名字的旋转角度值 | number，默认不旋转|\r\n|inverse | 是否反向坐标轴，ECharts 3 中新加 | 布尔值，默认为false  |\r\n| min | 坐标轴刻度最小值 |\'dataMin\'：取数据在该轴上的最小值作为最小刻度；在类目轴中，也可以设置为类目的序数 |\r\n| max | 坐标轴刻度最大值 | 和min一样，也可以设置成函数；max: function(value) {return value.max- 20;}|\r\n| boundaryGap | 坐标轴两边留白策略，类目轴和非类目轴的设置和表现不一样 | 类目轴值为布尔值，默认为 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带中间；非类目轴值为有两个值的数组，值可以是百分比或者数字，在设置 min 和 max 后无效|\r\n| scale | 只在数值轴中（type: \'value\'）有效；是否是脱离 0 值比例 | 布尔值 默认为false |\r\n| splitNumber | 坐标轴的分割段数，需要注意的是这个分割段数只是个预估值，最后实际显示的段数会在这个基础上根据分割后坐标轴刻度显示的易读程度作调整。| number 默认值为5 |\r\n| minInterval| 自动计算的坐标轴最小间隔大小 | number 默认为0，只在数值轴或时间轴中有效 |\r\n| maxInterval | 自动计算的坐标轴最大间隔大小 | number 只在数值轴或时间轴中有效 |\r\n| interval| 强制设置坐标轴分割间隔 一般不建议使用 | number 无法在类目轴中使用 |\r\n| logBase | 对数轴的底数，只在对数轴中（type: \'log\'）有效| number 默认值为10 |\r\n| silent | 坐标轴是否是静态无法交互 | 布尔值 默认为false  |\r\n| triggerEvent | 坐标轴的标签是否响应和触发鼠标事件 | 布尔值 默认为false |\r\n| axisLine | 坐标轴轴线相关设置 | object 接和下面的案例学习 |\r\n| axisTick | 坐标轴刻度相关设置 | object 接和下面的案例学习 |\r\n| axisLabel | 坐标轴刻度标签的相关设置 | object 接和下面的案例学习 |\r\n| splitLine | 坐标轴在 grid 区域中的分隔线 | object 接和下面的案例学习 |\r\n| splitArea | 坐标轴在 grid 区域中的分隔区域 | 默认不显示 object |\r\n| data | 类目数据 | 数据，结合下面的案例学习 |\r\n| axisPointer | 指示器的设置 | object，查看axisPointer组件的介绍 |\r\n| z、zlevel | 组件的层级 | 值得设置同上 |\r\n\r\n#### axisPointer 坐标轴指示器\r\n\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| id | 同上 | string |\r\n| show | 是否显示 | 布尔值 默认为false |\r\n| type | 指示器的类型 | 可选值 \'line\'：直线指示器 \'shadow\'：阴影指示器 \'none\'：无指示器 |\r\n| snap | 坐标轴指示器是否自动吸附到点上 | 布尔值， 默认为true |\r\n| z | 坐标轴指示器的 z 值控制图形的前后顺序。z值小的图形会被z值大的图形覆盖 | number |\r\n| label | 坐标指示器上的文本标签 | Object  设置参考下面的折线/面积图案例 |\r\n| lineStyle | axisPointer.type 为 \'line\' 时有效。 | object 同上 |\r\n| shadowStyle | axisPointer.type 为 \'shadow\' 时有效 | object 设置阴影的颜色，偏移程度，透明度 |\r\n| triggerTooltip | 是否触发提示框 | 布尔值。默认为true |\r\n| handle | 拖拽手柄，适用于触屏的环境 | object |\r\n| value | 当前的 value。在使用 axisPointer.handle 时，可以设置此值进行初始值设定从而决定 axisPointer 的初始位置 | number  |\r\n| link | 不同轴的 axisPointer 可以进行联动 | array [{xAxisId: [\'aa\', \'cc\'],angleAxis: \'all\'},]  // 表示左右 xAxisId 为 \'aa\'、\'cc\' 以及所有的 angleAxis 联动。|\r\n| triggerOn | 提示框的触发条件 |  可选 \'mousemove\'：鼠标移动时触发。\'click\'：鼠标点击时触发。\'none\'：不在 \'mousemove\' 或 \'click\' 时触发。 |\r\n\r\n折线图简单案例\r\n```js\r\nvar options={\r\n    \ttitle:{\r\n    \t\ttext:\'学生成绩折线/面积图\',\r\n    \t},\r\n    \tlegend:{\r\n    \t\ttype:\'scroll\',\r\n    \t\tdata:[\'学生成绩区间\'],\r\n    \t\torient:\'horizontal\',\r\n    \t\titemWidth:20,\r\n    \t\tinactiveColor:\'red\',\r\n    \t\twidth:200,\r\n    \t\tscrollDataIndex:2,\r\n    \t\tpageButtonPosition:\'start\',\r\n    \t\tanimationDurationUpdate:1000,\r\n    \t},\r\n    \tgrid:{          // 直角坐标系内绘图网格\r\n    \t\tshow:true,\r\n    \t\t// backgroundColor:\'#ccc\',   \r\n    \t\ttooltip:{},     //本坐标系特定的提示框   \r\n    \t},\r\n    \t//X轴设置\r\n        xAxis:{\r\n            data:[\'60分\',\'70分\',\'80分\',\'90分\',{value:\'100分\',textStyle: {    //类目数据\r\n        \t\tfontSize: 20,\r\n        \t\tcolor: \'red\'     \r\n    \t\t}}],\r\n            show:true,   //是否显示x轴，默认为true\r\n            position:\'top\',   // x轴的位置，默认值为bottom\r\n        \tname:\'成绩\',   //x轴的名字   也可以设置文本样式，通过nameTextStyle\r\n        \tnameTextStyle:{\r\n        \t\tcolor:\'yellow\',\r\n        \t},\r\n        \tnameGap:20,    //坐标轴名称与轴线之间的距离。 默认为15\r\n        \tinverse:true,   //是否是反向坐标轴  默认为false\r\n        \ttriggerEvent:true,  //坐标轴的标签是否响应和触发鼠标事件   默认为false\r\n        \taxisLine:{},    //坐标轴轴线相关设置。\r\n        \taxisTick:{},   //坐标轴刻度相关设置\r\n        \taxisLabel:{},   //坐标轴刻度标签的相关设置。\r\n        \taxisPointer:{},   //指示器的相关设置\r\n        },\r\n        yAxis:{\r\n        \taxisLabel:{       //坐标轴刻度标签的相关设置。\r\n        \t\tshow:true\r\n        \t},\r\n    \t\ttype : \'value\',       //坐标轴类型\r\n            // name : \'价格\',        设置Y轴的名字\r\n        },\r\n        axisPointer:{     //指示器的相关设置\r\n        \tshow:true,    //默认为false 不显示\r\n        \ttype:\'line\',     //指示器的类型 默认为line\r\n        \tsnap:true,\r\n        \tlabel:{show:true,color:\'#999\'},  //   指示文本的样式设置\r\n        \tlineStyle:{color:\'#000\'},   //线的样式，颜色，阴影，宽度，透明度等\r\n        \tshadowStyle:{},    //axisPointer.type 为 \'shadow\' 时有效。阴影的样式\r\n        \ttriggerTooltip:true,  //  是否触发提示框\r\n        \thandle:{                //拖拽手柄，适用于触屏的环境\r\n        \t\tshow:true,     //默认为false ，不显示\r\n        \t\t// icon:可以通过 \'image://url\' 设置为图片，\r\n        \t\tsize:35, // 手柄的尺寸，默认45可以设置单值，也可以设置为数组：[width, height]。\r\n        \t\tmargin:50,  //手柄与轴的距离。注意，这是手柄中心点和轴的距离。  number 默认为50\r\n        \t\tcolor:\'#999\',    //颜色    默认 \'#333\'\r\n        \t\tthrottle:40,   //手柄拖拽时触发视图更新周期，单位毫秒\r\n        \t\t//还可以设置阴影 模糊程度，偏移程度 颜色\r\n        \t}\r\n        },\r\n    \ttoolbox:{\r\n    \t\tfeature:{\r\n    \t\t\tsaveAsImage:{        //保存为图片。\r\n    \t\t\t\ttype:\'png\',      //保存图片的格式，支持 \'png\' 和 \'jpeg\'。\r\n    \t\t\t\tname:\'测试\',        //保存文件的名字，默认使用主标题\r\n    \t\t\t\t// backgroundColor:\'auto\'   保存的图片背景色，默认使用 backgroundColor，如果backgroundColor不存在的话会取白色。\r\n    \t\t\t\texcludeComponents:[\'toolbox\'] , //保存为图片时忽略的组件列表，默认忽略工具栏。\r\n    \t\t\t\tshow:true,     //是否显示该工具。\r\n    \t\t\t\t// icon:\'image://http://xxx.xxx.xxx/a/b.png\',   设置图标\r\n    \t\t\t\ticonStyle:{color:\'red\'},      //保存为图片 icon 样式设置。   \r\n    \t\t\t\temphasis:{},      //移入设置样式，同toolbox的emphasis\r\n    \t\t\t\tpixelRatio:1,    //保存图片的分辨率比例，默认跟容器相同大小   number\r\n    \t\t\t},\r\n    \t\t\trestore:{          //还原\r\n    \t\t\t\tshow:true,      //是否显示该组件\r\n    \t\t\t\ttitle:\'这是还原\',    //名称\r\n    \t\t\t\t// icon:\'\',      图标设置\r\n    \t\t\t\ticonStyle:{color:\'blue\'},    //图标样式\r\n    \t\t\t\temphasis:{iconStyle:{color:\'red\'}},     //移入显示样式，同上\r\n    \t\t\t},\r\n    \t\t\tdataView:{         //数据视图工具，可以展现当前图表所用的数据，编辑后可以动态更新。\r\n    \t\t\t\tshow:true,    //是否显示该工具      布尔值\r\n    \t\t\t\ttitle:\'数据视图\',    //移入显示的名字   string\r\n    \t\t\t\ticonStyle:{color:\'yellow\'},    //icon emphasis同上\r\n    \t\t\t\treadOnly:false,      //是否不可编辑（只读）。\r\n    \t\t\t\t//optionToContent:fun,    //自定义函数展示数据\r\n    \t\t\t\t//contentToOption:fun,   //如果支持数据编辑后的刷新，需要自行通过该函数实现组装 option 的逻辑\r\n    \t\t\t\tlang:[\'数据视图的\', \'关闭了啊\', \'刷新一哈\'],   //数据视图上有三个话术，默认是[\'数据视图\', \'关闭\', \'刷新\']。\r\n    \t\t\t},\r\n    \t\t\tdataZoom:{        //数据区域缩放。目前只支持直角坐标系的缩放。\r\n\r\n    \t\t\t},\r\n    \t\t\tmagicType:{      //动态类型切换\r\n    \t\t\t\tshow:true,    //是否显示\r\n    \t\t\t\ttype:[\'line\', \'bar\', \'stack\', \'tiled\'],   //启用的动态类型\r\n    \t\t\t\ttitle:{\r\n    \t\t\t\t\tline:\'切换为折线图\',\r\n    \t\t\t\t\tbar:\'切换为柱状图\',\r\n    \t\t\t\t\tstack:\'切换为堆叠\',\r\n    \t\t\t\t\ttiled:\'切换为平铺\',\r\n    \t\t\t\t},\r\n    \t\t\t\ticon:{\r\n    \t\t\t\t\t// line:\'image://http://xxx.xxx.xxx/a/b.png\',   配置各个icon\r\n    \t\t\t\t},\r\n    \t\t\t\ticonStyle:{color:\'pink\'},     //配置icon的样式\r\n    \t\t\t\temphasis:{iconStyle:{}},     //移入样式\r\n    \t\t\t\toption:{line:{}},      //配置每一个的样式\r\n    \t\t\t\tseriesIndex:{line:[]},    //各个类型对应的系列的列表   \r\n    \t\t\t},\r\n    \t\t\tbrush:{\r\n    \t\t\t\t\ttype:[\'rect\',\'polygon\'],\r\n    \t\t\t\t\ticon:{},     //没个按钮的icon\r\n    \t\t\t\t\ttitle:{     //标题文本。\r\n    \t\t\t\t\t\trect:\'矩形选择\',\r\n    \t\t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t},\r\n    \tseries : [\r\n        \t{\r\n            name: \'学生成绩区间\',       //数据项名称\r\n            type: \'line\',      //饼图\r\n            itemStyle:{},     //图形样式\r\n        \tlineStyle:{    //线条的样式\r\n        \t\tcolor:\'red\',   //线的颜色，支持rgba，还可以设置渐变和纹理\r\n        \t\twidth:2,     // number   线宽\r\n        \t\ttype:\'dashed\',  // 线的类型 \'solid\'\\\'dashed\'\\\'dotted\'\r\n        \t\t//还支持阴影的设置\r\n        \t\topacity:0.5,      //t透明度。同css的opacity\r\n        \t},\r\n        \temphasis:{     //高亮状态下提示的样式\r\n        \t\titemStyle:{        //同上面的itemStyle\r\n        \t\t\tcolor:\'blue\',\r\n        \t\t\tborderWidth:5,\r\n        \t\t\t},      \r\n        \t\tlabel:{              //提示文字的设置\r\n        \t\t\tshow:true,\r\n        \t\t\tposition:\'top\',    //也可以设置为数组  [x,y]\r\n        \t\t\toffset:[30, 40],    //是否对文字进行偏移  横向偏移30 向上40\r\n        \t\t\tcolor:\'blue\',     //文字的颜色\r\n        \t\t\tfontSize:20,     //文字的大小\r\n        \t\t}\r\n        \t},   \r\n        \tareaStyle:{     //填充区域的样式\r\n        \t\tcolor:\'#000\',\r\n        \t\topacity:0.5,\r\n        \t},\r\n        \tsmooth:true,    //是否平滑曲线显示\r\n        \tmarkPoint:{   //图表标注\r\n        \t\tsymbol:\'roundRect\',    //标注的图形样式\r\n        \t\tsymbolSize:60,      //标注的大小\r\n        \t\t// symbolRotate: 60 ,   标记的旋转角度\r\n        \t\tsymbolOffset:[20,20],   //标记的偏移位置 也可以写百分比\r\n        \t\tlabel:{show:true},    //标记的文本，同上面的label\r\n        \t\titemStyle:{},   //标注的样式 同上面的itemStyle\r\n        \t\temphasis:{},   //标注的高亮样式 同上面的emphasis\r\n        \t\tdata:[     //标注的数据数组,//值大部分和下面的data一样，只写特殊的\r\n        \t\t\t{\r\n        \t\t\t\t// valueIndex:number,  默认使用第一个数值轴所在的维度\r\n        \t\t\t\t// x:number,   相对容器的屏幕 x 坐标，单位像素\r\n        \t\t\t\t// y:number,   相对容器的屏幕 y 坐标，单位像素\r\n        \t\t\t}\r\n        \t\t],\r\n        \t},  \r\n        \tmarkLine:{     //图表标线。\r\n        \t\t// precision:2,   标线数值的精度，在显示平均值线的时候有用。\r\n        \t\tlabel:{}, //标线的文本,同上面的label\r\n        \t\tlineStyle:{},    //标线的样式\r\n        \t\temphasis:{},    //高亮标线的样式\r\n        \t\tdata:{       //标线的数据数组\r\n        \t\t\t0:{},     //0和1里面的设置同markPoint.data数组中对象的设置\r\n        \t\t\t1:{},  \r\n        \t\t},\r\n        \t},\r\n        \tmarkArea:{   //图表标域，常用于标记图表中某个范围的数据\r\n        \t\tlabel:{},   //标域文本配置。   同上面的label\r\n        \t\titemStyle:{},   //该标域的样式    同上面的itemStyle  \r\n        \t\temphasis:{    //高亮的标域样式 , \t\r\n        \t\t\tlabel:{},   \r\n        \t\t\titemStyle:{},\r\n        \t\t},   \r\n        \t\tdata:{\r\n        \t\t\t0:{},        //同markLine的data\r\n        \t\t\t1:{}\r\n        \t\t}\r\n        \t},\r\n            data:[\r\n                {\r\n                \tvalue:235,\r\n                \tname:\'90-100\',\r\n                \tlabel:{show:true,position:\'inside\',color:\'#000\'},\r\n                \titemStyle:{},    // 同series.itemStyle  单独设置这一项数据的引导线样式\r\n                \temphasis:{itemStyle:{},label:{}},    // 同  单独设置这一项数据的高亮样式\r\n                \ttooltip:{},    //单独设置这一项数据的提示框\r\n                \tsymbol:\'arrow\',   //标记的图形，还可以设置标记的一系列，查看markPoint属性\r\n                },   \r\n                {value:274, name:\'80-90\'},\r\n                {value:310, name:\'70-80\'},\r\n                {value:335, name:\'60-70\'},\r\n                {value:400, name:\'60分以下\'}  \r\n            \t],\r\n        \t}\r\n\t    ]\r\n\t}\r\n```\r\n![折线图](amWiki/images/折线面积图.jpg)\r\n\r\n##### 柱状/条形图     type:\'bar\'\r\n柱状/条形图与折线图很像，都是放在坐标系中展示的\r\n\r\n| 属性 | 描述 | 值|\r\n| ---- | ----| ----|\r\n|coordinateSystem | 该系列使用的坐标系 | string 默认是\'cartesian2d\' 好像也只能是这一个值 |\r\n| xAxisIndex | 使用的 x 轴的 index，在单个图表实例中存在多个 x 轴的时候有用。 | number 默认为0 |\r\n| yAxisIndex | 使用的 y 轴的 index，在单个图表实例中存在多个 y 轴的时候有用。 | number 默认为0|\r\n|barWidth　| 柱条的宽度，不设时自适应。支持设置成相对于类目宽度的百分比。 | number, string 在同一坐标系上，此属性会被多个 \'bar\' 系列共享。应该设置在最后一个bar上面 |\r\n| barMaxWidth | 柱条的最大宽度，不设时自适应。支持设置成相对于类目宽度的百分比。 | 值得解释同上的 barWidth|\r\n| barMinHeight | 柱条最小高度，可用于防止某数据项的值过小而影响交互。 | number |\r\n| barGap | 不同系列的柱间距离 | string 值为百分比 如果想要两个系列的柱子重叠，可以设置 barGap 为 \'-100%\'|\r\n| barCategoryGap | 同一系列的柱间距离 | string 默认为类目间距的20% ，设定情况同barWidth |\r\n| large | 是否开启大数据量优化，在数据图形特别多而出现卡顿时候可以开启。 | 布尔值 默认为false |\r\n| largeThreshold | 开启绘制优化的阈值。 | number 默认值为400 |\r\n| progressive | 渐进式渲染时每一帧绘制图形数量，设为 0 时不启用渐进式渲染，支持每个系列单独配置。| number 默认为5000|\r\n| progressiveThreshold |启用渐进式渲染的图形数量阈值 | number 默认值为3000 |\r\n| progressiveChunkMode | 分片的方式 | 可选值 \'sequential\': 按照数据的顺序分片。缺点是渲染过程不自然。\'mod\': 取模分片，即每个片段中的点会遍布于整个数据，从而能够视觉上均匀得渲染。 |\r\n| dimensions | 定义 series.data 或者 dataset.source 的每个维度的信息 | array |\r\n| encode | 定义 data 的哪个维度被编码成什么。 | object |\r\n| data | 系列中的数据内容数组 | object 包含name、value、label: {...}、itemStyle: {...}、emphasis: {...}、tooltip: |\r\n\r\n柱状图简单案例\r\n```js\r\nvar options={\r\n    title:{\r\n        text:\'学生成绩柱状图\'  ,   //主标题文本，支持使用 \\n 换行。\r\n    },\r\n    legend:{\r\n        data:[\'高中成绩占比\',\'初中成绩占比\']\r\n    },\r\n    grid:{        //直角坐标系内绘图网格\r\n    \tshow:true,\r\n    },\r\n    //X轴设置\r\n    xAxis:{\r\n        data:[\'60分\',\'70分\',\'80分\',\'90分\',{value:\'100分\',textStyle: {\r\n    \t\tfontSize: 20,\r\n    \t\tcolor: \'red\'     \r\n\t\t}}],\r\n        show:true,   //是否显示x轴，默认为true\r\n        position:\'bottom\',   // x轴的位置，默认值为bottom\r\n    \tname:\'成绩\',   //x轴的名字   也可以设置文本样式，通过nameTextStyle\r\n    \tnameGap:0,    //坐标轴名称与轴线之间的距离。 默认为15\r\n    },\r\n    yAxis:{\r\n    \taxisLabel:{       //坐标轴刻度标签的相关设置。\r\n    \t\tshow:true\r\n    \t},\r\n\t\ttype : \'value\',       //坐标轴类型\r\n        name : \'人数\',        //设置Y轴的名字\r\n    },\r\n    //name=legend.data的时候才能显示图例\r\n    series:[{\r\n        name:\'高中成绩占比\',\r\n        type:\'bar\',      // 设置图标类型     柱状图\r\n        coordinateSystem:\'cartesian2d\',   // 该系列使用的坐标系\r\n        label:{    //图形上的文本标签 ,设置同折线图一样\r\n            show:true,\r\n            position:\'top\',   //标签的位置 [10,\'50%\']\r\n            distance:10,      //距离元素的位置\r\n            backgroundColor:\'#ccc\',  //标签的背景颜色\r\n            borderWidth:5,     //标签的边框宽度\r\n            borderColor:\'red\',     //标签的边框颜色\r\n            textBorderColor:\'yellow\',   //文字本身的描边色\r\n            //还可以设置阴影  文字阴影\r\n        },\r\n        itemStyle:{      //图形的样式\r\n            color:\'green\',    //柱子颜色  ，默认在全局调色盘 option.color 获取颜色\r\n            //还可以设置边框、阴影和透明度\r\n        },\r\n        emphasis:{     //高亮的样式\r\n            label:{},\r\n            itemStyle:{color:\'red\'},\r\n        },\r\n        barWidth:50,    //柱子的宽度\r\n        barGap:\'30%\',    //不同系列柱子之间的距离\r\n\r\n        data:[\'12\',\'28\',\'20\',{\r\n            name:\'asd\',\r\n            value:25,\r\n            label:{},     //同外面的series[0].label   设置单个的数据  \r\n            itemStyle:{color:\'blue\'},  //同外面的series[0].itemStyle   设置单个的数据\r\n            emphasis:{     //高亮的样式   设置单个的数据\r\n                label:{},\r\n                itemStyle:{color:\'black\'},\r\n            },\r\n        },\'1\'],\r\n        markPoint:{\r\n            symbol:\'triangle\',\r\n\r\n        }      \r\n    },{\r\n        name:\'初中成绩占比\',\r\n        type:\'bar\',      // 设置图标类型     柱状图\r\n        coordinateSystem:\'cartesian2d\',   // 该系列使用的坐标系\r\n        label:{    //图形上的文本标签 ,设置同折线图一样\r\n            show:true,\r\n            position:\'top\',   //标签的位置 [10,\'50%\']\r\n            distance:10,      //距离元素的位置\r\n            backgroundColor:\'#ccc\',  //标签的背景颜色\r\n            borderWidth:5,     //标签的边框宽度\r\n            borderColor:\'pink\',     //标签的边框颜色\r\n            //textBorderColor:\'yellow\',   //文字本身的描边色\r\n            //还可以设置阴影  文字阴影\r\n        },\r\n        itemStyle:{      //图形的样式\r\n            color:\'pink\',    //柱子颜色  ，默认在全局调色盘 option.color 获取颜色\r\n            //还可以设置边框、阴影和透明度\r\n        },\r\n        emphasis:{     //高亮的样式\r\n            label:{},\r\n            itemStyle:{color:\'red\'},\r\n        },\r\n        barWidth:50,    //柱子的宽度\r\n        barGap:\'30%\',    //不同系列柱子之间的距离\r\n\r\n        data:[\'42\',\'25\',\'15\',{\r\n            name:\'asd\',\r\n            value:35,\r\n            label:{},     //同外面的series[0].label   设置单个的数据  \r\n            itemStyle:{color:\'black\'},  //同外面的series[0].itemStyle   设置单个的数据\r\n            emphasis:{     //高亮的样式   设置单个的数据\r\n                label:{},\r\n                itemStyle:{color:\'orange\'},\r\n            },\r\n        },\'1\'],\r\n        markPoint:{\r\n            symbol:\'triangle\',\r\n\r\n        }      \r\n    }]\r\n\r\n};\r\n```\r\n![柱状图](amWiki/images/柱状图.jpg)\r\n\r\n\r\n##### 仪表盘     type:\'gauge\'\r\n\r\n| 属性 | 描述 | 值 |\r\n|----|----|----|\r\n| radius | 仪表盘半径，可以是相对于容器高宽中较小的一项的一半的百分比，也可以是绝对的数值。| string、number 默认值为\'75%\' |\r\n| startAngle | 仪表盘起始角度 | number 圆心 正右手侧为0度，正上方为90度，正左手侧为180度。|\r\n| endAngle | 仪表盘结束角度 | number 默认值为-45|\r\n|clockwise | 仪表盘刻度是否是顺时针增长 | 布尔值 默认值为true |\r\n| min | 最小的数据值 | number 默认为0 |\r\n| max | 最大的数据值 | number 默认为100 |\r\n|splitNumber | 仪表盘刻度的分割段数 | number 默认为10 |\r\n| axisLine | 仪表盘轴线相关配置 | object 两个属性，show表示是否显示 lineStyle对象表示轴线的样式 |\r\n|  splitLine |分隔线样式 | object 三个属性，show表示是否显示 length表示线长，支持百分比 lineStyle对象表示分割线样式 |\r\n| axisTick | 刻度的样式| object 四个属性 show表示是否显示，length表示线长，splitNumber表示分隔线之间分割的刻度数 lineStyle对象表示刻度线的样式 |\r\n| axisLabel | 刻度标签 | object 该对象的属性与label对象的设置一样 |\r\n|pointer | 仪表盘指针 | Object 该对象有三个值 show表示是否显示，length表示指针的长度，可以设置百分比  width表示指针的宽度 |\r\n| title | 仪表盘标题 | object 主要是设置标题的样式，位置 详细见下面的例子 |\r\n| detail |仪表盘详情，用于显示数据 | object 属性值与title一样 |\r\n\r\n\r\n仪表盘案例\r\n```js\r\nvar options={\r\n\ttitle:{\r\n\t\ttext:\'仪表盘\'\r\n\t},\r\n\tseries:{\r\n\t\ttype:\'gauge\',     //仪表盘\r\n\t\tradius:\'70%\',     //仪表盘半径\r\n\t\tname:\'测试仪表盘\',   //系列名称\r\n\t\t// startAngle:   225 , 仪表盘起始角度\r\n\t\t// endAngle:   -40 , 仪表盘结束角度\r\n\t\tmin:-10,       //最小数据\r\n\t\tmax:255,       //最大数据\r\n\t\tsplitNumber:8,   //仪表盘刻度的分割段数\r\n\t\taxisLine:{     //仪表盘轴线相关配置。\r\n\t\t\tshow:true,\r\n\t\t\tlineStyle:{     //仪表盘轴线样式\r\n\t\t\t\tcolor:[[0.2, \'blue\'], [0.8, \'red\'], [1, \'green\']],    //颜色\r\n\t\t\t}\r\n\t\t},\r\n\t\tsplitLine:{       //分隔线样式\r\n\t\t\tlength:\'50\',     //线长\r\n\t\t\tlineStyle:{     //分隔线样式\r\n\t\t\t\tcolor:\'red\',   //还支持渐变色和纹理填充 ,  注意与轴线颜色设置的区别\r\n\t\t\t\ttype:\'dashed\',   //线的类型\r\n\t\t\t}\r\n\t\t},\r\n\t\taxisTick:{      //刻度样式\r\n\t\t\tlength:5,    //刻度线长，支持半径的百分比\r\n            splitNumber:8, //分隔线之间分割的刻度数 默认为5\r\n\t\t\tlineStyle:{   //刻度线样式  \r\n                color:\'#eee\',   //刻度线颜色\r\n                width:1,    //刻度线宽度\r\n                type:\'solid\', //刻度线类型\r\n                //还支持设置阴影的模糊程度、颜色、偏移度    透明度\r\n            }  \r\n\t\t},\r\n        axisLabel:{},    //刻度标签,同label对象的设置\r\n\t\tpointer:{         //仪表盘指针\r\n\t\t\tshow:true,\r\n\t\t\tlength:\'80%\',    //仪表盘指针长度\r\n            width:8\r\n\t\t},  \r\n\t\titemStyle:{    //指针样式\r\n            color:\'#000\',\r\n            //还支持边框、阴影和透明度的设置\r\n        },\r\n        emphasis:{       //高亮的样式设置\r\n            itemStyle:{color:\'red\',}\r\n        },\r\n\t\ttitle:{      //仪表盘标题\r\n\t\t\tshow:true,     //默认为true\r\n            offsetCenter:[0,\'-20%\'],   //数组第一项是水平方向的偏移，第二项是垂直方向的偏移。可以是绝对的数值，也可以是相对于仪表盘半径的百分比\r\n            //还可以设置文字的样式，边框 宽高 描边 阴影 内边距\r\n\t\t},\r\n        detail:{         //属性的设置同title\r\n            color:\'yellow\',\r\n        },\r\n\t\tdata: [{value: 50, name: \'完成量\'}],\r\n        tooltip:{}   //查看tooltip组件的设置\r\n\t}\r\n}\r\n```\r\n![仪表盘](amWiki/images/仪表盘.jpg)\r\n\r\n##### 雷达图 type:\'radar\'  \r\n>雷达图主要用于表现多变量的数据，例如球员的各个属性分析。依赖 radar 组件。\r\n\r\n| 属性| 描述 | 值|\r\n|---- | ----| ---- |\r\n| radarIndex | 雷达图所使用的 radar 组件的 index | number |\r\n|symbol | 标记的图形 | ECharts 提供的标记类型包括 \'circle\', \'rect\', \'roundRect\', \'triangle\', \'diamond\', \'pin\', \'arrow\', \'none\' ，也可以自己引入图片 |\r\n| symbolSize | 标记的大小 | number、array [20,10]表示宽20，高10 |\r\n| symbolRotate | 标记的旋转角度 | number |\r\n| symbolKeepAspect | 如果 symbol 是 path:// 的形式，是否在缩放时保持该图形的长宽比 |布尔值 默认为false |\r\n| symbolOffset | 标记相对于原本位置的偏移。默认情况下，标记会居中置放在数据对应的位置 |array [0,\'20%\'] |\r\n| areaStyle | 区域填充的样式 | object 属性 color表示填充色 opacity表示透明度， 还可以设置阴影 |\r\n| emphasis | 高亮的样式设置  | object 里面包含itemStyle、label、lineStyle、areaStyle这四个对象 |\r\n| data | 雷达图的数据是多变量的 | 数组，详细介绍结合下面的雷达图案例 |\r\n\r\n#### radar 雷达图坐标系组件，只适用于雷达图\r\n>该组件等同 ECharts 2 中的 polar 组件。因为 3 中的 polar 被重构为标准的极坐标组件，为避免混淆，雷达图使用 radar 组件作为其坐标系。\r\n\r\n| 属性 | 描述 | 值 |\r\n| ---- | ---- | ---- |\r\n| id | 默认不指定。指定则可用于在 option 或者 API 中引用组件 | string |\r\n| zlevel、z | 用于组件的层级 | number |\r\n| center | 中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标| array [400,\'50%\'] |\r\n|radius | 组件的半径 | number, string, Array [内半径,外半径] |\r\n| startAngle | 坐标系起始角度，也就是第一个指示器轴的角度 | number |\r\n| name | 雷达图每个指示器名称的配置项 | object 可以设置文字的样式、边框、背景色、阴影、宽高、描边|\r\n| nameGap | 指示器名称和指示器轴的距离 | number 默认值为15 |\r\n| splitNumber | 指示器轴的分割段数 | number 默认值为5|\r\n| shape | 雷达图绘制类型 | string 支持 \'polygon\' 和 \'circle\' |\r\n| scale | 是否是脱离 0 值比例 | 布尔值 默认为false |\r\n| silent | 坐标轴是否是静态无法交互 | 布尔值 默认为false |\r\n| triggerEvent | 坐标轴的标签是否响应和触发鼠标事件 | 布尔值，默认为false |\r\n| axisLine | 坐标轴轴线相关设置 | object 同坐标轴中的同名属性  |\r\n| splitLine | 坐标轴在 grid 区域中的分隔线 | object 包含两个属性，show表示是否显示，lineStyle对象用来设置分割线的样式 |\r\n| splitArea | 坐标轴在 grid 区域中的分隔区域| object 包含两个属性，show表示是否显示，默认不现实，areaStyle对象设置分隔区域的样式，主要包括color、阴影和透明度|\r\n| indicator | 雷达图的指示器，用来指定雷达图中的多个变量（维度） | array，详细介绍结合下面的雷达图案例 |\r\n\r\n雷达图案例\r\n```js\r\nvar options={\r\n    title: {\r\n        text: \'雷达图\'\r\n  },\r\n  legend: {           //图例组件\r\n      data: [\'预算分配\', {\r\n        name:\'实际开销\',\r\n        icon:\'circle\',      //设置该图例组件为圆形，样式还有很多，也可以设置图片\r\n      }],\r\n      bottom:0  ,      //设置组件距离容器下方的距离，值可以为字符串\'20%\',还有left，right，top\r\n      right:0,\r\n      orient:\'vertical\',      //图例列表的布局朝向。\r\n      textStyle:{},       //图例的公用文本样式。\r\n  },\r\n  radar: {            //雷达图坐标系组件，只适用于雷达图\r\n      shape: \'circle\',     //雷达图绘制类型 圆形 默认为polygon是方形的\r\n      center:[\'50%\', \'50%\'],\r\n      radius:[\'30%\',\'75%\'],     //设置雷达图的半径，值可以为number、string、array，数组的话第一个值为内半径，第二个是外半径\r\n      startAngle:90,    //起始角度\r\n      splitNumber:10,            //指示器轴的分割段数\r\n      name: {\r\n          textStyle: {\r\n              color: \'#fff\',                  //文字的颜色\r\n              backgroundColor: \'#999\',     //文字块背景色\r\n              borderRadius: 3,         //文字块的圆角\r\n              padding: [3, 5]         //文字块的内边距，与css写法一样\r\n         }\r\n      },\r\n      nameGap:20,   //指示器名称与指示器的距离   默认为15，   number\r\n      shape:\'circle\',   //雷达图绘制类型\r\n      axisLine:{           //坐标轴轴线相关设置\r\n           symbol:\'arrow\' ,    //轴线两边的箭头。可以是字符串，表示两端使用同样的箭头；或者长度为 2 的字符串数组，分别表示两端的箭头。默认不显示箭头，两端都显示箭头可以设置为 \'arrow\'，只在末端显示箭头可以设置为 [\'none\', \'arrow\']。\r\n           symbolSize:[10,15],  //轴线两边的箭头的大小，第一个数字表示宽度，第二个数字表示高度\r\n           symbolOffset:[0,0],  //轴线两边的箭头的偏移  可以是number\r\n           lineStyle:{},      //轴线的样式    颜色，宽度、透明度、阴影\r\n      },\r\n      splitLine:{        //坐标轴在 grid 区域中的分隔线\r\n            show:true,\r\n            lineStyle:{},    //分隔线的样式    颜色，宽度、透明度、阴影\r\n      },\r\n      splitArea:{        //坐标轴在 grid 区域中的分隔区域默认不显示\r\n            show:true,\r\n            areaStyle:{  //分隔区域的样式\r\n                color:[\'rgba(50,50,50,0.5)\',\'rgba(200,200,200,0.3)\'],\r\n                //还可以设置阴影和透明度\r\n            }\r\n      },\r\n      indicator: [                  //用来指定雷达图中的多个变量（维度）\r\n         { name: \'销售（sales）\', max: 6500},\r\n         { name: \'管理（Administration）\', max: 16000,color: \'red\'},   //color设置文字颜色\r\n         { name: \'信息技术（Information Techology）\', max: 30000},\r\n         { name: \'客服（Customer Support）\', max: 38000},\r\n         { name: \'研发（Development）\', max: 52000},\r\n         { name: \'市场（Marketing）\', max: 25000}\r\n      ]\r\n  },\r\n  series: [{\r\n      name: \'预算 vs 开销（Budget vs spending）\',\r\n      type: \'radar\',            //雷达图\r\n      symbol:\'rect\',     //标记\r\n      symbolSize:6,    //标记的大小，用数组分开表示宽和高，也可以用函数\r\n      symbolRotate:80,  //标记的旋转角度\r\n      label:{},    //图形上的文本标签\r\n      itemStyle:{},    //拐点的样式\r\n      lineStyle:{},   //线条的样式\r\n      areaStyle:{},   //填充区域的样式\r\n      emphasis:{       //高亮样式\r\n            label:{show:true},    //高亮图形上的文本标签\r\n            itemStyle:{},    //高亮拐点的样式\r\n            lineStyle:{},   //高亮线条的样式\r\n            areaStyle:{},   //高亮填充区域的样式\r\n      },\r\n      data : [\r\n          {\r\n              value : [4300, 10000, 28000, 35000, 50000, 19000],\r\n              name : \'预算分配\',\r\n              symbol:\'circle\',   //同上面的symbol\r\n              symbolSize:8,\r\n              symbolRotate:80,\r\n              label:{},    //单个图形上的文本标签\r\n              itemStyle:{},    //单个拐点的样式\r\n              lineStyle:{},   //单个线条的样式\r\n              areaStyle:{},   //单个填充区域的样式\r\n              emphasis:{       //单个高亮样式\r\n                    label:{show:true},    //单个高亮图形上的文本标签\r\n                    itemStyle:{},    //单个高亮拐点的样式\r\n                    lineStyle:{},   //单个高亮线条的样式\r\n                    areaStyle:{},   //单个高亮填充区域的样式\r\n              },\r\n          },\r\n           {\r\n              value : [5000, 14000, 28000, 31000, 42000, 21000],\r\n              name : \'实际开销\'\r\n          }\r\n      ]\r\n  }]\r\n}\r\n```\r\n![雷达图](amWiki/images/雷达图.jpg)\r\n\r\n#### geo 地理坐标系组件\r\n| 属性 | 描述 | 值|\r\n|---- | ---- | ---- |\r\n|id| 组件 ID。默认不指定。指定则可用于在 option 或者 API 中引用组件 | string|\r\n| show | 是否显示该组件 | 布尔值 默认为true |\r\n| map | 地图类型 | string 下面有详细介绍如何使用该属性 |\r\n| roam | 是否开启鼠标缩放和平移漫游 | 默认不开启。如果只想要开启缩放或者平移，可以设置成 \'scale\' 或者 \'move\'。设置成 true 为都开启|\r\n| center | 当前视角的中心点，用经纬度表示 | array [115.97, 29.71] |\r\n| aspectScale | 用于 scale 地图的长宽比 | number 默认值为0.75|\r\n| boundingCoords |定义定位的左上角以及右下角分别所对应的经纬度 | 二维数组 [// 定位左上角经纬度[-180, 90],// 定位右下角经纬度[180, -90]]|\r\n| zoom | 当前视角的缩放比例 | number 默认值为1 |\r\n| scaleLimit | 滚轮缩放的极限控制 | object 两个属性，min表示最小的缩放值，max表示最大的缩放值 |\r\n| nameMap| 自定义地区的名称映射 |object {\'China\' : \'中国\'}|\r\n| selectedMode | 选中模式，表示是否支持多个选中 | 默认关闭，支持布尔值和字符串，字符串取值可选\'single\'表示单选，或者\'multiple\'表示多选。 |\r\n| label | 图形上的文本标签，可用于说明图形的一些数据信息 | object 具体设置查看上面的代码 |\r\n| itemStyle | 地图区域的多边形 图形样式 | object 主要就是设置颜色、区域颜色、边框、阴影、透明度具体查看下面的地图案例 |\r\n| emphasis | 高亮状态下的多边形和标签样式 | object 包含两个对象 label和itemStyle |\r\n| zlevel、z | 设置组件的层级 | number |\r\n| top、bottom、left、right | 设置组件距离容器的位置 | 值得设置同上面组件的解释 |\r\n| regions| 在地图中对特定的区域配置样式| array 结合下面的地图案例去学习 |\r\n|silent | 图形是否不响应和触发鼠标事件 | 布尔值 默认为false即响应和触发鼠标事件 |\r\n| layoutSize |地图的大小|number, string 支持相对于屏幕宽高的百分比或者绝对的像素大小 |\r\n| layoutCenter | 设置地图的位置，使用后left、top等四个值和宽高无效 | array [\'30%\', \'30%\'] |\r\n\r\n\r\nECharts 3不再内置地图数据增大代码体积，可以下载需要的地图文件引入并注册到 ECharts 中。ECharts 中提供了两种格式的地图数据，一种是可以直接 script 标签引入的 js 文件，引入后会自动注册地图名字和数据。还有一种是 JSON 文件，需要通过 AJAX 异步加载后手动注册。\r\n* JavaScript 引入示例\r\n```html\r\n<div id=\"chinaMap\" style=\"width:500px;height:500px;\"></div>\r\n<script src=\"echarts.js\"></script>\r\n<script src=\"china.js\"></script>\r\n<script>\r\nvar chart = echarts.init(document.getElementById(\'chinaMap\'));\r\nchart.setOption({\r\n    series: [{\r\n        type: \'map\',\r\n        map: \'china\'\r\n    }]\r\n});\r\n</script>\r\n```\r\n* JSON 引入示例\r\n```js\r\n$.get(\'map/json/china.json\', function (chinaJson) {\r\n    echarts.registerMap(\'china\', chinaJson);\r\n    var chart = echarts.init(document.getElementById(\'main\'));\r\n    chart.setOption({\r\n        series: [{\r\n            type: \'map\',\r\n            map: \'china\'\r\n        }]\r\n    });\r\n});\r\n```\r\ngeo组件中国地图案例\r\n```js\r\nvar options={\r\n    title:{\r\n        text:\'地图测试\'\r\n    },\r\n    geo:{\r\n        map:\'china\',    //地图类型\r\n        roam:true,      //是否开启鼠标缩放和平移漫游,也可以单独开启\r\n        center:[] ,      //当前视角的中心点，用经纬度表示\r\n        aspectScale:0.75,   //地图的长宽比、\r\n        // boundingCoords:[\r\n        //     // [-180, 90],     定位左上角经纬度\r\n        //     // [180, -90]    定位右下角经纬度\r\n        // ],\r\n        zoom:1,       //当前视角的缩放比例\r\n        nameMap:{\r\n            \'China\' : \'中国\'\r\n        },\r\n        selectedMode:true,   //选中模式，表示是否支持多个选中，默认关闭\r\n        label:{\r\n            show:true,   //是否显示标签。默认为false\r\n            //还可以设置标签的颜色、文字样式、位置、边框、阴影、描边、背景颜色、宽高\r\n        },\r\n        itemStyle:{   // 图形样式\r\n            areaColor:\'red\',  //地图区域的颜色。\r\n            color:\'blue\',\r\n            //还可以设置边框、阴影、和透明度\r\n        },      \r\n        emphasis:{        //高亮状态下的多边形和标签样式。\r\n            label:{},\r\n            itemStyle:{\r\n                areaColor:\'blue\',  //地图区域的颜色。\r\n                color:\'blue\',\r\n            }\r\n        },\r\n        top:0,         //组件离容器上侧的距离     能设置上下左右，值可以是字符串\'20%\'\r\n        regions:[{\r\n            name:\'新疆\',\r\n            selected:true,\r\n            label:{},\r\n            itemStyle:{           //该区域的多边形样式设置\r\n                areaColor:\'black\'       //设置该区域的颜色\r\n            },   \r\n            emphasis:{         //高亮的样式\r\n                itemStyle:{areaColor:\'pink\'},\r\n                lable:{}\r\n            }\r\n        },\r\n        {\r\n            name:\'西藏\',\r\n            selected:true,\r\n            label:{},\r\n            itemStyle:{           //该区域的多边形样式设置\r\n                areaColor:\'black\'       //设置该区域的颜色\r\n            },   \r\n            emphasis:{\r\n                itemStyle:{areaColor:\'pink\'},\r\n                lable:{}\r\n            }\r\n        }],\r\n        layoutSize:\'20%\',   //设置地图的大小\r\n        silent:false    //图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。\r\n    },\r\n}\r\n```\r\n\r\n踩过的坑：     \r\n在使用中国地图时，移入显示省份名称，显示的位置不在省份的中间，这是因为省份名称是显示在省会的坐标那里，而有的省会在省份的边缘，解决这种问题需要在你的china.js文件中找到省份，然后改掉对应的坐标，比如：`{\"cp\":[113.665412,34.757975],\"name\":\"河南\",\"childNum\":1}`   [113.665412,34.757975]是河南省会郑州的地理坐标，改变这个坐标就改变了省份名称显示的地方\r\n\r\n![地图](amWiki/images/地图.jpg)\r\n\r\n\r\n#### 富文本标签\r\n在许多地方（如图、轴的标签等）都可以使用富文本标签                  \r\n功能：             \r\n* 能够定制文本块整体的样式（如背景、边框、阴影等）、位置、旋转等。\r\n* 能够对文本块中个别片段定义样式（如颜色、字体、高宽、背景、阴影等）、对齐方式等。\r\n* 能够在文本中使用图片做小图标或者背景。\r\n* 特定组合以上的规则，可以做出简单表格、分割线等效果。\r\n\r\n```js\r\nvar options = {\r\n    title: {text: \'天气情况统计\', left: \'center\'},\r\n    series:[{\r\n            type: \'pie\',\r\n            radius : \'65%\',\r\n            center: [\'50%\', \'50%\'],\r\n            selectedMode: \'single\',\r\n            data:[{\r\n                    value:1548,\r\n                    name: \'幽州\',\r\n                    label: {\r\n                        normal: {\r\n                            formatter: [\r\n                                \'{title|{b}}{abg|}\',\r\n                                \'{valueHead|天数}{rateHead|占比}\',\r\n                                \'{hr|}\',\r\n                                \'{value|202}{rate|55.3%}\',\r\n                                \'{value|142}{rate|38.9%}\',\r\n                                \'{value|21}{rate|5.8%}\'\r\n                            ].join(\'\\n\'),\r\n                            backgroundColor: \'#eee\',\r\n                            borderColor: \'#777\',\r\n                            borderWidth: 1,\r\n                            borderRadius: 4,\r\n                            rich: {\r\n                                title: {\r\n                                    color: \'#eee\',\r\n                                    align: \'center\'\r\n                                },\r\n                                abg: {\r\n                                    backgroundColor: \'#333\',\r\n                                    width: \'100%\',\r\n                                    align: \'right\',\r\n                                    height: 30,\r\n                                    borderRadius: [4, 4, 0, 0]\r\n                                },\r\n                                hr: {\r\n                                    borderColor: \'#777\',\r\n                                    width: \'100%\',\r\n                                    borderWidth: 0.5,\r\n                                    height: 0\r\n                                },\r\n                                value: {\r\n                                    width: 30,\r\n                                    height:30,\r\n                                    padding: [0, 20, 0, 30],\r\n                                    align: \'left\'\r\n                                },\r\n                                valueHead: {\r\n                                    color: \'#333\',\r\n                                    width: 40,\r\n                                    height:30,\r\n                                    padding: [0, 20, 0, 20],\r\n                                    align: \'center\'\r\n                                },\r\n                                rate: {\r\n                                    width: 40,\r\n                                    height:30,\r\n                                    align: \'right\',\r\n                                    padding: [0, 10, 0, 0]\r\n                                },\r\n                                rateHead: {\r\n                                    color: \'#333\',\r\n                                    width: 40,\r\n                                    height:30,\r\n                                    align: \'center\',\r\n                                    padding: [0, 10, 0, 0]\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                {value:535, name: \'荆州\'},\r\n                {value:510, name: \'兖州\'},\r\n            ],\r\n\r\n        }\r\n    ]\r\n};\r\n```\r\n![富文本应用](amWiki/images/富文本.jpg)\r\n","timestamp":1585877701769},{"name":"05-ECharts的API.md","path":"001-前端/08-JavaScript/007-插件、库/03-数据可视化/05-ECharts的API.md","content":"# ECharts的API\r\n\r\n| API | 描述 |\r\n| ---- | ---- |\r\n| echarts | 全局 echarts 对象，在 script 标签引入 echarts.js 文件后获得|\r\n| echartsInstance | 通过 echarts.init 创建的实例 |\r\n| action | ECharts 中支持的图表行为,通过 dispatchAction 触发，一些数据可视化的行为设置例如高亮、tooltip位置设置 |\r\n| events | 所有 ECharts 的事件列表。 |\r\n\r\n\r\n### echarts对象上的主要方法\r\n1. init：创建一个 ECharts 实例，返回 echartsInstance，参数有多个，主要参数也是第一个参数传入一个DOM元素，其余请查看官方文档，其他参数主要的作用是设置应用的主题、设备的像素比、渲染器(支持 \'canvas\' 或者 \'svg\')，实例的宽高\r\n2. connect：多个图表实例实现联动。参数是 group 的 id，或者图表实例的数组。\r\n3. disconnect：解除图表实例的联动，如果只需要移除单个实例，可以将通过将该图表实例 group 设为空。参数是group 的 id。\r\n4. dispose：销毁实例，实例销毁后无法再被使用。\r\n5. getInstanceByDom：获取 dom 容器上的实例。\r\n6. registerMap：注册可用的地图，必须在包括 geo 组件或者 map 图表类型的时候才能使用。\r\n7. getMap：获取已注册的地图，返回的对象类型如下\r\n```js\r\n{\r\n    // 地图的 geoJson 数据\r\n    geoJson: Object,\r\n    // 地图的特殊区域，见 registerMap\r\n    specialAreas: Object\r\n}\r\n```\r\n8. registerTheme：注册主题，用于初始化实例的时候指定。\r\n\r\n### echartsInstance对象\r\n1. group：图表的分组，用于联动    值为string或者number\r\n2. setOption：设置图表实例的配置项以及数据，万能接口，所有参数和数据的修改都可以通过setOption完成，ECharts 会合并新的参数和数据，然后刷新图表。 参数：\r\n    * option：图表的配置项和数据\r\n    * notMerge：可选，是否不跟之前设置的option进行合并，默认为false，即合并\r\n    * lazyUpdate：可选，在设置完option后是否不立即更新图表，默认为false，即立即更新\r\n    * silent：可选，阻止调用 setOption 时抛出事件，默认为false，即抛出事件\r\n3. getWidth、getHeight、getDom、getOption：这四个方法是用来获取\r\n4. dispatchAction：触发图表行为，例如图例开关legendToggleSelect, 数据区域缩放dataZoom，显示提示框showTip等等\r\n5. on：绑定事件处理函数。\r\n6. off：解绑事件处理函数。\r\n7. appendData：此接口用于，在大数据量（百万以上）的渲染场景，分片加载数据和增量渲染\r\n8. clear：清空当前实例，会移除实例中所有的组件和图表。\r\n9. dispose：销毁实例，销毁后实例无法再被使用。\r\n\r\n### action\r\n1. legend对象：图例组件相关的行为，必须引入图例组件后才能使用\r\n2. tooltip对象：提示框组件相关的行为，必须引入提示框组件后才能使用。\r\n3. dataZoom对象：数据区域缩放组件相关的行为，必须引入数据区域缩放组件后才能使用。\r\n4. timeline对象：时间轴组件相关的行为，必须引入时间轴组件后才能使用。\r\n5. pie、geo、map、graph：这些对象分别是饼图、地图组件、地图图标、关系图的相关的行为，需要引入相关的组件才能使用\r\n\r\n```js\r\necharts:{         //一个全局对象，引入echarts.js后获得\r\n    init()        //初始化实例，注意单个容器不能初始化多个实例\r\n    connect()      //多个图表实例实现联动\r\n    disconnect()     //解除图表之间的联动，如果只需要移除单个实例，可以将通过将该图表实例  group 设为空\r\n    dispose()     //销毁实例，销毁后无法再使用\r\n    getInstanceByDom()     //获取DOM上的实例\r\n    registerMap()     //注册可用的地图，必须在包括 geo 组件或者 map 图\t\t\t\t\t表类型的时候才能使用。\r\n    getMap()     //获取已注册的地图\r\n    registerTheme     //注册主题，初始化时使用\r\n},\r\nechartsInstance:{},   //通过echarts.init创建的实例可以获得实例的各种\t\t\t\t\t\t\t属性\r\naction:{},   //echarts中支持的图表的行为包括legend:{},tooltip:{}等\r\nevents:{}   //echarts中包含的事件\r\n```\r\n\r\n\r\n\r\n#### 异步数据的加载和更新\r\n1. Echarts中实现异步只需要jquery中的工具异步获取数据后通过setOption填入数据和配置即可\r\n```js\r\nvar mychart=echarts.init(document.getElementById(‘main’));\r\n$.get(‘data.json’).done(function(data){\r\n    mychart.setOption({\r\n        title:{},\r\n        tooltip:{},\r\n        legend:{},\r\n        xAxis:{},\r\n        yAxis:{},\r\n        series:[{\r\n          data:data\r\n        }]\r\n    })\r\n})\r\n```\r\n2. 还可以先设置一个空的坐标轴，然后再异步获取数据同样通过setOption载入，如果加载数据时间很长可以在获取数据的这段时间加上一个loading动画。只需调用showLoading ()方法就可以实现，数据加载完成后再用hideLoading()方法隐藏 。\r\n```js\r\nmyChart.showLoading();\r\n\t$.get(\'data.json\').done(function (data) {\r\n   \t myChart.hideLoading();\r\n   \t myChart.setOption(...);});\r\n```\r\n3. 数据的动态更新            \r\n所有数据的更新都通过 setOption实现，只需要定时获取数据，setOption 填入数据，而不用考虑数据到底产生了那些变化，ECharts 会找到两组数据之间的差异然后通过合适的动画去表现数据的变化。                  \r\n一般地，是通过定时器定时获取数据并更新到页面\r\n\r\n#### echarts.js响应式实现\r\n在浏览器窗口变化时调用Echarts提供的resize方法，详见 http://echarts.baidu.com/api.html#echartsInstance.resize ，该方法的描述是：改变图表尺寸，在容器大小发生改变时需要手动调用。当然需要外部容器也是自适应的。\r\n\r\n#### 事件和行为\r\nEcharts中所涉及的事件包含两种，一种是鼠标点击事件，或者hover时触发的事件；另一种是用户在使用可交互组件后触发的行为事件。\r\n1. 所有的鼠标事件都包含参数params，这是一个包含点击图形的数据信息的对象。可以在回调函数中获取这个对象中的函数名、系列名称等。\r\n```js\r\nmyChart.on(\'click\', function (parmas) {\r\n     $.get(\'detail?q=\' + params.name, function (detail) {\r\n        myChart.setOption({\r\n            series: [{\r\n                name: \'pie\',\r\n                // 通过饼图表现单个柱子中的数据分布\r\n                data: [detail.data]\r\n            }]\r\n        });\r\n    });});\r\n```\r\n2. 组件交互的行为事件             \r\n交互组件都会触发事件其中的事件种类都在events文档中有列出。用法一样用on.\r\n\r\n\r\n\r\n\r\n\r\n#### 微信小程序中使用 ECharts\r\n由于微信小程序是不支持 DOM 操作的，Canvas 接口也和浏览器不尽相同，所以百度团队和小程序团队合作给我们提供了Echarts的微信小程序版本，熟悉ECharts的配置你就能很快在微信小程序中使用ECharts            \r\n\r\n1. 下载\r\n下载 GitHub 上的项目： https://github.com/ecomfe/echarts-for-weixin            \r\n这个项目其实就是一个小程序的项目，你可以只在用小程序的编辑器运行测试(需要将 project.config.json 中的 appid 替换成在公众平台申请的项目 id)，其中克隆的文件中的ec-canvas文件就是ECharts提供给小程序的组件，项目中同时也提供了很多使用这个组件的例子。              \r\nec-canvas 目录下有一个 echarts.js，默认ECharts会在每次 echarts-for-weixin 项目发版的时候替换成最新版的 ECharts。如有必要，可以自行从 ECharts 项目中下载最新发布版，或者从官网自定义构建以减小文件大小。下载的文件放在 ec-canvas/echarts.js，注意一定需要重命名为 echarts.js。            \r\n\r\n2. 使用\r\n将ec-canvas文件放置在你的小程序中适当的位置，然后在你使用ECharts的页面json进行配置，允许使用组件 ec-canvas ;\r\n```js\r\n{\r\n  \"usingComponents\":{\r\n    \"ec-canvas\":\"../../ec-canvas/ec-canvas\"       //这里写的是你放置ec-canvas文件的位置\r\n  }\r\n}\r\n```\r\nwxml文件中使用组ec-canvas组件\r\n```\r\n<view class=\"container\">\r\n  <ec-canvas id=\"mychart-dom-bar\" canvas-id=\"mychart-bar\" ec=\"{{ ec }}\"></ec-canvas>\r\n</view>\r\n```\r\n其中 ec 是一个我们在 index.js 中定义的对象，它使得图表能够在页面加载后被初始化并设置。         \r\n页面中js文件的配置如下\r\n```js\r\nfunction initChart(canvas, width, height) {\r\n  const chart = echarts.init(canvas, null, {\r\n    width: width,\r\n    height: height\r\n  });\r\n  canvas.setChart(chart);\r\n\r\n  var option = {\r\n    ...\r\n  };\r\n  chart.setOption(option);\r\n  return chart;\r\n}\r\nPage({\r\n  data: {\r\n    ec: {\r\n      onInit: initChart\r\n    }\r\n  }\r\n});\r\n```\r\n这对于所有 ECharts 图表都是通用的，只需要修改上面 option 的内容，即可改变图表。\r\n","timestamp":1585877701769},{"name":"08-杂.md","path":"001-前端/08-JavaScript/007-插件、库/03-数据可视化/08-杂.md","content":"\r\n## Highcharts\r\nHighcharts 非商业免费，商业需授权，代码开源。    \r\nHighcharts 基于SVG，方便自己定制，但图表类型有限。         \r\nHighcharts 兼容 IE6 及以上的所有主流浏览器，完美支持移动端缩放、手势操作。\r\n\r\n### 组成\r\nHighcharts 系列软件包含 Highcharts JS，Highstock JS，Highmaps JS 共三款软件       \r\n* Highchartsa：基本图表 其主要包含直线图、曲线图、区域图、柱状图、饼状图、散状点图、仪表图、气泡图、瀑布流图等20多种图表。\r\n* Highstock：股票图表控件 包含多个高级导航组件（预设置数据时间范围，日期选择器、滚动条、平移、缩放功能）\r\n* Highmaps：优秀地图组件 它可以方便快捷的创建用于展现销售、选举结果等其他与地理位置关系密切的交互性地图图表。\r\n\r\n### 使用\r\n* 下载使用： https://www.highcharts.com/blog/download/        \r\n* 直接引入CDN文件： `<script src=\"http://cdn.hcharts.cn/highcharts/highcharts.js\"></script>`\r\n\r\n使用方式与echarts很像：     \r\n1. 创建容器并指定大小供后续操作\r\n2. 通过highcharts.chart函数来创建图表，highcharts.chart函数有两个参数 第一个参数是容器的id，第二个则是图表配置信息。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <title>Test</title>\r\n</head>\r\n<script src=\"http://cdn.hcharts.cn/highcharts/highcharts.js\"></script>\r\n<body>\r\n<div id=\"container\" style=\"width:400px;height:400px\"></div>\r\n\r\n<script type=\"text/javascript\">\r\n// 图表配置\r\nvar options={\r\n    //去除生成后的图表水印链接,否则默认会在图标的右下角添加highcharts网站的水印\r\n     credits: { enabled: false },\r\n    chart:{\r\n        type:\"bar\"  //指定图表的类型，默认是折线图（line）\r\n    },\r\n     title: {\r\n                text: \'我的第一个图表\'                 // 标题\r\n            },\r\n            xAxis: {\r\n                categories: [\'苹果\', \'香蕉\', \'橙子\']   // x 轴分类\r\n            },\r\n            yAxis: {\r\n                title: {\r\n                    text: \'吃水果个数\'                // y 轴标题\r\n                }\r\n            },\r\n            series: [{                              // 数据列\r\n                name: \'小明\',                        // 数据列名\r\n                data: [1, 0, 4]                     // 数据\r\n            }, {\r\n                name: \'小红\',\r\n                data: [5, 7, 3]\r\n            }]\r\n};\r\nvar chart=Highcharts.chart(\"container\",options);\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n## D3\r\nD3 完全免费，代码开源。       \r\nD3.v3 基于SVG，方便自己定制；D3.v4支持Canvas+SVG，如果计算比较密集，也可以选择用Canvas。除此之外，D3图表类型非常丰富，几乎可以满足所有开发需求，但代码相对于以上两个插件来说，会稍微难一点。    \r\nD3 兼容IE9 及以上的所有主流浏览器，对于移动端的兼容性也同上。         \r\n\r\n### 安装使用\r\n下载使用：https://github.com/d3/d3       \r\n直接引入：`<script src=\"https://cdn.bootcss.com/d3/5.7.0/d3.js\"></script>`  \r\n","timestamp":1585877701769},{"name":"008-跨域资源共享 CORS.md","path":"001-前端/08-JavaScript/008-跨域资源共享 CORS.md","content":"## 现象\r\n在前端发送某些请求时，通过`Network`查看会发现其重复了两次请求，其中多了一个为`optiong`的请求。\r\n\r\n## 原因\r\n当进行跨域请求时，`跨域资源共享(CORS)` 机制引发浏览器会首先使用 `OPTIONS` 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。\r\n\r\nCORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。\r\n\r\n因此查看网络请求会发现有两次请求，一次为`Option`，一次为正常请求。\r\n\r\n\r\n## 跨域资源共享 CORS \r\n\r\n### CORS介绍\r\nCORS (Cross-origin resource sharing) 是一种机制，它使用额外的 HTTP 头来告诉浏览器，让Web应用被准许访问来自不同源服务器上的指定的资源。\r\n\r\n当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求，出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，**除非响应报文包含了正确CORS响应头**。\r\n\r\n跨域资源共享（ CORS ）机制允许Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。\r\n\r\n\r\n### CORS实现原理\r\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\r\n\r\n整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会**自动**添加一些附加的头信息，**有时还会多出一次附加的请求**，但用户不会有感觉。\r\n\r\n因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\r\n\r\n\r\n### CORS运行规则\r\n\r\n根据发送请求的请求方法和头信息可以将请求分为`简单请求（simple request）`和`预检请求（not-so-simple request）`\r\n\r\n同时符合以下规则即为简单请求：\r\n\r\n1. 使用下列方法之一：\r\n    * GET\r\n    * POST\r\n    * HEAD\r\n2. 头信息只包含以下字段，不能包含自定字段\r\n    * Accept\r\n    * Accept-Language\r\n    * Content-Language\r\n    * Content-Type : 仅限 `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`\r\n    * DPR\r\n    * Downlink\r\n    * Save-Data\r\n    * Viewport-Width\r\n    * Width\r\n\r\n\r\n#### 简单请求\r\n简单请求会自动在**请求头**中添加`Origin`字段，用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\r\n\r\n请求头：\r\n```\r\nHost: 192.168.20.78:8080\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nAccess-Control-Request-Method: POST\r\nOrigin: http://localhost:3000      \r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 Edg/80.0.361.69\r\nReferer: http://localhost:3000/dungang\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n```\r\n\r\n响应头：\r\n```\r\nAccess-Control-Allow-Origin: *\r\nContent-Length: 0\r\nContent-Type: application/json\r\nDate: Mon, 23 Mar 2020 06:07:11 GMT\r\nServer: WSGIServer/0.2 CPython/3.6.5\r\n```\r\n\r\n\r\n以上请求为例，请求头中的`Origin`表明请求源是`http://localhost:3000`，响应头中`Access-Control-Allow-Origin: *`表示该资源可以被**任意**外域访问。如果服务端需要限制固定网址访问，可以将该字段改为：\r\n\r\n```\r\nAccess-Control-Allow-Origin: http://localhost:3000\r\n```\r\n\r\n\r\n\r\n\r\n响应头字段 | 功能说明 | 是否必填 | 可选值 \r\n---|---\r\nAccess-Control-Allow-Origin | 允许跨域访问的源地址 |  是 |  请求时`Origin`字段的值; 或 `*`，表示接受任意域名的请求\r\nAccess-Control-Allow-Origin | 允许跨域访问的源地址 |  是 |  请求时`Origin`字段的值; 或 `*`，表示接受任意域名的请求\r\n\r\n\r\n#### 预检请求\r\n非简单请求，即使用`PUT`、`DELETE`等方式或`Content-Type`字段的类型是`application/json`等值或包含自定义头信息字段。\r\n\r\n预检请求在正式发送请求之前会首先使用 `OPTIONS`   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。\"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。\r\n\r\n```\r\nOPTIONS /health.consume.default HTTP/1.1\r\nHost: 192.168.20.227:8080\r\nConnection: keep-alive\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nAccess-Control-Request-Method: POST\r\nOrigin: http://localhost:3000\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 Edg/80.0.361.69\r\nAccess-Control-Request-Headers: accesskey,appkey,content-type,method,nonce,sign,timestamp,token,version\r\nAccept: */*\r\nReferer: http://localhost:3000/\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n\r\n\r\nHTTP/1.0 200 OK\r\nDate: Mon, 23 Mar 2020 08:11:55 GMT\r\nServer: WSGIServer/0.2 CPython/3.6.5\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: accesskey, appkey, content-type, method, nonce, sign, timestamp, token, version\r\nAccess-Control-Allow-Methods: *\r\nContent-Length: 0\r\n```\r\n\r\n预检时，会包含属性`Origin`表示请求源，\r\n`Access-Control-Request-Method`表示请求方式，`Access-Control-Request-Headers`表示将携带这些自定义头部字段。 服务器决定实际请求是否被允许。\r\n\r\n服务器预检响应中包含\r\n\r\n预检响应头内容 | 说明 | 可选值  \r\n---|--- |---\r\n`Access-Control-Allow-Origin` | 所允许的请求源 | * \r\n`Access-Control-Allow-Headers` | 服务器允许请求中携带的字段 | 逗号分割的列表\r\n`Access-Control-Allow-Methods` | 服务器允许使用的请求方法 | *表示任意方法，或逗号分割的列表\r\n`Access-Control-Max-Age` | 预检有效时间，有效时间内无需再次预检 | number\r\n\r\n\r\n\r\n\r\n预检完成后，实际发送的请求如下：\r\n```\r\nPOST /health.consume.default HTTP/1.1\r\nHost: 192.168.20.227:8080\r\nConnection: keep-alive\r\nContent-Length: 15\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nOrigin: http://localhost:3000\r\nnonce: 6g49e\r\nsign: 0a6676d45a34dc2a5a9d8f8e880ca7143517e8e494b7b31b230c2bcb6cdac24c\r\nmethod: health.consume.default\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 Edg/80.0.361.69\r\nContent-Type: application/json;charset=UTF-8\r\ntimestamp: 1584951117903\r\naccesskey: Ksfu9gajQimzvanv\r\ntoken: vh0ajl93jn6s9\r\nappKey: wrY6f7KG\r\nversion: v1\r\nAccept: */*\r\nReferer: http://localhost:3000/\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n\r\n\r\nHTTP/1.0 200 OK\r\nDate: Mon, 23 Mar 2020 08:11:56 GMT\r\nServer: WSGIServer/0.2 CPython/3.6.5\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Allow-Headers: accesskey, appkey, content-type, method, nonce, sign, timestamp, token, version\r\nAccess-Control-Allow-Methods: *\r\nContent-Length: 3352\r\n```\r\n\r\n\r\n\r\n参考：   \r\n[MDN Web开发技术 —— HTTP访问控制（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)   \r\n[跨域资源共享 CORS 详解 —— 阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors.html) \r\n\r\n","timestamp":1585877701769},{"name":"01-readme.md","path":"001-前端/09-Webpack/01-readme.md","content":"","timestamp":1585877701769}]